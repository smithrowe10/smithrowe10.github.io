<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java学习笔记 | ming's blog</title><meta name="author" content="ming"><meta name="copyright" content="ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 java工作方式：  源代码：demo.java文件 编译器：运行源代码检查错误，将demo.java编译为demo.class文件，由字节码组成 输出：输出demo.class java虚拟机：运行demo.class文件，将字节码转换为平台能理解的形式  java程序结构：  源文件（source file） 2. 类（class file） 3. 方法（method）: 函数或过程 4">
<meta property="og:type" content="article">
<meta property="og:title" content="Java学习笔记">
<meta property="og:url" content="http://example.com/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ming&#39;s blog">
<meta property="og:description" content="前言 java工作方式：  源代码：demo.java文件 编译器：运行源代码检查错误，将demo.java编译为demo.class文件，由字节码组成 输出：输出demo.class java虚拟机：运行demo.class文件，将字节码转换为平台能理解的形式  java程序结构：  源文件（source file） 2. 类（class file） 3. 方法（method）: 函数或过程 4">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/smile_boy.jpg">
<meta property="article:published_time" content="2023-06-28T07:42:49.000Z">
<meta property="article:modified_time" content="2023-06-28T10:34:43.521Z">
<meta property="article:author" content="ming">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/smile_boy.jpg"><link rel="shortcut icon" href="/img/dog.png"><link rel="canonical" href="http://example.com/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-28 18:34:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/smile_boy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ming's blog"><span class="site-name">ming's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-28T07:42:49.000Z" title="Created 2023-06-28 15:42:49">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-28T10:34:43.521Z" title="Updated 2023-06-28 18:34:43">2023-06-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言">前言</h2>
<p><strong>java工作方式</strong>：</p>
<ul>
<li><strong>源代码</strong>：demo.java文件</li>
<li><strong>编译器</strong>：运行源代码检查错误，将demo.java编译为demo.class文件，由字节码组成</li>
<li><strong>输出</strong>：输出demo.class</li>
<li><strong>java虚拟机</strong>：运行demo.class文件，将字节码转换为平台能理解的形式</li>
</ul>
<p><strong>java程序结构</strong>：</p>
<ol>
<li>源文件（source file）<br>
2. 类（class file）<br>
3. 方法（method）: 函数或过程<br>
4. 语句（statement）</li>
</ol>
<p>java是面向对象的语言，所有东西都得包含在类里。</p>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>输入输出</li>
</ul>
<pre><code class="language-java">import java.util.Scanner;

class Input &#123;
    public static void main(String[] args) &#123;
        Scanner input = new Scanner(System.in);
        System.out.print(&quot;输入一个整数: &quot;);
        int number = input.nextInt();
        System.out.println(&quot;您输入 &quot; + number);
        
        //获取double输入
        double myDouble = input.nextDouble();
    	
        //获取字符串输入
        String myString = input.next(); //以空格结束
        input.useDelimiter(&quot;\n&quot;); // 设置为以换行结束
        String myString = input.nextline(); // 以回车结束 

        //关闭scanner对象
        input.close();
    &#125;
&#125;
</code></pre>
<ul>
<li>数据类型</li>
</ul>
<pre><code class="language-java">int x =0
string[] str = 'hello world!'
println() //输出加换行
int len = str.length
int x = (int) 24.6 //类型转换
while(flag)&#123;&#125;//java中integer与boolean两个类型不相容，故flag必须为boolean类型 
</code></pre>
<ul>
<li>Java数组</li>
</ul>
<pre><code class="language-java">int[] myList;         // 数组变量声明，首选的方法
int myList[];         //  效果相同，但不是首选方法
array = new int[arraySize];     // 创建数组
int[] array = new int[arraySize];   // 数组变量声明 + 创建数组
int[] array = &#123;0,1,2&#125;;
Arrays.sort(array); // 数组排序
int[][] a = new int[2][3];// 二维数组创建
</code></pre>
<p>*** 在Java中，<strong>动态数组</strong>是通过ArrayList实现的。可以使用add()方法向ArrayList中添加元素。以下是添加元素的示例代码：</p>
<pre><code class="language-java">ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();

// 向数组末尾添加元素
arrayList.add(&quot;元素1&quot;);
arrayList.add(&quot;元素2&quot;);
arrayList.add(&quot;元素3&quot;);

// 在指定位置添加元素
arrayList.add(1, &quot;新元素&quot;);

System.out.println(arrayList); // 输出 [元素1, 新元素, 元素2, 元素3]

arrayList.sort(Comparator.naturalOrder());// 升序排列
arrayList.sort(Comparator.reverseOrder()); // 降序
arrayList.size()
</code></pre>
<p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p>
<pre><code class="language-java">for(type element: array)
&#123;
    System.out.println(element);
&#125;
</code></pre>
<ul>
<li>
<p>可变参数列表：</p>
<pre><code class="language-java">// 使用数组语法实现可变参数列表
public void printArray(Object[] args)&#123;
    for(Object obj: args)&#123;
    System.out.println(obj + &quot; &quot;);
    &#125;
&#125;
// 使用省略号实现可变参数列表
public void printArray(Object... args)&#123;
    for(Object obj: args)&#123;
    System.out.println(obj + &quot; &quot;);
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>枚举类型：多用在swith语句中；</p>
<pre><code class="language-java">public enum Color&#123;
    RED,BLUE,WHITE,GREEN
&#125;

Color color = Color.RED;
</code></pre>
</li>
<li>
<p>java中的全局变量与全局方法：任何变量只要加上public，static和final，基本上都会变成全局变量取用的常数。这是一种近似全局的事物，他们也必须定义在类中。</p>
</li>
<li>
<p>java是通过<strong>值传递</strong>的，也就是通过拷贝传递；</p>
<ul>
<li>传递基本类型参数：方法接收到的是参数的拷贝，会创建副本；</li>
<li>传递引用类型参数：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本；</li>
</ul>
</li>
<li>
<p>什么是自动拆装箱？</p>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
</li>
</ul>
<h2 id="面向对象">面向对象</h2>
<ul>
<li>
<p><strong>面向对象和面向过程</strong></p>
<ul>
<li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li>
<li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。（<strong>面向对象开发的程序一般更易维护、易复用、易扩展。</strong>）</li>
</ul>
</li>
<li>
<p>对象具有接口</p>
<ul>
<li>
<p>对象能够接受什么请求是由它的<strong>接口</strong>（interface）决定的，而接口由对象所归属的类定义；</p>
<pre><code class="language-java">// 类型
class Light&#123;
    public void on()&#123; // 接口
        
    &#125;
    public void off()&#123; // 接口
        
    &#125;
&#125;

Light lt = new Light();  // 创建对象
lt.on();// 对象发出请求
</code></pre>
</li>
</ul>
</li>
<li>
<p>对象和对象引用</p>
<ul>
<li>new运算符创建对象，存放在堆内存中；</li>
<li>对象引用指向对象，存放在栈内存中；</li>
</ul>
<pre><code class="language-java">Person person = new Person()\\ person:对象引用
</code></pre>
</li>
<li>
<p>对象相等和引用相等</p>
<ul>
<li>对象相等：内存中的内容相等；</li>
<li>引用相等：内存的地址相等；</li>
</ul>
</li>
<li>
<p>面向对象三大特征</p>
<ul>
<li>
<p><strong>封装</strong></p>
<ul>
<li>实例变量标记为<strong>private</strong></li>
<li>提供公有的getters与setters，标记为<strong>public</strong>，来控制存取动作</li>
<li><strong>public</strong>：可以被所有人访问；<strong>private</strong>：只能被类的创建者通过自身的方法访问；<strong>protected</strong>：类似于private，但是区别是继承的子类可以访问；</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
</li>
<li>
<p><strong>多态</strong></p>
<ul>
<li>存在的三个必要条件：继承，重写，父类引用指向子类对象 <strong>Parent p = new Child()</strong></li>
</ul>
<pre><code class="language-java">class Shape &#123;
    void draw() &#123;&#125;
&#125;
 
class Circle extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;Circle.draw()&quot;);
    &#125;
&#125;·
 
class Square extends Shape &#123;
    void draw() &#123;
        System.out.println(&quot;Square.draw()&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>
<p>参数化类型（泛型）</p>
<ul>
<li>
<p>一个被参数化的类型是一个特殊的类，可以让编译器自动适配特定的类型；</p>
</li>
<li>
<p>例如，编译器可以将集合定义为只接受放入shape的对象，因此集合中也只能取出shape对象；</p>
<pre><code class="language-java">ArrayList&lt;shape&gt; shapes = new ArraytList&lt;&gt;();\\ 创建一个防止shape对象的ArrayList
</code></pre>
</li>
</ul>
</li>
<li>
<p>对象的创建和生命周期</p>
<ul>
<li>创建一个新对象时，可以通过堆内存来创建，因为堆是在运行时动态管理内存的；</li>
<li>java只允许<strong>动态分配内存</strong>，当创建一个新对象时，都需要通过new操作符创建一个对象的动态实例；</li>
<li>java底层支持<strong>垃圾收集器</strong>机制，它知道一个对象何时不会再用，并自动释放该对象占用的内存；</li>
</ul>
</li>
<li>
<p>异常处理</p>
</li>
</ul>
<h2 id="对象">对象</h2>
<ul>
<li>
<p>数据保存的地方</p>
<ul>
<li>寄存器：数据直接保存在中央处理器（CPU），存储速度最快；</li>
<li>栈：数据存储在RAM里，效率仅次于寄存器；</li>
<li>堆：是一个通用的内存池（也使用RAM），用于存放所有的java对象；</li>
<li>常量：直接保存在程序代码中；</li>
</ul>
</li>
<li>
<p>static关键字</p>
<ul>
<li>使用static的字段或方法不依赖于对象；</li>
<li>即便没有为这个类创建对象，也可以调用该类的static方法和static字段；</li>
</ul>
<pre><code class="language-java">class test&#123;
    static int x = 0;
&#125;

test t1 = new test();
test t2 = new test();
// 即便创建了两个对象，test.x只会占用同一块空间
// t1.x和t2.x均为0
</code></pre>
</li>
</ul>
<h2 id="操作符">操作符</h2>
<ul>
<li>
<p><strong><code>==</code></strong> 和 <strong><code>equals ()</code></strong> 的区别：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
<li><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来<strong>判断两个对象是否相等</strong></li>
</ul>
<pre><code class="language-java">String a = new String(&quot;ab&quot;); // a 为一个引用
String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样
String aa = &quot;ab&quot;; // 放在常量池中
String bb = &quot;ab&quot;; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
</code></pre>
</li>
</ul>
<h2 id="初始化和请理">初始化和请理</h2>
<ul>
<li>
<p>构造器进行初始化</p>
<ul>
<li>构造器的名字就是类的名字；</li>
<li>构造器也可以传入参数来指定如何创建对象；</li>
</ul>
<pre><code class="language-java">class Rock&#123;
    Rock()&#123; //无参构造器
        System.out.print(&quot;Rock&quot;)
    &#125;
    Rock(int x)&#123; //构造器
        System.out.print(&quot;Rock&quot; + x );
    &#125;
&#125;
</code></pre>
</li>
<li>
<p><strong>方法重载</strong></p>
<ul>
<li>允许不同参数类型的方法<strong>具有相同的名字</strong>；例如可以创建一个无参构造器和有参数传递的构造器；</li>
<li>每个重载方法必须有<strong>独一无二的参数列表</strong>；</li>
</ul>
</li>
<li>
<p><strong>重写</strong></p>
<ul>
<li><strong>@override</strong>注解，表示该方法是一个重写（Override）父类中的方法，而不是在子类中定义一个新的方法；</li>
<li>@Override注解只能应用于重写父类中的方法，而不能应用于接口中的方法或静态方法。</li>
</ul>
</li>
<li>
<p>无参构造器</p>
<ul>
<li>如果你没有创建构造器，系统会自动为这个类创建一个无参构造器；</li>
<li>但如果你已经创建了构造器，即便没有无参构造器，系统都不会再自动创建了；</li>
</ul>
</li>
<li>
<p><strong>this</strong>关键字</p>
<ul>
<li>this 表示对当前对象的引用；</li>
<li>只能在非静态方法中使用；</li>
</ul>
<pre><code class="language-java">class Person&#123;
    private String name;
    private int age;
    
    public Person(String name,int age)&#123;
        this.name = name;
        this.age = age;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>finalize()方法</p>
<ul>
<li>Java中：
<ul>
<li>对于一些特殊的内存，垃圾处理器可能不知道怎么释放；</li>
<li>垃圾收集不是析构；</li>
<li>垃圾收集仅与内存有关；</li>
</ul>
</li>
<li>finalize()的使用仅限于一种特殊情况，对象以某种方式分配空间，而不是通过创建对象来分配；</li>
</ul>
</li>
<li>
<p><strong>垃圾收集器的工作原理</strong></p>
<ul>
<li>java中的堆更像一个传送带，“堆指针”只是简单的移动到尚未分配的区域，而垃圾收集器的介入可以使“堆指针”移到靠近传送带的地方，由此构建了一个高速的，有无限空闲空间的堆模型；</li>
<li><strong>引用计数</strong>：每个对象都有一个引用计数器，每次该对象被引用时，引用计数都会增加；离开作用域或设置为null时计数器减小；</li>
<li><strong>停止-复制</strong>：该算法将可用内存空间分为两部分，每次只使用其中一部分。当一部分内存用完后，将未被回收的对象复制到另一部分内存中，并清除原来的内存。该算法的优点是简单高效，缺点是需要额外的内存空间。</li>
<li><strong>标记-清除</strong>：该算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后进行清除。该算法的缺点是会产生内存碎片，容易导致频繁的内存分配和回收。</li>
</ul>
</li>
</ul>
<h2 id="实现隐藏">实现隐藏</h2>
<ul>
<li>控制访问被称为<strong>实现隐藏</strong>；</li>
<li>将数据和方法包装在类中，并与实现隐藏结合，称为<strong>封装</strong>；</li>
<li><strong>类不能是private或protected的</strong>；如果想要防止对该类的访问，可以将该类的构造器都设为priate；</li>
</ul>
<h2 id="复用">复用</h2>
<ul>
<li>
<p><strong>组合</strong></p>
<ul>
<li>组合就是 A类的对象是B类的成员变量。相当于 A类对象是B类对象的一个变量，A类中的所有功能，B类都可以通过A类对象的调用来实现。</li>
<li>组合体现的是整体与部分、拥有的关系，即 has - a 的关系</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li>
<p>继承在面向对象语言中必不可少；其实创建一个类时，总是在继承，除非明确指定要继承某个类，否则都会<strong>隐式继承java的标准根类Object</strong>；</p>
</li>
<li>
<p>使用<strong>extends</strong>关键字，可以使用基类中的方法，还可以向子类中添加新方法；</p>
</li>
<li>
<p>创建对象时，构造过程是由基类 “向外” 进行的；即便没有为子类创建构造器，编译器也会自动创建一个可以调用基类的无参构造器；</p>
</li>
<li>
<p>如果基类没有无参构造器，那么就需要用 <strong>Super</strong>关键字来显示的调用构造器；</p>
<pre><code class="language-java">class Art&#123;
    Art(int i)&#123;
        ...
    &#125;
&#125;

class Draw extends Art&#123;
    Draw(int i)&#123;
        super(i); // 调用基类构造器
        ...
    &#125;
&#125;

public Cartoon extends Draw&#123;
    Cartoon()&#123;
        super(11); // 调用基类构造器
        ...
    &#125;
    public static void main()&#123;&#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>向上转型</strong></p>
<ul>
<li>
<p>在Java中，子类继承了父类的所有方法和属性，因此<strong>子类对象可以被当做父类对象来使用</strong>。这种将子类对象转换为父类对象的过程就是向上转型。</p>
</li>
<li>
<p>向上转型总是安全的，因为是从更具体的类型转换为更通用的类型；</p>
<pre><code class="language-java">class Animal &#123;
    public void eat() &#123;
        System.out.println(&quot;Animal is eating.&quot;);
    &#125;
&#125;

class Dog extends Animal &#123;
    public void bark() &#123;
        System.out.println(&quot;Dog is barking.&quot;);
    &#125;
&#125;

public class Test &#123;
    public static void main(String[] args) &#123;
        Animal animal = new Dog();  // 创建了一个Dog对象，并将其赋值给Animal类型的变量animal,完成向上转型
        animal.eat();  // 调用父类方法 // 动态绑定
        animal.bark();  // 编译错误，父类不能访问子类特有的方法
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>final</strong></p>
<ul>
<li>final，static表示是一个常量；</li>
<li>空白 final：即没有被初始化的final字段；必须在构造器里进行初始化，保证了final字段在使用之前总是被初始化；</li>
<li>final参数：只能读取，不能修改参数；</li>
<li>final类：该类不能被继承；</li>
</ul>
</li>
</ul>
<h2 id="多态">多态</h2>
<ul>
<li>
<p>多态是指同一个方法或者同一个类在不同的情况下表现出不同的行为。Java中的多态性主要通过方法的重载和覆盖以及向上转型实现。</p>
<pre><code class="language-java">class Animal&#123;
    public void eat()&#123;&#125;
&#125;

public class cat extends Animal&#123;
   @override public void eat()&#123;&#125;
&#125;

public class zoo&#123;
    public void manage(Animal i)&#123; //方法接收一个Animal引用，他怎么知道这个引用在这里指的是cat，而不是dog，pig?
        i.eat();
    &#125;
    public static void main()&#123;
        cat cat1 = new cat();
        manage(cat1); // 向上转型
    &#125;
&#125;
</code></pre>
</li>
<li>
<p><strong>方法调用绑定</strong></p>
<ul>
<li><strong>前期绑定</strong>：在程序运行之前执行绑定，面向过程语言中默认是前期绑定；在多态中，困惑的点在于，编译器中只有一个基类引用时，怎么确定哪个才是要调用的正确方法；</li>
<li><strong>后期绑定</strong>（动态绑定）：是指在运行时根据对象的实际类型来调用相应的方法；java中所有方法都是动态绑定，除非方法是static或final的；</li>
</ul>
</li>
<li>
<p><strong>构造器和多态</strong></p>
<ul>
<li>构造器的调用顺序
<ul>
<li>基类构造器被调用，然后是子类；</li>
<li>按声明的顺序初始化成员变量；</li>
<li>最后执行子类构造器的方法体；</li>
</ul>
</li>
<li>构造器内部的多态方法行为
<ul>
<li>构造器负责创建对象，如果在构造器内调用动态绑定方法，则可以调用尚未被初始化的成员的方法——<strong>这将会导致灾难</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="抽象类">抽象类</h2>
<ul>
<li>
<p><strong>抽象方法</strong>只有一个声明，没有方法体；</p>
<pre><code class="language-java">abstract void f();
</code></pre>
</li>
<li>
<p><strong>包含抽象方法的类</strong>称为抽象类，抽象类（Abstract Class）是一种<strong>不能被实例化的类，它只能作为其他类的父类</strong>，用于定义一些抽象方法和非抽象方法；</p>
<pre><code class="language-java">absrtact class Basic&#123;
    abstract void f();
    void m();
&#125;

Basic b = new Basic(); // 错误的，抽象类不能被实例化
</code></pre>
</li>
<li>
<p>如果要创建一个可实例化的类，继承抽象类后<strong>要为所有的抽象方法提供定义</strong>；</p>
<pre><code class="language-java">public class A extends Basic()&#123;
    @override void f()&#123;
        System.out.print(&quot;hello!&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="接口">接口</h2>
<ul>
<li>
<p>用<strong>interface</strong>关键字创建了一个完全抽象的类，它不代表任何实现；</p>
<pre><code class="language-java">public interface Instrument&#123;
    void f1();
    int f2();
    public static final int N = 4; //接口中的字段必须被声明为 public static final
    
    default void f3()&#123;
        System.out.print(&quot;hello!&quot;); // default关键字允许我们在接口中实现方法
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>使用<strong>implements</strong>关键字创建一个符合特定接口的类，表示要提供它的定义；</p>
<pre><code class="language-java">public class guitar implements Instrument&#123;
     @override public void f1()&#123; // 来自接口的方法必须被定义为public
        System.out.print(&quot;hello!&quot;);
     &#125;
     @override public int f2()&#123;
        return 1;
     &#125;
&#125;
</code></pre>
</li>
<li>
<p><strong>多重继承</strong></p>
<ul>
<li>Java通过接口来解决多继承问题。一个类可以实现多个接口，从而具有多个不同的行为。</li>
</ul>
</li>
<li>
<p><strong>抽象类与接口</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">接口</th>
<th style="text-align:center">抽象类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">组合</td>
<td style="text-align:center">可在新类中组合多个接口</td>
<td style="text-align:center">只能继承一个抽象类</td>
</tr>
<tr>
<td style="text-align:center">状态</td>
<td style="text-align:center">不能包含字段（静态字段除外）</td>
<td style="text-align:center">可以包含字段，且非抽象方法可以引用这些字段</td>
</tr>
<tr>
<td style="text-align:center">默认方法&amp;抽象方法</td>
<td style="text-align:center">默认方法不需要在子类中实现，它只能引用子接口中的方法</td>
<td style="text-align:center">抽象方法必须在子类中实现</td>
</tr>
<tr>
<td style="text-align:center">构造器</td>
<td style="text-align:center">不能有构造器</td>
<td style="text-align:center">可以有构造器</td>
</tr>
<tr>
<td style="text-align:center">访问权限</td>
<td style="text-align:center">隐式的public</td>
<td style="text-align:center">可以为protected或包访问权限</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>工厂方法</strong>设计模式</p>
<ul>
<li>
<p>产生某个接口的对象时，不是直接调用构造器，而是在工厂对象上直接调用构建方法；</p>
<pre><code class="language-java">// 动物接口
interface Animal &#123;
    void speak();
&#125;

// 工厂接口
interface AnimalFactory &#123;
    Animal createAnimal();
&#125;

// 狗类
class Dog implements Animal &#123;
    public void speak() &#123;
        System.out.println(&quot;汪汪汪！&quot;);
    &#125;
&#125;

// 猫类
class Cat implements Animal &#123;
    public void speak() &#123;
        System.out.println(&quot;喵喵喵！&quot;);
    &#125;
&#125;

// 狗工厂类
class DogFactory implements AnimalFactory &#123;
    @override public Animal createAnimal() &#123;
        return new Dog();
    &#125;
&#125;

// 猫工厂类
class CatFactory implements AnimalFactory &#123;
    @override public Animal createAnimal() &#123;
        return new Cat();
    &#125;
&#125;

public class Factories&#123;
    public static void animalAct(AnimalFactory fact)&#123;
        Animal a = fact.createAnimal();
        a.speak();
    &#125;
    public static void main()&#123;
        animalAct(new DogFactory());
        animalAct(new CatFactory());
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>
<p>接口的新特性</p>
<ul>
<li>
<p>接口中可以加入private的方法，这些方法只能被接口内的其他方法调用;</p>
<pre><code class="language-java">public interface Instrument&#123;
    private void f1()&#123;           // 默认是default的
        System.out.print(&quot;hello!&quot;);
    &#125;   
    default void f2()&#123;
         f1();
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="内部类">内部类</h2>
<ul>
<li>
<p>创建内部类</p>
<ul>
<li>内部类即定义在其他类内的类；</li>
<li>在外部创建非静态内部类的对象的时候，必须将对象的类型指定为 OuterClassName.InnerClassName</li>
</ul>
</li>
<li>
<p>为何使用内部类</p>
<ul>
<li>可以<strong>隐藏细节和内部结构</strong>，封装性更好；</li>
</ul>
</li>
<li>
<p>内部类可以访问外围类的所有成员（当创建一个内部类时，内部类的对象会隐含一个链接指向创建该对象的外围对象）</p>
</li>
<li>
<p>要使用外部类的名字，可以使用 OuterName.this ;</p>
<pre><code class="language-java">public class DotThis&#123;
    void f()&#123;&#125;;
    public class Inner()&#123; // 内部类
        public DotThis outer()&#123;
            return DoThis.this;    // 如果使用”this“，引用的会是Inner的”This“
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="集合">集合</h2>
<ul>
<li>
<p>利用泛型指定保存在集合中对象的类型</p>
<pre><code class="language-java">import java.util.*;
ArrayList&lt;Apple&gt; apple = new ArrayList&lt;&gt;(); // 编译时将阻止我们将错误的类型的对象放入某个集合中
</code></pre>
</li>
<li>
<p>Java 集合类库（可以表示为库的两个基本接口）</p>
<ul>
<li>
<p><strong>Collection</strong>：一个由单独元素组成的序列；</p>
<ul>
<li><strong>List</strong> ：必须按元素插入顺序来保存他们；
<ul>
<li><code>ArrayList</code> 和 <code>LinkedList</code>类</li>
</ul>
</li>
<li><strong>Set</strong>：不能存在重复元素；
<ul>
<li><code>HashSet</code>：查找速度最快；</li>
<li><code>TreeSet</code>：按添加顺序升序保存对象；</li>
<li><code>LinkedHashSet</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；</li>
</ul>
</li>
<li><strong>Queue</strong>：先进先出</li>
</ul>
</li>
<li>
<p><strong>Map</strong> ：一组键值对对象，使用键来查找值；</p>
<ul>
<li>
<p>List使用数值来查找某个对象，而<strong>Map使用另一个对象来查找某个对象</strong>，它将对象与对象关联在了一起，因此也被称为关联<strong>数组</strong> or <strong>字典</strong></p>
</li>
<li>
<p>操作</p>
<pre><code class="language-java">Map.put(key,value);  //添加键值对
Map.get(key) // 查值
</code></pre>
</li>
<li>
<p>三种风格</p>
<ul>
<li><code>HashMap</code>：查找顺序最快；</li>
<li><code>TreeMap</code>：按添加元素的升序排列；</li>
<li><code>LinkedHashMap</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>List</strong></p>
<ul>
<li>
<p>分类</p>
<ul>
<li><code>ArrayList</code>：<strong>访问性能好，中间插入或删除元素的速度慢；</strong></li>
<li><code>LinkedList</code>：<strong>访问性能差，但是中间插入或删除元素的成本低；</strong></li>
</ul>
</li>
<li>
<p><code>ArrayList</code>常用方法</p>
<pre><code class="language-java">add();  // 添加元素
addAll();   // 添加所有元素
contains();  // 确定某个对象是否在列表中
remove();  // 移除对象
get(i);   // 通过索引获取元素
indexOf(value);  // 获得List中的索引编号
size(); // 元素数量
set(i，v); // 替换指定索引的元素
sort(); //排序
toString(); // 转换为字符串
isEmpty(); // 判空
</code></pre>
</li>
<li>
<p>迭代器（<strong>Iterator</strong>）</p>
<ul>
<li><code>Iterator</code>是一种用于遍历集合类（如<code>ArrayList</code>、<code>HashSet</code>等）元素的接口。通过使用<code>Iterator</code>接口，可以在不暴露集合内部结构的情况下，逐个访问集合中的元素。</li>
<li><code>Iterator</code>能够<strong>将序列的遍历操作和底层结构分离</strong>，即迭代器<strong>统一了对集合的访问</strong>；</li>
<li><code>Iterator</code>接口包含以下常用方法：
<ul>
<li><code>boolean hasNext()</code>：如果迭代器还有下一个元素，则返回<code>true</code>。</li>
<li><code>E next()</code>：返回迭代器的下一个元素。</li>
<li><code>void remove()</code>：从迭代器返回的集合中删除迭代器最后一个元素。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>LinkedList</code>常用方法</p>
<pre><code class="language-java">getFirst()  element()  peek() // 均为返回列表的头部     
removeFirst()   remove()   // 移除并返回列表头部
add()  addLast()  offer()  //在列表尾部插入元素
addFirst()  //列表开头插入元素
removeLast() // 移除并返回列表的最后一个元素
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Stack</strong></p>
<ul>
<li>通过<code>LinkedList</code>提供</li>
</ul>
<pre><code class="language-java">Stack&lt;String&gt; s = new Stack&lt;&gt;();
s.push(&quot;hello!&quot;);
s.pop();
s.peek(); // 返回栈顶元素
</code></pre>
</li>
<li>
<p><strong>Set</strong></p>
<ul>
<li>
<p>不允许有重复元素出现</p>
</li>
<li>
<p>常用来测试成员身份</p>
<pre><code class="language-java">Set&lt;String&gt; set1 = new HashSet&lt;&gt;();
Collections.addAll(set1,&quot;A B C D E&quot;.split(&quot; &quot;));
set1.contains(&quot;D&quot;);// true
set1.containsAll(set2);
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>Map</strong></p>
<ul>
<li>
<p>对象映射到对象</p>
<pre><code class="language-java">Map&lt;String,Pet&gt; petMap = new Map&lt;&gt;();
petMap.put(&quot;My cat&quot;,new Cat(&quot;mm&quot;));
petMap.put(&quot;My dog&quot;,new Dog(&quot;ww&quot;));
Pet dog = petMap.get(&quot;My dog&quot;); // &quot;ww&quot;
petMap.getOrDefault(key,&quot;Not Found&quot;) // 获取指定 key 对应对 value，如果找不到则返回设置的默认值。
petMap.containsKey(&quot;My cat&quot;); // true
petMap.containsValue(dog); // true
</code></pre>
</li>
<li>
<p><code>HashMap</code></p>
<ul>
<li>
<p><code>HashMap</code> 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全的</strong>。</p>
<p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个;</p>
</li>
<li></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Queue</strong></p>
<ul>
<li>
<p>典型的先进先出（<strong>FIFO</strong>）的集合。</p>
</li>
<li>
<p><code>LinkedList</code>实现了<code>Queue</code>接口，提供了支持队列行为的方法，因此可以通过将<code>LinkedList</code>向上转型为<code>Queue</code>实现队列；</p>
<pre><code class="language-java">// 普通队列
Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();
q.offer(); // 队列特有的操作，队列尾部插入元素
q.peek(); // 返回头部，若队列为空，则返回NULL   
q.element();  // 返回头部，若队列为空，则报错
q.poll();  // 删除头部元素，若队列为空，则返回NULL
q.remove(); // 删除头部元素，若队列为空，则报错

// 双端队列
Deque&lt;Integer&gt; dq = new LinkedList&lt;&gt;();
dq.offerLast();
dq.peekFirst();
dq.getFirst();
dq.pollFirst();
dq.removeFirst();
</code></pre>
</li>
<li>
<p><code>PriorityQueue</code></p>
<ul>
<li>
<p>优先级最高的元素先出；</p>
</li>
<li>
<p>当一个元素被加入队列，会先进行排序再加入；</p>
<pre><code class="language-java">PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); 
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数式编程">函数式编程</h2>
<ul>
<li>
<p>通过整合现有代码来产生新功能，而不是从零开始编写所有内容；</p>
<p><strong>面向对象编程抽象数据，而函数式编程抽象行为</strong></p>
</li>
<li>
<p><strong>lambda 表达式</strong></p>
<ul>
<li>
<p>基本语法：</p>
<ul>
<li>参数；</li>
<li>后面跟 - &gt;，可以读为产生；</li>
<li>-&gt; 后面都是方法体。</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; strings = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);
List&lt;String&gt; upperCaseStrings = strings.stream()
    .map(str -&gt; str.toUpperCase()) // map()方法接受一个lambda表达式作为参数，该表达式将字符串转换为大写字母。                                      //由于lambda表达式只有一个参数，因此可以省略参数列表的括号。
    .forEach(System.out::println);
</code></pre>
</li>
<li>
<p>编写递归的lambda表达式；</p>
</li>
</ul>
</li>
<li>
<p><strong>方法引用</strong></p>
<ul>
<li>基本语法 ：<code>类名or对象名</code> +  <code>::</code>  + <code>方法名</code></li>
</ul>
<pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);
list.stream().map(String::toUpperCase).forEach(System.out::println);
</code></pre>
<ul>
<li>直接引用已有的方法或构造函数，而不需要像lambda表达式那样创建新的方法体。</li>
<li><code>Runnable</code></li>
</ul>
<pre><code class="language-java">class Go &#123;
    static void go() &#123;
        System.out.println(&quot;go!&quot;);
    &#125;
&#125;

public class Main &#123;
    public static void main(String[] args) &#123;
        // Thread 对象接受一个Runnable作为其构造器参数，start()方法会调用该引用的方法（run()）
        new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                System.out.println(&quot;hello&quot;);
            &#125;
        &#125;).start();
        
        new Thread(Go::go).start();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="流">流</h2>
<ul>
<li>
<p>“ 集合优化了对象的存储，而<strong>流</strong>（stream）与对象的成批处理有关 ”</p>
</li>
<li>
<p><strong>声明式编程</strong>，直接说明想要完成<strong>什么</strong>（how），而不是<strong>怎么做</strong>（what）</p>
<pre><code class="language-java">public class Stream &#123;
    public static void main(String[] args)&#123;
        new Random(1)
            .ints(2, 10)
            .limit(5)
            .sorted()
            .forEach(System.out::print);
    &#125; 
&#125;
</code></pre>
</li>
</ul>
<h2 id="异常">异常</h2>
<ul>
<li>
<p><strong>捕获异常</strong></p>
<pre><code class="language-java">try&#123;
    // 可能会产生异常的代码
&#125;catch()&#123;
    // 异常处理程序
&#125;

try&#123;
    // 可能会产生异常的代码
&#125;catch()&#123;
    // 异常处理程序
&#125;catch()&#123;
    
&#125;finally&#123;
    // 不管怎么样都会执行
&#125;
</code></pre>
</li>
</ul>
<h2 id="反射">反射</h2>
<ul>
<li>
<p>反射可以在程序运行时发现并使用对象的类型的<strong>所有信息</strong>；反射允许对类的成员变量，成员方法和构造方法进行编程访问；</p>
</li>
<li>
<p><strong>Class 对象</strong></p>
<ul>
<li>
<p>程序中每个类都会有一个Class 对象，它包含了与类相关的信息；</p>
</li>
<li>
<p>获取Class对象的三种方式：</p>
<ul>
<li><code>Class.forName(&quot;类名&quot;)</code></li>
<li><code>类名.class</code></li>
<li><code>对象.getClass( )</code> （已经创建了对象后才能使用）</li>
</ul>
</li>
<li>
<p>万物皆对象</p>
<ul>
<li>字节码文件：<code>Class</code>类的对象；</li>
<li>构造方法：<code>Constructor</code>类的对象；</li>
<li>成员变量：<code>Field</code>类的对象；</li>
<li>成员方法：<code>Method</code>类的对象；</li>
</ul>
</li>
<li>
<p>获取Class对象的方式</p>
<pre><code class="language-java">// 类名.class
Class clazz1 = User.class;

// 对象.getClass()
Class clazz2 = new User().getClass();

// Class.forName(&quot;全路径&quot;)
Class clazz3 = Class.forName(&quot;com.lm.User&quot;);

// 实例化
User user =(User)clazz1.getDeclaredConstructor().newInstance();
</code></pre>
</li>
<li>
<p>获取构造方法</p>
<pre><code class="language-java">Class clazz = User.class;
        
// 获取所有public构造方法
Constructor[] constructors1 = clazz.getConstructors();
        
// 获取所有构造方法(包括private)
Constructor[] constructors2 = clazz.getDeclaredConstructors();

// 指定有参数构造创建对象
//public        
Constructor c1 = clazz.getConstructor(String.class,int.class);        
User user1 = (User)c1.newInstance(&quot;ming&quot;,21);  
// private
Constructor c2 = clazz.getDeclaredConstructor(String.class, int.class);        
c2.setAccessible(true); // 设置允许访问        
User user2 = (User)c2.newInstance(&quot;ming&quot;,21);
</code></pre>
</li>
<li>
<p>获取属性</p>
<pre><code class="language-java">Class clazz = User.class;
// 获取所有public属性
Field[] fields1 = clazz.getFields();
        
// 获取所有属性（包括private）
Field[] fields2 = clazz.getDeclaredFields();
</code></pre>
</li>
<li>
<p>获取方法</p>
<pre><code class="language-java">User user = new User(&quot;ming&quot;,21);
Class clazz = user.getClass();

// public 方法
Method[] methods1 = clazz.getMethods();
for(Method m:methods1)&#123;
    if(m.getName().equals(&quot;toString&quot;))&#123;
        m.invoke(user); // 执行 toString()方法
    &#125;
&#125;

// private
Method[] methods2 = clazz.getDeclaredMethods();
for(Method m:methods2)&#123;
    if(m.getName().equals(&quot;run&quot;))&#123;
        m.setAccessible(true); // 设置允许访问
        m.invoke(user); // 执行 private run()方法
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li>
<p>转型前检查</p>
<ul>
<li>在java中，可以使用<code>instanceof</code>关键字检查一个对象是否是某个类的实例；</li>
</ul>
<pre><code class="language-java">if(x instanceof Dog)&#123;
    ((DOg)x).bark();
&#125;
</code></pre>
</li>
<li>
<p>动态代理（proxy）</p>
<ul>
<li>在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术；</li>
<li><strong>AOP</strong>思想：基于动态代理思想，对原来目标对象创建代理对象，在不修改原对象代码情况下，通过代理对象调用增强功能的代码，从而对原有业务方法进行增强。</li>
</ul>
</li>
</ul>
<h2 id="泛型">泛型</h2>
<ul>
<li>
<p>让代码只需依赖于 &quot; <strong>某种不具体指定的类型</strong> &quot;，而不是特定的接口或类，那么就可以编写出更为通用的代码；</p>
</li>
<li>
<p>泛型类：</p>
<pre><code class="language-java">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;&#123; 
    //key这个成员变量的类型为T,T的类型由外部指定  
    private T key;

    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定
        this.key = key;
    &#125;

    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定
        return key;
    &#125;
&#125;

</code></pre>
</li>
<li>
<p>泛型接口</p>
<pre><code class="language-java">//定义一个泛型接口
public interface Generator&lt;T&gt; &#123;
    public T next();
&#125;
</code></pre>
</li>
<li>
<p>类型通配符</p>
<pre><code class="language-java">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;
    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());
&#125;
// 类型通配符一般是使用？代替具体的类型实参
// 此处’？’是类型实参，而不是类型形参!!!
// ?和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。
</code></pre>
</li>
<li>
<p>泛型方法</p>
<pre><code class="language-java">// 定义一个泛型方法，需要将泛型参数列表(&lt;T&gt;)放在返回值之前(必不可少！)
public &lt;T&gt; void f(T x)&#123;
    System.out.println(x.getClass().getName());
&#125;
</code></pre>
</li>
</ul>
<h1>Java多线程</h1>
<h2 id="多线程的概念">多线程的概念</h2>
<ul>
<li>
<p><strong>进程</strong>：程序的基本执行实体（例如电脑中运行的某个软件）</p>
</li>
<li>
<p><strong>线程</strong>：线程是操作系统能够运算调度的最小单位。它被包含在进程中，是<strong>进程</strong>的实际运作单位。</p>
</li>
<li>
<p><strong>多线程</strong>：程序同时执行多个任务；</p>
</li>
<li>
<p><strong>并发</strong>(<code>concurrent</code>)指在java程序中同时运行多个线程；（同一时刻，多个指令在<strong>单个CPU</strong>上<strong>交替执行；</strong>）</p>
</li>
<li>
<p><strong>并行</strong>：同一时刻，多个指令在<strong>多个CPU</strong>上<strong>同时执行；</strong></p>
</li>
</ul>
<h2 id="多线程的实现方式">多线程的实现方式</h2>
<ul>
<li>
<p>实现方式一：自己定义一个继承自<code>Thread</code>的类，重写<code>run</code>方法；</p>
<pre><code class="language-java">public class Thread1 extends Thread&#123;
    @Override
    public void run() &#123;
        for(int i=0;i&lt;10;i++)&#123;
            System.out.println(getName() +&quot; hello world!&quot;);
        &#125;
    &#125;
&#125;

// 测试
public class MyThread &#123;
    public static void main(String[] args) &#123;
        Thread1 t1 = new Thread1();
        t1.setName(&quot;线程1&quot;);
        Thread1 t2 = new Thread1();
        t2.setName(&quot;线程2&quot;);

        t1.start();
        t2.start();

    &#125;
&#125;
// 运行结果
线程2 hello world!
线程1 hello world!
线程1 hello world!
线程1 hello world!
线程1 hello world!
线程2 hello world!
线程2 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
线程1 hello world!
线程2 hello world!
</code></pre>
</li>
<li>
<p>实现方式二：</p>
<ul>
<li>自己定义一个类实现<code>Runnable</code>接口，重写<code>run</code>方法；</li>
<li>创建一个自己类的对象，创建Thread类的对象，并开启线程；</li>
</ul>
<pre><code class="language-java">public class Thread2 implements Runnable&#123;
    @Override
    public void run() &#123;
        String name = Thread.currentThread().getName();//获取当前线程的name
        for(int i=0;i&lt;10;i++)&#123;
            System.out.println(name +&quot; hello world!&quot;);
        &#125;
    &#125;
&#125;

// 测试
public class MyThread &#123;
    public static void main(String[] args) &#123;
        Thread2 thread = new Thread2();
        
        Thread t1 = new Thread(thread);
        Thread t2 = new Thread(thread);
        t1.setName(&quot;线程1&quot;);
        t2.setName(&quot;线程2&quot;);


        t1.start();
        t2.start();
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>实现方式三：</p>
<ul>
<li>创建一个类实现<code>Callable</code>接口，重写<code>call</code>方法（有返回值，表示多线程的运行结果）；</li>
<li>创建自己类的对象；</li>
<li>创建<code>FutureTask</code>对象（用于管理多线程处理的结果）；</li>
<li>创建<code>Thread</code>类的对象，并启动线程；</li>
</ul>
<pre><code class="language-java">public class Thread3 implements Callable&lt;Integer&gt; &#123;
    @Override
    public Integer call() throws Exception &#123;
        int sum = 0;
        for(int i=0;i&lt;10;i++)&#123;
            sum += i;
        &#125;
        return sum;
    &#125;
&#125;

// 测试
public class MyCallable &#123;
    public static void main(String[] args) &#123;
        Thread3 thread = new Thread3();
        
        FutureTask&lt;Integer&gt; f = new FutureTask&lt;&gt;(thread);
        
        Thread t1 = new Thread(f);
        Thread t2 = new Thread(f);
        t1.setName(&quot;线程1&quot;);
        t2.setName(&quot;线程2&quot;);

        t1.start();
        t2.start();

        int ans = f.get();
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h2 id="多线程的常用方法">多线程的常用方法</h2>
<pre><code class="language-java">public final void setName(String name); // 更改线程的名字
public final String getName(); // 获取线程的名字
public void start(); // 启动线程
public static Thread currentThead(); // 获取正在执行的线程
public final int getPriority(); // 获取当前线程优先级
public final void setPriority(int newPriority); //设置线程的优先级（1~10）
public static void sleep(long millis); // 睡眠指定时间，暂停运行
public final void join(long millis); // 插入线程
public static void yield(); //礼让线程
</code></pre>
<h2 id="线程的生命周期">线程的生命周期</h2>
<p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230421121103828.png" alt="image-20230421121103828"></p>
<h2 id="线程的安全问题">线程的安全问题</h2>
<ul>
<li>
<p>竞态条件（Race Condition）</p>
<ul>
<li>多个线程同时对<strong>共享资源</strong>进行读写操作，导致数据不一致。</li>
<li>解决：同步机制（synchronized），锁（Lock），使用线程安全的数据结构（如ConcurrentHashMap）</li>
<li>同步代码块
<ul>
<li><strong>锁对象一定要是唯一的</strong>，如果每个线程拥有一个不同的锁对象，则锁就失去了意义；</li>
<li>synchronized不要写在循环内，不然一个线程抢到执行权后，直到循环结束之前，其他线程没法进入；</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//注：这里使用线程的第一种自定义方法
public class MyThread extends Thread&#123;
    
    // 加static关键字，表示共享ticket数据
    static int ticket = 0; 

    // 锁对象必须是唯一的
    // 加static关键字表示的MyThread创建的所有对象都共享同一个obj
    static Object obj = new Object();

    @Override
    public void run() &#123;
        while(true)&#123;
            // 同步代码块
            synchronized (obj)&#123;
                if(ticket&lt;100)&#123;
                    try &#123;
                        Thread.sleep(100);
                    &#125; catch (InterruptedException e) &#123;
                        throw new RuntimeException(e);
                    &#125;
                    ticket++;
                    System.out.println(getName()+&quot;正在卖第&quot;+ticket+&quot;张票！&quot;);
                &#125;else&#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li>同步方法
<ul>
<li>将同步代码块抽取出来形成一个方法，为这个方法上锁；</li>
</ul>
</li>
</ul>
<pre><code class="language-java">//注：这里使用线程的第二种自定义方法
public class MyRunnable implements Runnable&#123;
    int ticket = 0;// 不需要static关键字，Runnable对象只创建一次

    @Override
    public void run() &#123;
        while(true)&#123;
            if(memthod()) break;
        &#125;
    &#125;

    // 同步方法
    private synchronized boolean memthod() &#123;
        if(ticket&lt;100)&#123;
            try &#123;
                Thread.sleep(100);
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125;
            ticket++;
            System.out.println(Thread.currentThread().getName()+&quot;正在卖第&quot;+ticket+&quot;张票！&quot;);
        &#125;else&#123;
            return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p><strong>StringBulider</strong>&amp;<strong>StringBuffer</strong></p>
<ul>
<li>
<p><code>StringBuffer</code>和<code>StringBuilder</code>都是Java中用于处理<strong>可变字符串</strong>的类，它们的主要区别在于线程安全性和性能。</p>
</li>
<li>
<p><code>StringBuffer</code>是<strong>线程安全</strong>的，因此可以在多线程环境下使用。它的<strong>所有公共方法都是同步的</strong>，即在方法内部使用了synchronized关键字来确保线程安全。这种同步机制会带来一定的<strong>性能损失</strong>，因为多个线程需要竞争同一把锁，这会导致线程阻塞和上下文切换。因此，如果不需要在多线程环境下使用可变字符串，建议使用<code>StringBuilder</code>。</p>
</li>
<li>
<p><code>StringBuilder</code>是<strong>非线程安全</strong>的，因此不能在多线程环境下使用。它的所有公共方法都不是同步的，因此在单线程环境下使用<code>StringBuilder</code>比使用<code>StringBuffer</code>更加高效。</p>
</li>
</ul>
</li>
<li>
<p><strong>锁（Lock）</strong></p>
<pre><code class="language-java">public class MyThread extends Thread&#123;
    static int ticket = 0;
    static Lock lock = new ReentrantLock();
    @Override
    public void run() &#123;
        while (true) &#123;
            lock.lock(); // 上锁
            try &#123;
                if (ticket &lt; 100) &#123;
                    Thread.sleep(100);
                    ticket++;
                    System.out.println(getName() + &quot;正在卖第&quot; + ticket + &quot;张票！&quot;);
                &#125; else &#123;
                    break;
                &#125;
            &#125; catch (InterruptedException e) &#123;
                throw new RuntimeException(e);
            &#125; finally &#123;
                lock.unlock(); // 释放锁 
                               // 使用finally关键字，不管怎样都会被执行，防止线程跳出循环后未释放锁
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p><strong>死锁</strong></p>
<ul>
<li>死锁是指两个或多个线程在互相持有对方所需要的资源时，都在等待对方先释放资源，导致程序无法继续执行的情况。</li>
<li>避免死锁的方法：
<ul>
<li>避免使用多个锁：尽量减少线程需要持有的锁的数量，或使用更高级别的同步机制（如ReentrantLock）来避免死锁；</li>
<li>避免使用多个锁的嵌套；</li>
<li>超时等待：线程尝试获取锁时，设置一个超时时间，在等待超过一定时间后，放弃获取锁。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>等待唤醒机制</strong></p>
<ul>
<li>
<p>等待唤醒机制是一种用于线程间通信的机制，它允许一个线程等待另一个线程的通知，以便在特定时间点上恢复执行。</p>
</li>
<li>
<p>常用方法：</p>
<pre><code class="language-java">void wait();
void notify();
void notifyAll();
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="线程池">线程池</h2>
<ul>
<li>之前写多线程的弊端：线程用完之后就消失，浪费资源；</li>
<li>线程池是一种用于<strong>管理和重用线程</strong>的机制，它允许在应用程序中创建一组线程，并在需要时执行任务，而不需要频繁地创建和销毁线程。</li>
<li>线程池核心原理：
<ul>
<li>创建一个池子，初始是空的；</li>
<li>提交任务时，池子创建一个新的线程对象，任务执行完毕后把线程还给池子，下次创建线程时不需要创建新的线程，直接复用已有的线程；</li>
<li>但是如果提交任务时线程池中没有空闲线程，也无法创建新的线程，任务就会等待；</li>
</ul>
</li>
</ul>
<pre><code class="language-java">public class ThreadPoolDemo &#123;
    public static void main(String[] args) &#123;

        // 创建一个没有上限的线程池对象
//        ExecutorService pool = Executors.newCachedThreadPool();

        // 创建一个有上限的线程池对象
        ExecutorService pool = Executors.newFixedThreadPool(3);

        // 提交任务
        pool.submit(new MyThread());
        pool.submit(new MyThread());

        // 销毁线程池
        pool.shutdown();
    &#125;
&#125;
</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post_share"><div class="social-share" data-image="/img/smile_boy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/28/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Spring学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Spring学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Redis学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Redis学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/smile_boy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ming</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/smithrowe10"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">初始化和请理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E9%9A%90%E8%97%8F"><span class="toc-number">7.</span> <span class="toc-text">实现隐藏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8"><span class="toc-number">8.</span> <span class="toc-text">复用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">9.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">10.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">12.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">13.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">14.</span> <span class="toc-text">函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81"><span class="toc-number">15.</span> <span class="toc-text">流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">16.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">17.</span> <span class="toc-text">反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">18.</span> <span class="toc-text">泛型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number"></span> <span class="toc-text">Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">多线程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">多线程的实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">多线程的常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">4.</span> <span class="toc-text">线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">线程的安全问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.</span> <span class="toc-text">线程池</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/" title="Ubuntu 安装 Redis">Ubuntu 安装 Redis</a><time datetime="2023-07-20T05:40:41.000Z" title="Created 2023-07-20 13:40:41">2023-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" title="Leetcode刷题总结">Leetcode刷题总结</a><time datetime="2023-07-18T09:07:42.000Z" title="Created 2023-07-18 17:07:42">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/" title="Web开发相关">Web开发相关</a><time datetime="2023-07-16T04:41:51.000Z" title="Created 2023-07-16 12:41:51">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/" title="点评项目">点评项目</a><time datetime="2023-07-10T03:16:40.000Z" title="Created 2023-07-10 11:16:40">2023-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/" title="Ubuntu配置ssh">Ubuntu配置ssh</a><time datetime="2023-07-01T05:43:21.000Z" title="Created 2023-07-01 13:43:21">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ming</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>