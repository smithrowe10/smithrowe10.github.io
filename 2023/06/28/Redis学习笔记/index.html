<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis学习笔记 | ming's blog</title><meta name="author" content="ming"><meta name="copyright" content="ming"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介   Redis（Remote Dictionary Server）是一个基于内存的key-value的结构数据库，它可以用作数据库，缓存和消息中间件。   单线程，每个命令具备原子性   基于内存存储，读写性能高   适合存储热点数据（热点资讯，热点商品）     Redis是一种典型的NoSql数据库（非关系型数据库）；   Redis所有的数据结构都以唯一的key字符串作为名称，然后通过">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis学习笔记">
<meta property="og:url" content="http://example.com/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ming&#39;s blog">
<meta property="og:description" content="简介   Redis（Remote Dictionary Server）是一个基于内存的key-value的结构数据库，它可以用作数据库，缓存和消息中间件。   单线程，每个命令具备原子性   基于内存存储，读写性能高   适合存储热点数据（热点资讯，热点商品）     Redis是一种典型的NoSql数据库（非关系型数据库）；   Redis所有的数据结构都以唯一的key字符串作为名称，然后通过">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/smile_boy.jpg">
<meta property="article:published_time" content="2023-06-28T06:13:41.000Z">
<meta property="article:modified_time" content="2023-08-28T11:20:37.091Z">
<meta property="article:author" content="ming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/smile_boy.jpg"><link rel="shortcut icon" href="/img/dog.png"><link rel="canonical" href="http://example.com/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-28 19:20:37'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/smile_boy.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="ming's blog"><span class="site-name">ming's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-06-28T06:13:41.000Z" title="Created 2023-06-28 14:13:41">2023-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-28T11:20:37.091Z" title="Updated 2023-08-28 19:20:37">2023-08-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis学习笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介">简介</h2>
<ul>
<li>
<p><code>Redis</code>（Remote Dictionary Server）是一个<strong>基于内存</strong>的<code>key-value</code>的结构数据库，它可以用作数据库，缓存和消息中间件。</p>
<ul>
<li>
<p>单线程，每个命令具备原子性</p>
</li>
<li>
<p>基于内存存储，读写性能高</p>
</li>
<li>
<p>适合存储热点数据（热点资讯，热点商品）</p>
</li>
</ul>
</li>
<li>
<p><code>Redis</code>是一种典型的<code>NoSql</code>数据库（非关系型数据库）；</p>
</li>
<li>
<p><code>Redis</code>所有的数据结构都以唯一的<code>key</code>字符串作为名称，然后通过唯一的<code>key</code>获取相应的<code>value</code>；不同数据结构之间的差异就在于<code>value</code>的数据结构的不同。</p>
</li>
</ul>
<h3 id="常用数据类型">常用数据类型</h3>
<ul>
<li>字符串（<code>string</code>）：普通字符串，常用；</li>
<li>哈希（<code>hash</code>）：适合存储对象；</li>
<li>列表（<code>list</code>）：按照插入元素顺序排序，可以有重复元素；</li>
<li>无序集合（<code>set</code>）：无序集合，没有重复元素；</li>
<li>有序集合（<code>sorted set</code>）：有序集合，没有重复元素；</li>
</ul>
<h2 id="常用命令">常用命令</h2>
<ul>
<li>
<p><code>String</code>操作命令</p>
<ul>
<li>Redis中的字符串是动态的可以修改的字符串，类似于<code>ArrayList</code>；</li>
</ul>
<pre><code class="language-sql">SET key value
GET key
SETEX key seconds value  # 设置指定key的值，并将key的过期时间设为seconds
SETNX key value  # 只有key不存在时设置key的值
</code></pre>
</li>
<li>
<p><code>hash</code>操作命令</p>
<pre><code class="language-sql">HSET key field value
HGET key field
HDEL key field
HKEYS key   # 获取Hash表中所有字段
HVALS key   # 获取Hash表中所有值
HGETALL key  # 获取Hash表中指定key所有字段和值
</code></pre>
</li>
<li>
<p><code>list</code>操作命令</p>
<pre><code class="language-sql">LPUSH key value1 [value2] # 将一个或多个元素插入列表头部
LRANGE key start stop   # 获取指定范围内的元素
RPOP key     # 移除并获取列表最后一个元素
LLEN key     # 获取列表长度
BRPOP key1 [key2] timeout  # 移出并获取列表最后一个元素
</code></pre>
</li>
<li>
<p><code>set</code>操作命令</p>
<pre><code class="language-sql">SADD key memeber1 [memeber2] # 添加一个或多个成员
SMEMBERS key         # 返回集合中所有元素
SCARD key     # 获取集合中的成员数
SREM key memeber1 [memeber2]   #移除一个或多个成员
</code></pre>
</li>
<li>
<p><code>sorted set</code></p>
<p>每个元素都会关联一个 double 类型的分数。<code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<pre><code class="language-sql">ZADD key score member  # 添加成员或更新分数
ZRANGE  key start stop [WITHSCORES] # 返回指定范围内的成员
ZINCRBY key increment memeber # 对指定成员的分数加上increment
ZREM key memeber # 移除成员
</code></pre>
</li>
<li>
<p>通用命令</p>
<pre><code class="language-sql">KEYS pattern    # 查找所有符合的key
EXISTS key   # 检查key是否存在
TYPE key  # 查看key对应的类型
TTL key  #返回key的剩余生存时间(time to live),以秒为单位
         # -1表示存活时间为永久
DEL key  #删除key
</code></pre>
</li>
</ul>
<h2 id="Java客户端工具">Java客户端工具</h2>
<h3 id="jedis">jedis</h3>
<h4 id="jedis配置">jedis配置</h4>
<p>jedis就是基于java语言的redis客户端，集成了redis的命令操作，提供了连接池管理。（线程不安全）</p>
<ul>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;2.9.0&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>连接测试</p>
<pre><code class="language-java">public class JedisTest &#123;
    private Jedis jedis;

    // 执行测试文件前执行
    @BeforeEach
    void setUp()&#123;
        // 1. 建立连接
        jedis = new Jedis(&quot;127.0.0.1&quot;,6379);
        // 2. 设置密码
        jedis.auth(&quot;lm12138&quot;);
        // 3. 选择库
        jedis.select(0);
    &#125;

    @Test
    public void test()&#123;
        // 设置数据
        String res = jedis.set(&quot;ming&quot;, &quot;22&quot;);
        System.out.println(res);
        // 读取数据
        String value = jedis.get(&quot;ming&quot;);
        System.out.println(value);
    &#125;

    // 释放缓存
    @AfterEach
    void close()&#123;
        if(jedis!=null)&#123;
            jedis.close();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h4 id="jedis连接池">jedis连接池</h4>
<p>jedis线程不安全，频繁的连接和释放连接会有损害性能，推荐用线程池；</p>
<pre><code class="language-java">public class JedisConnectionFactory &#123;
    private static final JedisPool jedisPool;

    static &#123;
        // 配置连接池
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(8);// 最大连接数
        poolConfig.setMaxIdle(4); // 最大空闲连接数
        poolConfig.setMinIdle(0); // 最小空闲连接
        poolConfig.setMaxWaitMillis(1000); // 最大等待时间

        // 创建连接池对象
        jedisPool = new JedisPool(poolConfig,&quot;127.0.0.1&quot;,
                6379,1000,&quot;lm12138&quot;);

    &#125;

    // 获取jedis对象
    public static Jedis getJedis()&#123;
        return jedisPool.getResource();
    &#125;
&#125;
</code></pre>
<h3 id="spring-data-redis">spring-data-redis</h3>
<p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></p>
<blockquote>
<p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png" alt="image-20220525140217446"></p>
<h4 id="基本配置">基本配置</h4>
<ul>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
            &lt;version&gt;2.11.1&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置信息</p>
<pre><code class="language-yaml">spring:
  data:
    redis:
      host: 127.0.0.1
      port: 6379
      password: lm12138
      lettuce:
        pool:
          max-active: 8
          max-idle: 8
          min-idle: 0
          max-wait: 100ms
</code></pre>
</li>
<li>
<p>测试连接</p>
<pre><code class="language-java">@SpringBootTest
class RedisDemoApplicationTests &#123;

    @Autowired
    private RedisTemplate redisTemplate;

    @Test
    void contextLoads() &#123;
        redisTemplate.opsForValue().set(&quot;ming&quot;,21);
        Object age = redisTemplate.opsForValue().get(&quot;ming&quot;);
        System.out.println(age);
    &#125;

&#125;
</code></pre>
</li>
</ul>
<h4 id="RedisSerializer配置">RedisSerializer配置</h4>
<hr>
<blockquote>
<p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png" alt="image-20220525170205272"></p>
<p>**缺点：**可读性差，内存占用较大</p>
<ul>
<li>
<p>编写配置类</p>
<pre><code class="language-java">@Configuration
public class RedisConfig &#123;
    @Bean
    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123;
        // 1.创建RedisTemplate对象
        RedisTemplate&lt;String ,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        // 2.设置连接工厂
        redisTemplate.setConnectionFactory(factory);

        // 3.创建序列化对象
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();

        // 4.设置key和hashKey采用String的序列化方式
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setHashKeySerializer(stringRedisSerializer);

        // 5.设置value和hashValue采用json的序列化方式
        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);
        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);

        return redisTemplate;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个<strong>对象</strong></p>
<pre><code class="language-java">@Test
void testSaveUser() &#123;
    redisTemplate.opsForValue().set(&quot;user:100&quot;, new User(&quot;ming&quot;, 21));
    User user = (User) redisTemplate.opsForValue().get(&quot;user:100&quot;);
    System.out.println(&quot;User = &quot; + user);
&#125;
</code></pre>
</li>
</ul>
<h4 id="StringRedisTemplate">StringRedisTemplate</h4>
<blockquote>
<p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p>
</blockquote>
<p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png" alt="image-20220525172001057"></p>
<blockquote>
<p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p>
</blockquote>
<ul>
<li>
<p>我们可以直接编写一个测试类使用<code>StringRedisTemplate</code>来执行以下方法</p>
<pre><code class="language-java">@SpringBootTest
class RedisStringTemplateTest &#123;

	@Resource
	private StringRedisTemplate stringRedisTemplate;

	@Test
	void testSaveUser() throws JsonProcessingException &#123;
		// 1.创建一个Json序列化对象
		ObjectMapper objectMapper = new ObjectMapper();
		// 2.将要存入的对象通过Json序列化对象转换为字符串
		String userJson1 = objectMapper.writeValueAsString(new User(&quot;Vz&quot;, 21));
		// 3.通过StringRedisTemplate将数据存入redis
		stringRedisTemplate.opsForValue().set(&quot;user:100&quot;,userJson1);
		// 4.通过key取出value
		String userJson2 = stringRedisTemplate.opsForValue().get(&quot;user:100&quot;);
		// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象
		User user = objectMapper.readValue(userJson2, User.class);
		// 6.打印结果
		System.out.println(&quot;user = &quot; + user);
	&#125;
&#125;
</code></pre>
</li>
<li>
<p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p>
<p>方案一：</p>
<ol>
<li>自定义RedisTemplate</li>
<li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li>
<li>缺点：占用内存空间，需要记录类的字节码</li>
</ol>
<p>方案二：</p>
<ol>
<li>使用StringRedisTemplate</li>
<li>写入Redis时，手动把对象序列化为JSON</li>
<li>读取Redis时，手动把读取到的JSON反序列化为对象</li>
</ol>
</li>
</ul>
<h2 id="缓存">缓存</h2>
<h3 id="简介-v2">简介</h3>
<p>缓存是数据交换得缓冲区（Cache），用于存储临时数据，一般读写性能较高；</p>
<ul>
<li>
<p>缓存的作用</p>
<ul>
<li>降低后端负载</li>
<li>提高读写速率，降低响应速率</li>
</ul>
</li>
<li>
<p>缓存的成本</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本（集群部署等）</li>
</ul>
</li>
<li>
<p>通常我们这样使用缓存：</p>
<ul>
<li>写请求只写数据库</li>
<li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存</li>
<li>同时，写入缓存中的数据，都设置失效时间</li>
</ul>
</li>
</ul>
<p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230712110056150.png" alt="image-20230712110056150"></p>
<p>​		这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「<strong>热数据</strong>」，缓存利用率得以最大化。</p>
<h3 id="缓存更新策略">缓存更新策略</h3>
<ul>
<li>
<p>缓存更新策略</p>
<ul>
<li>内存淘汰：利用Redis的内存淘汰机制；</li>
<li>超时剔除：给缓存数据添加超时时间；</li>
<li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存；</li>
</ul>
</li>
<li>
<p>删除缓存还是更新缓存？</p>
<ul>
<li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多；</li>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（<strong>更优</strong>）</li>
</ul>
</li>
<li>
<p>如何保证缓存和数据库操作的原子性？</p>
<ul>
<li>单体系统，将缓存和数据库放在一个事务中；</li>
<li>分布式系统：利用TCC等分布式事务方案；</li>
</ul>
</li>
<li>
<p>这里存在<strong>数据一致性问题</strong>，当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。这两个操作并非是原子的，所以有先后顺序；</p>
<ul>
<li>
<p>先删除缓存，再更新数据库：</p>
<ul>
<li>
<p>初始化（数据库：1 ，缓存：1）</p>
</li>
<li>
<p><em>线程1</em> 删除缓存后（数据库：1 ，缓存：null）</p>
</li>
<li>
<p><em>线程2</em> 前来查询缓存未命中，查询数据库，并将查询到的数据写入缓存（数据库：1 ，缓存：1）</p>
</li>
<li>
<p><em>线程1</em> 再更新数据库（数据库：2 ，缓存：1）</p>
</li>
<li>
<p>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率较大</strong>，因为Redis的读写速度比数据库快很多，并发情况下很容易发生这种情况。</p>
</li>
</ul>
</li>
<li>
<p>先更新数据库，再删除缓存</p>
<ul>
<li>初始化，恰好缓存失效（数据库：1 ，缓存：null）</li>
<li><em>线程1</em> 查询缓存未命中并查询数据库（1）</li>
<li><em>线程2</em> 更新数据库（数据库：2 ，缓存：null）</li>
<li><em>线程2</em>  删除缓存（数据库：2 ，缓存：null）</li>
<li><em>线程1</em> 写入缓存（数据库：2 ，缓存：1）</li>
<li>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率很小</strong>（线程1之前缓存恰好失效；Redis写入速度很快，在其之前有线程插入并更新数据库的概率很小）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>因此，缓存更新策略的最佳实践方案为：</p>
<ul>
<li>低一致性需求：使用Redis自带的内存淘汰机制；</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案；
<ul>
<li>读操作：
<ul>
<li>缓存命中则直接返回；</li>
<li>缓存未命中则直接查询数据库，并写入缓存，并设定超时时间；</li>
</ul>
</li>
<li>写操作：
<ul>
<li>先写数据库，然后再删除缓存；</li>
<li>要确保数据库与缓存操作的原子性；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透">缓存穿透</h3>
<ul>
<li>
<p>缓存穿透是指客户端<strong>请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远都不会生效，这些请求都会到数据库。（可能会被无效请求恶意攻击）。</p>
</li>
<li>
<p>解决方案：</p>
<ul>
<li>
<p>缓存空对象：对于无效的请求，缓存一个null对象</p>
<ul>
<li>
<p>优点：实现简单，维护简单</p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的数据不一致</li>
</ul>
</li>
</ul>
</li>
<li>
<p>布隆过滤</p>
<ul>
<li>请求与Redis缓存之间设置一布隆过滤器，由布隆过滤器判断请求数据是否存在，存在则放行，不存在则直接返回。</li>
<li>布隆过滤器并不是存储了所有数据，而是通过某种算法来判断请求数据是否存在。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩">缓存雪崩</h3>
<ul>
<li>缓存雪崩是指 <strong>同一时段大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</li>
<li>解决方案：
<ul>
<li>给不同的key添加随机失效时间；</li>
<li>利用Redis集群提高服务的可用性；</li>
<li>给缓存业务添加降级限流策略；</li>
<li>给业务添加多级缓存；</li>
</ul>
</li>
</ul>
<h3 id="缓存击穿">缓存击穿</h3>
<ul>
<li>
<p>缓存击穿问题也被称为<strong>热点key</strong>问题，就是一个<strong>被高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求在瞬间给数据库带来巨大的冲击。</p>
</li>
<li>
<p>解决方案：</p>
<ul>
<li>
<p>互斥锁：查询缓存未命中时，先获取互斥锁，获取锁成功后查询数据库并重建缓存，写入缓存后再释放锁；这样，其他线程请求无法在缓存重建期间查询缓存。</p>
<p>线程需要等待，性能收到影响；可能有死锁风险。</p>
</li>
<li>
<p>逻辑过期：<strong>给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL</strong>。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。</p>
<ul>
<li>优点：
<ul>
<li>线程无需等待，性能较好</li>
</ul>
</li>
<li>缺点：
<ul>
<li>不保证一致性(因为会返回过期数据)</li>
<li>有额外的内存消耗(同时缓存了逻辑过期时间的字段)</li>
<li>实现复杂</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="秒杀">秒杀</h2>
<h3 id="分布式全局唯一ID">分布式全局唯一ID</h3>
<ul>
<li>
<p>**<em>UUID(通用唯一标识符)**表示一个128位长的唯一值。 它也被普遍称为</em>GUID(全球唯一标识符)。我们可以使用*UUID*类来生成随机文件名，会话或事务ID。 UUID的另一种流行用法是在数据库中生成主键值。<strong>有极小的概率会重复</strong>。</p>
</li>
<li>
<p><strong>雪花算法</strong></p>
<p>由64位<code>bit</code>字符组成（Long）<br>
$$<br>
0\quad \quad0000 … 0000\quad\quad\quad 000000 0000 \quad\quad 0000 0000 0000<br>
$$<br>
​                                                       <strong>符号位   时间戳：41 bit          机器ID：10 bit</strong>      <strong>12 bit 序列号</strong></p>
<ul>
<li>
<p>组成：</p>
<ul>
<li>符号位：1 bit，生成ID一般均为正数，因此为0；</li>
<li>时间戳：41 bit，单位为ms，可以使用约69年；</li>
<li>机器ID：10 bit，可以支持1024个分布式机器；</li>
<li>序列号：12 bit，表示每ms可以生成$2^{12}=1024$个不同ID；</li>
</ul>
</li>
<li>
<p>特点</p>
<ul>
<li>按时间递增</li>
<li>唯一性</li>
<li>生成效率高</li>
</ul>
</li>
</ul>
<pre><code class="language-java">/**
 * 生成全局唯一ID（** 雪花算法 **）
 */
@Component
public class UIDWorker &#123;

    // 开始时间戳
    private static final long BEGIN_TIMESTAMP = 1692213900;

    @Resource
    private StringRedisTemplate stringRedisTemplate;

    public Long nextId(String prefix)&#123;
        // 生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        // 机器ID
        long machineId = 1;

        // 生成序列号(通过Redis自增生成序列)
        String nowDateTime = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));
        long increment = stringRedisTemplate.opsForValue()
                         .increment(&quot;icr&quot; + prefix + &quot;:&quot; + nowDateTime);

        // 拼接并返回
        long id = timestamp &lt;&lt; 22 | machineId &lt;&lt; 12 | increment;

        return id;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>雪花算法的**时钟回拨 **问题</p>
<ul>
<li>由于雪花算法对于时钟特别敏感，因此如果时钟出现回拨现象，有可能导致获取的ID重复。</li>
<li>正常来说只要不是不是有人手贱或者出于泄愤的目的进行干扰，系统的时间漂移是一个在毫秒级别的极短的时间。因此可以在获取 ID 的时候，记录一下当前的时间戳。然后在下一次过来获取的时候，<strong>对比一下当前时间戳和上次记录的时间戳，如果发现当前时间戳小于上次记录的时间戳，所以出现了时钟回拨现象，对外抛出异常，本次 ID 获取失败</strong>。理论上当前时间戳会很快的追赶上上次记录的时间戳。</li>
</ul>
</li>
</ul>
<h3 id="超卖问题">超卖问题</h3>
<ul>
<li>
<p>高并发场景下，做个线程交叉执行可能会出现超卖问题；</p>
<ul>
<li>
<p><code>初始</code>：库存：1；</p>
</li>
<li>
<p><code>线程1</code>：查询库存为1；</p>
</li>
<li>
<p><code>线程2</code>：查询库存为1；</p>
</li>
<li>
<p><code>线程1</code>：扣减库存，下单成功；</p>
</li>
<li>
<p><code>线程2</code>：扣减库存，下单成功；</p>
</li>
<li>
<p><code>库存</code>：<strong>-1</strong>（出现超买问题）；</p>
</li>
</ul>
</li>
<li>
<p>解决方案：加锁</p>
</li>
<li>
<p><strong>悲观锁</strong></p>
<ul>
<li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li>
<li>例如<code>Synchronized</code>，<code>Lock</code>都属于悲观锁；</li>
<li>特点：简单直接，性能差；</li>
</ul>
</li>
<li>
<p><strong>乐观锁</strong></p>
<ul>
<li>认为线程安全问题不一定会发生，因此不加锁，只是<strong>在更新数据时判断是否有其他线程对数据进行了修改</strong>。
<ul>
<li>如果没有，则认为是安全的，更新数据；</li>
<li>如果有，则重试或者抛出异常；</li>
</ul>
</li>
<li>特点：性能好，但容易出现成功率过低的问题；</li>
</ul>
</li>
<li>
<p>乐观锁的实现方式</p>
<ul>
<li>
<p><strong>版本号法</strong>：为资源添加一个version版本号，当修改资源后version就加一，修改资源前判断版本号是否被修改；</p>
<ul>
<li>
<p><code>初始</code>：库存：1；（ version = 1 ）</p>
</li>
<li>
<p><code>线程1</code>：查询库存为1；（ version = 1 ）</p>
</li>
<li>
<p><code>线程2</code>：查询库存为1；（ version = 1 ）</p>
</li>
<li>
<p><code>线程1</code>：扣减库存，下单成功；（ version = 2 ）</p>
</li>
<li>
<p><code>线程2</code>：此时发现version与查询时的不同，说明资源被其他线程修改，下单失败；</p>
</li>
</ul>
</li>
<li>
<p><strong>CAS</strong>（<code>Compare And Swap</code>）：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。<br>
（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。<br>
（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p>
<pre><code class="language-java">// 扣减库存
boolean isSuccess = seckillVoucherService.update()
        .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1
        .eq(&quot;voucher_id&quot;, voucherId) // where ...
        .eq(&quot;stock&quot;,voucher.getStock())
        .update();
</code></pre>
<p>该方法能够解决超卖问题，但是高并发场景下成功率过低，影响业务；</p>
</li>
</ul>
</li>
</ul>
<h3 id="一人一单">一人一单</h3>
<ul>
<li>
<p>业务场景下，同一个用户对同一优惠券只能下一次单。（抵制黄牛！）</p>
</li>
<li>
<p>加<code>sycronized</code>锁实现</p>
<pre><code class="language-java">@Transactional
public Result createVoucherOrder(Long voucherId) &#123;
    // 获取用户Id
    Long userId = UserHolder.getUser().getId();
    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效
    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串
    synchronized (userId.toString().intern())&#123;
        // 一人一单
        Long count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();
        if(count&gt;0)&#123;
            return Result.fail(&quot;用户已经抢购过该优惠券！&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>以上代码可能会导致线程安全问题</p>
<pre><code class="language-java">@Transactional
public Result createVoucherOrder(Long voucherId) &#123;
    ...
    synchronized (userId.toString().intern())&#123;
        // 一人一单
        ...
    &#125;
    // 锁释放，此时其他线程可以进来
    // 而事务尚未提交，线程不安全！
&#125;
</code></pre>
</li>
<li>
<p>优化</p>
<pre><code class="language-java">@Override
public Result seckillVoucher(Long voucherId) &#123;
    Long userId = UserHolder.getUser().getId();
    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效
    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串
    synchronized (userId.toString().intern()) &#123;
        return this.createVoucherOrder(voucherId); // **事务失效** 问题
        // 事务已提交
    &#125; // 释放锁
&#125;

@Transactional
public Result createVoucherOrder(Long voucherId) &#123;
    ...
&#125;
</code></pre>
</li>
<li>
<p>以上有可能导致<strong>事务失效</strong>问题，解决方案如下：</p>
<pre><code class="language-java">Long userId = UserHolder.getUser().getId();
synchronized (userId.toString().intern()) &#123;
    // 拿到当前对象的代理对象
    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
    return proxy.createVoucherOrder(voucherId);
&#125;
</code></pre>
</li>
</ul>
<h2 id="分布式锁">分布式锁</h2>
<h3 id="简介-v3">简介</h3>
<ul>
<li>
<p><code>sycronized</code>只能在一个<code>JVM</code>内部实现不同线程之间的互斥，集群下可能出现线程安全问题</p>
</li>
<li>
<p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见的互斥锁。</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>多进程可见</li>
<li>互斥</li>
<li>高性能</li>
<li>高可用</li>
<li>安全性</li>
</ul>
</li>
<li>
<p>实现方式</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">MySQL</th>
<th style="text-align:center">Redis</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">互斥</td>
<td style="text-align:center">利用MySQL本身的互斥锁机制</td>
<td style="text-align:center">利用setnx命令</td>
</tr>
<tr>
<td style="text-align:center">高可用</td>
<td style="text-align:center">好</td>
<td style="text-align:center">好</td>
</tr>
<tr>
<td style="text-align:center">高性能</td>
<td style="text-align:center">一般</td>
<td style="text-align:center">好</td>
</tr>
<tr>
<td style="text-align:center">安全性</td>
<td style="text-align:center">断开连接，自动释放锁</td>
<td style="text-align:center">利用锁超时时间，到期释放</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="基于Redis实现分布式锁">基于Redis实现分布式锁</h3>
<ul>
<li>
<p>获取锁</p>
<pre><code class="language-sql"># 利用setnx的互斥特性
SETNX lock thread1
# 添加锁过期时间，避免服务宕机引起的死锁
EXPIRE lock 30
</code></pre>
<p>以上两条命令不具备原子性，可以使用以下命令：</p>
<pre><code class="language-sql">SET lock thread NX EX 30
</code></pre>
</li>
<li>
<p>释放锁</p>
<p>手动释放或超时释放</p>
<pre><code class="language-sql"># 删除即可
DEL lock
</code></pre>
</li>
<li>
<p>实现Redis分布式锁</p>
<pre><code class="language-java">public interface ILock &#123;

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return true代表获取锁成功; false代表获取锁失败
     */
    boolean tryLock(long timeoutSec);

    /**
     * 释放锁
     */
    void unlock();
&#125;
</code></pre>
<pre><code class="language-java">public class SimpleRedisLock implements ILock &#123;

    private StringRedisTemplate stringRedisTemplate;

    private String lockName;

    private static final String ID_PREFIX = UUID.randomUUID(true) + &quot;-&quot;;

    private static final String LOCK_PREFIX = &quot;lock_&quot;;

    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String lockName) &#123;
        this.lockName = lockName;
        this.stringRedisTemplate = stringRedisTemplate;
    &#125;


    @Override
    public boolean tryLock(long timeoutSec) &#123;
         /*
          获取锁时存入线程标识
          解决分布式锁 **误删** 问题
         */
        
        // 获取线程标示
        String threadId = ID_PREFIX + Thread.currentThread().getId();
        // 获取锁
        Boolean isSuccess = stringRedisTemplate.opsForValue()
                .setIfAbsent(LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.MINUTES);
//        return isSuccess;  // 可能会在自动拆箱过程中出现空指针
        return Boolean.TRUE.equals(isSuccess);
    &#125;

    @Override
    public void unlock() &#123;
        /*
         释放锁时先获取锁中的线程标识，判断是否与当前标识相同
         如果一致则释放锁，不一致则不释放锁；
         */

        String threadId = ID_PREFIX + Thread.currentThread().getId();
        String id = stringRedisTemplate.opsForValue().get(LOCK_PREFIX + lockName);
        if (threadId.equals(id)) &#123;
            stringRedisTemplate.delete(LOCK_PREFIX + lockName);
        &#125;
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>解决分布式锁 <strong>误删</strong> 问题</p>
<ul>
<li>
<p><code>线程1</code>：获取锁成功（<code>lock1</code>），执行任务；（任务时间较久或宕机）</p>
</li>
<li>
<p>超过超时时间，锁自动释放；</p>
</li>
<li>
<p><code>线程2</code>：获取锁成功（<code>lock1</code>），执行任务；</p>
</li>
<li>
<p><code>线程1</code>：任务执行成功，释放锁；</p>
</li>
<li>
<p>此时<code>线程2</code>还未执行完毕，<code>线程 1 </code>误删了<code>线程 2 </code>的锁；</p>
</li>
</ul>
<p>解决方案：</p>
</li>
<li>
<p>获取锁时存入线程标识（可以使用<code>UUID</code>）；</p>
<ul>
<li>释放锁时先获取锁中的线程标识，判断是否与当前标识相同，如果一致则释放锁，不一致则不释放锁；</li>
</ul>
</li>
<li>
<p>分布式锁的<strong>原子性</strong></p>
<ul>
<li>
<p>由于上述判断线程标识与释放锁的操作不具备原子性，因此可能会有线程安全问题；</p>
</li>
<li>
<p>Redis提供了lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性；</p>
<pre><code class="language-lua">EVAL script key [key ...]  # 执行脚本
</code></pre>
</li>
</ul>
</li>
<li>
<p>实现思路总结</p>
<ul>
<li>利用<code>SETNX</code>命令获取锁，设置过期时间，并存入线程标识；</li>
<li>释放锁时先判断标识是否一致，一致则删除锁；</li>
</ul>
</li>
<li>
<p>基于<code>SETNX</code>实现分布式锁的问题：</p>
<ul>
<li>不可重入：同一个线程无法多次获取同一把锁；</li>
<li>不可重试：获取锁失败时返回false，没有重试机制；</li>
<li>超时释放：超时释放虽然可以避免死锁；设置超时时间过短，若业务执行时间过长，也会导致锁释放，存在安全隐患；设置超时时间过长，导致业务停滞；</li>
<li>主从一致性</li>
</ul>
</li>
</ul>
<h3 id="Redisson">Redisson</h3>
<ul>
<li>
<p><strong>Redisson使用</strong></p>
<ul>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.redisson&lt;/groupId&gt;
            &lt;artifactId&gt;redisson&lt;/artifactId&gt;
            &lt;version&gt;3.13.6&lt;/version&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置文件</p>
<pre><code class="language-java">// Reddision 配置
@Configuration
public class RedissonConfig &#123;

    @Bean
    public RedissonClient redissonClient() &#123;
        // 配置
        Config config = new Config();
        // 单节点
        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;lm12138&quot;);
        // 创建RedissonClient对象
        return Redisson.create(config);
    &#125;
&#125;
</code></pre>
</li>
<li>
<p>使用 <code>Redisson</code></p>
<pre><code class="language-java">@Resource
private RedissonClient redissonClient;

@Test
private void testRedisson() &#123;
    // 获取锁，指定锁名称
    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);
    boolean isLock = lock.tryLock();
    // 判断是否获取锁成功
    if(!isLock)&#123;
        try &#123;
           // 业务逻辑
        &#125; finally &#123;
          // 释放锁
          lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="秒杀优化">秒杀优化</h3>
<ul>
<li>
<p>秒杀流程回顾：</p>
<ul>
<li>查询优惠券（数据库）</li>
<li>判断秒杀库存</li>
<li>查询订单（数据库）</li>
<li>校验一人一单</li>
<li>减库存（数据库）</li>
<li>创建订单（数据库）</li>
</ul>
</li>
<li>
<p><strong>异步秒杀</strong>：</p>
<ul>
<li>新增秒杀优惠券的同时，将秒杀库存保存到Redis中；</li>
<li>基于lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li>
<li>如果抢购成功，将优惠券id和用户id存入阻塞队列</li>
<li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">ming</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">http://example.com/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/smile_boy.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="Java学习笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Java学习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2023/06/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="MySQL学习笔记"><img class="cover" src="/images/mysql.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL学习笔记</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/smile_boy.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ming</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">13</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">3</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/smithrowe10"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">常用数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%B7%A5%E5%85%B7"><span class="toc-number">3.</span> <span class="toc-text">Java客户端工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis"><span class="toc-number">3.1.</span> <span class="toc-text">jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jedis%E9%85%8D%E7%BD%AE"><span class="toc-number">3.1.1.</span> <span class="toc-text">jedis配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jedis%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">3.1.2.</span> <span class="toc-text">jedis连接池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-data-redis"><span class="toc-number">3.2.</span> <span class="toc-text">spring-data-redis</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RedisSerializer%E9%85%8D%E7%BD%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">RedisSerializer配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringRedisTemplate"><span class="toc-number">3.2.3.</span> <span class="toc-text">StringRedisTemplate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">4.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-v2"><span class="toc-number">4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.2.</span> <span class="toc-text">缓存更新策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">4.3.</span> <span class="toc-text">缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">4.4.</span> <span class="toc-text">缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">4.5.</span> <span class="toc-text">缓存击穿</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80"><span class="toc-number">5.</span> <span class="toc-text">秒杀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID"><span class="toc-number">5.1.</span> <span class="toc-text">分布式全局唯一ID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%BA%E4%B8%80%E5%8D%95"><span class="toc-number">5.3.</span> <span class="toc-text">一人一单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-v3"><span class="toc-number">6.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">6.2.</span> <span class="toc-text">基于Redis实现分布式锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redisson"><span class="toc-number">6.3.</span> <span class="toc-text">Redisson</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E4%BC%98%E5%8C%96"><span class="toc-number">6.4.</span> <span class="toc-text">秒杀优化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/" title="Ubuntu 安装 Redis">Ubuntu 安装 Redis</a><time datetime="2023-07-20T05:40:41.000Z" title="Created 2023-07-20 13:40:41">2023-07-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/" title="Leetcode刷题总结">Leetcode刷题总结</a><time datetime="2023-07-18T09:07:42.000Z" title="Created 2023-07-18 17:07:42">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/" title="Web开发相关">Web开发相关</a><time datetime="2023-07-16T04:41:51.000Z" title="Created 2023-07-16 12:41:51">2023-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/" title="点评项目">点评项目</a><time datetime="2023-07-10T03:16:40.000Z" title="Created 2023-07-10 11:16:40">2023-07-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/" title="Ubuntu配置ssh">Ubuntu配置ssh</a><time datetime="2023-07-01T05:43:21.000Z" title="Created 2023-07-01 13:43:21">2023-07-01</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By ming</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>