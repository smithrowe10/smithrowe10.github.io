<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu 安装 Redis</title>
      <link href="/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/"/>
      <url>/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/</url>
      
        <content type="html"><![CDATA[<ul><li><p>下载稳定版本Redis</p><pre><code class="language-bash">wget https://download.redis.io/redis-stable.tar.gz</code></pre></li><li><p>解压到指定目录</p><pre><code class="language-bash">tar -xzvf redis-stable.tar.gz -C /usr/local</code></pre></li><li><p>编译</p><pre><code class="language-bash">cd /usr/local/redis-stablemake</code></pre></li><li><p>安装</p><pre><code class="language-bash">make install</code></pre></li><li><p>可能出现的报错：</p><ul><li><p>没有找到 make</p><pre><code class="language-bash">sudo apt install make</code></pre></li><li><p><code>/bin/sh: 1: pkg-config: not found</code></p><pre><code class="language-bash">sudo apt-get install pkg-config</code></pre></li><li><p><code>/bin/sh: 1: cc: not found</code></p><pre><code class="language-bash">sudo apt install gcc</code></pre></li></ul></li><li><p>启动Redis服务</p><pre><code class="language-bash">/usr/local/redis-stable/src$ ./redis-server# 注意这种方式启动 redis 使用的是默认配置。# 也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。# ./redis-server ../redis.conf</code></pre></li><li><p>连接Redis服务</p><pre><code class="language-bash">/usr/local/redis-stable/src$ ./redis-cli</code></pre></li><li><p>常用配置</p><pre><code class="language-bash">vim daemonize yes  # 守护进程，后台运行requeirepass xxx   # 设置密码</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode刷题总结</title>
      <link href="/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列">栈和队列</h2><ul><li><p><a href="https://leetcode.cn/problems/min-stack-lcci">最小栈</a>：请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><pre><code class="language-java">public class MyStack &#123;    private Stack&lt;Integer&gt; stackData; // 栈数据    private Stack&lt;Integer&gt; stackMin; // 栈的最小值    public MyStack1() &#123;        this.stackData = new Stack&lt;&gt;();        this.stackMin = new Stack&lt;&gt;();    &#125;    public int pop() &#123;        if (this.stackData.isEmpty()) throw new RuntimeException();        int val = this.stackData.pop();        if (val == this.getMin()) &#123;            this.stackMin.pop();        &#125;        return val;    &#125;    public void push(int x) &#123;        this.stackData.push(x);        if (!this.stackMin.isEmpty()) &#123;            if (this.stackMin.peek() &gt;= x) &#123;                this.stackMin.push(x);            &#125;        &#125; else &#123;            this.stackMin.push(x);        &#125;    &#125;    public int getMin() &#123;        if (this.stackMin.isEmpty()) throw new RuntimeException();        return this.stackMin.peek();    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></p><pre><code class="language-java">public class MyQueue &#123;    private Stack&lt;Integer&gt; stackPush;    private Stack&lt;Integer&gt; stackPop;    MyQueue1() &#123;        this.stackPush = new Stack&lt;&gt;();        this.stackPop = new Stack&lt;&gt;();    &#125;    public void add(int x) &#123;        this.stackPush.push(x);        if (this.stackPop.isEmpty()) &#123;            pushToPop();        &#125;    &#125;    // push栈元素压到pop栈，pop栈顶永远是优先级最高的    public void pushToPop() &#123;        if (this.stackPop.isEmpty()) &#123;            while (!this.stackPush.isEmpty()) &#123;                this.stackPop.push(this.stackPush.pop());            &#125;        &#125;    &#125;    public int poll() &#123;        if (this.stackPush.isEmpty() &amp;&amp; this.stackPop.isEmpty()) return -1;        pushToPop();        return this.stackPop.pop();    &#125;    public int peek() &#123;        return this.stackPop.peek();    &#125;&#125;</code></pre></li><li><p><strong>汉诺塔问题</strong>：求有N层塔时，打印最优移动过程和最优移动总步数；注：移动时不能跳步，即必须经过中间。</p><pre><code class="language-java">// 1. 小压大原则// 2. 不可逆原则：若要求最小步数，则相邻操作之间不可逆//     如果上一步是 L-&gt;M，则下一步绝对不是 M-&gt;Lpublic class HanoiProblem &#123;    public enum State &#123;        No, LToM, MToR, RToM, MToL    &#125;        public static int minStep(int n) &#123;        Stack&lt;Integer&gt; left = new Stack&lt;&gt;();        Stack&lt;Integer&gt; mid = new Stack&lt;&gt;();        Stack&lt;Integer&gt; right = new Stack&lt;&gt;();        left.push(Integer.MAX_VALUE);        mid.push(Integer.MAX_VALUE);        right.push(Integer.MAX_VALUE);        for (int i = n; i &gt; 0; i--) &#123;            left.push(i);        &#125;        State[] record = &#123;State.No&#125;;        int step = 0;        while (right.size() != n + 1) &#123;            step += process(record, State.MToL, State.LToM, left, mid, &quot;left&quot;, &quot;mid&quot;);            step += process(record, State.RToM, State.MToR, mid, right, &quot;mid&quot;, &quot;right&quot;);            step += process(record, State.MToR, State.RToM, right, mid, &quot;right&quot;, &quot;mid&quot;);            step += process(record, State.LToM, State.MToL, mid, left, &quot;mid&quot;, &quot;left&quot;);        &#125;        return step;    &#125;    public static int process(State[] record, State preNoAct, State nowAct, Stack&lt;Integer&gt; s1, Stack&lt;Integer&gt; s2, String from, String to) &#123;        if (record[0] != preNoAct &amp;&amp; s1.peek() &lt; s2.peek()) &#123;            int val = s1.pop();            s2.push(val);            System.out.println(&quot;move &quot; + val + &quot; from &quot; + from + &quot; to &quot; + to);            record[0] = nowAct;            return 1;        &#125;        return 0;    &#125;    public static void main(String[] args) &#123;        System.out.println(minStep(2));    &#125;&#125;</code></pre></li><li><p><strong>用一个栈实现另一个栈的排序</strong>：将一个整数类型的栈从顶到底按从大到小的顺序排序，只能申请一个栈。</p><pre><code class="language-java">public class SortStack &#123;    public static void sort(Stack&lt;Integer&gt; stack) &#123;        Stack&lt;Integer&gt; help = new Stack&lt;&gt;(); // 辅助栈        while (!stack.isEmpty()) &#123;            int cur = stack.pop();            while (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) &#123;                stack.push(help.pop());            &#125;            help.push(cur);        &#125;        while (!help.isEmpty()) &#123;            stack.push(help.pop());        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></p><p>示例：</p><pre><code class="language-java">输入: arr = [1,3,-1,-3,5,3,6,7], 和 w = 3输出: [3,3,5,5,6,7] 解释:   滑动窗口的位置                最大值---------------               -----[1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7</code></pre><pre><code class="language-java">public class MaxWindow &#123;    // 方法一，暴力枚举，但是会超时    // O(N x w)    public static int[] getMaxWindow1(int[] arr, int w) &#123;        int n = arr.length;        int[] res = new int[n - w + 1];        int left = 0;        int right = w;        while (right &lt; n + 1) &#123;            int maxVal = Integer.MIN_VALUE;            for (int i = left; i &lt; right; i++) &#123;                maxVal = Math.max(maxVal, arr[i]);            &#125;            res[left] = maxVal;            left++;            right++;        &#125;        return res;    &#125;        // 方法二：双端队列实现，复杂度O(N)    public static int[] getMaxWindow2(int[] arr, int w) &#123;        int n = arr.length;        int[] res = new int[n - w + 1];        Deque&lt;Integer&gt; dq = new LinkedList&lt;&gt;(); // 双端队列        int index = 0;        for (int i = 0; i &lt; arr.length; i++) &#123;            while (!dq.isEmpty() &amp;&amp; arr[dq.peekLast()] &lt;= arr[i]) &#123;                dq.pollLast();            &#125;            dq.addLast(i);            // 队头下标已过期            if (dq.peekFirst() == i - w) &#123;                dq.pollFirst();            &#125;            if (i &gt;= w - 1) &#123;                res[index++] = arr[dq.peekFirst()];            &#125;        &#125;        return res;    &#125;&#125;</code></pre></li></ul><h2 id="链表">链表</h2><p>重要技巧：</p><p>（1）特殊数据结构，如数组，哈希表等；</p><p>（2）快慢指针；</p><ul><li><p><a href="https://leetcode.cn/problems/reverse-linked-list/">反转单向链表</a></p><pre><code class="language-java">public class ReverseNode &#123;    public Node reverseNode(Node head) &#123;        Node pre = null;        Node next = null;        while (head != null) &#123;            next = head.next; // 记录后继节点            head.next = pre; // 当前节点指向前继节点            pre = head;  // 更新前继节点            head = next; // 更新当前节点为后继节点        &#125;        return pre;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除单链表中倒数第k个节点</a></p><pre><code class="language-java">// 快慢指针实现public class RemoveLastNode &#123;    public static Node removeNode(Node head, int k) &#123;        if (head == null || k &lt; 1) return null;        Node slow = head;        Node fast = head;        while (k != 0) &#123;            fast = fast.next;            k--;        &#125;        // 删除头节点        if (fast == null) &#123;            head = head.next;            return head;        &#125;        fast = fast.next;        while (fast != null) &#123;            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return head;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/linked-list-cycle-lcci/">环路检测</a>：给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 <code>null</code>。</p><p>思路：</p><p>（1）设置快慢指针<code>slow</code>和<code>fast</code>进行遍历，若fast遇到终点（null）则链表无环；</p><p>（2）若链表有环，则快慢指针一定在某个环内位置相遇，此时<code>fast</code>指针回到<code>head</code>的位置，每次走一步，<code>slow</code>指针不变，继续遍历，则两指针一定在环的入口相遇；</p><pre><code class="language-java">public class DetectCycle &#123;    public Node detectCycle(Node head) &#123;        if (head == null || head.next == null) &#123;            return null;        &#125;        Node slow = head;        Node fast = head;        while (fast != null &amp;&amp; fast.next != null) &#123;            slow = slow.next;            fast = fast.next.next;            // 快慢指针相遇            if (fast == slow) &#123;                fast = head;                while (fast != slow) &#123;                    slow = slow.next;                    fast = fast.next;                &#125;                return slow;            &#125;        &#125;        return null;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">判断两个链表是否相交</a>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><pre><code class="language-JAVA">public class IntersectionNode &#123;    public Node getIntersectionNode(Node headA, Node headB) &#123;        Node n1 = headA;        Node n2 = headB;        while (n1 != n2) &#123;            if (n1 == null) n1 = headA;            else n1 = n1.next;            if (n2 == null) n2 = headB;            else n2 = n2.next;        &#125;        return n1;    &#125;&#125;</code></pre></li></ul><h2 id="字符串">字符串</h2><ul><li><p><a href="https://leetcode.cn/problems/reverse-string/"> 反转字符串</a></p><pre><code class="language-java">class Solution &#123;    public void reverseString(char[] s) &#123;        int left = 0;        int right = s.length - 1;        while (left &lt; right) &#123;            char tmp = s[left];            s[left] = s[right];            s[right] = tmp;            left++;            right--;        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/reverse-string-ii/">反转字符串 II</a>：给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><pre><code class="language-java">class Solution &#123;    public String reverseStr(String s, int k) &#123;        char[] str = s.toCharArray();        for (int i = 0; i &lt; str.length; i += 2 * k) &#123;            // 剩余字符小于 2k 但大于或等于 k 个，反转前 k 个字符            if (str.length &gt;= i + k) &#123;                reverse(str, i, i + k - 1);                continue;            &#125;            // 剩余字符少于 k 个，将剩余字符全部反转            reverse(str, i, str.length - 1);        &#125;        return String.copyValueOf(str);    &#125;    public void reverse(char[] s, int left, int right) &#123;        while (left &lt; right) &#123;            char tmp = s[left];            s[left] = s[right];            s[right] = tmp;            left++;            right--;        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">替换空格</a></p><pre><code class="language-java">class Solution &#123;    public String replaceSpace(String s) &#123;        if(s==null)&#123;            return null;        &#125;                StringBuilder sb = new  StringBuilder();        for(int i=0;i&lt;s.length();i++)&#123;            if(s.charAt(i)==' ')&#123;                sb.append(&quot;%20&quot;);            &#125;else&#123;                sb.append(s.charAt(i));            &#125;        &#125;                return sb.toString();    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a></p><pre><code class="language-java">public class ReverseWords &#123;    public static String reverseWords(String s) &#123;        String[] strs = s                .trim() // 去除头尾空白符                .split(&quot; &quot;); // 以空格来分隔字符串        StringBuilder reverseString = new StringBuilder();        for (int i = strs.length - 1; i &gt;= 0; i--) &#123;            if (strs[i] == &quot;&quot;) continue;            reverseString.append(strs[i]);            if (i != 0) &#123;                reverseString.append(&quot; &quot;);            &#125;        &#125;        return reverseString.toString();    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></p><pre><code class="language-java">public class ReverseLeftWords &#123;    // 1.反转区间为前n的子串    // 2.反转区间为n到末尾的子串    // 3.反转整个字符串    public String reverseLeftWords(String s, int n) &#123;        char[] str = s.toCharArray();        reverse(str, 0, n - 1);        reverse(str, n, s.length() - 1);        reverse(str, 0, s.length() - 1);        return String.copyValueOf(str);    &#125;    // 反转字符串    public void reverse(char[] str, int start, int end) &#123;        while (start &lt; end) &#123;            char tmp = str[start];            str[start] = str[end];            str[end] = tmp;            start++;            end--;        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></p><pre><code class="language-java">public class StrStr &#123;    public static int strStr(String haystack, String needle) &#123;        int i = 0, j = 0;        int temp = 0;        while (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;            temp = i;            // 逐个匹配            while (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()                                          &amp;&amp; haystack.charAt(i) == needle.charAt(j)) &#123;                i++;                j++;            &#125;            // 匹配成功            if (j == needle.length()) &#123;                return i - needle.length();            &#125;            // 从下个位置继续匹配            i = temp + 1;            j = 0;        &#125;        return -1;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></p><p>判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><pre><code class="language-java">public class RepeatedSubstringPattern &#123;    public static boolean repeatedSubstringPattern(String s) &#123;        String ss = s + s;        String substring = ss.substring(1, ss.length() - 1);        return substring.contains(s);    &#125;    public static void main(String[] args) &#123;        System.out.println(repeatedSubstringPattern(&quot;abaaba&quot;));    &#125;&#125;</code></pre></li></ul><h2 id="二叉树">二叉树</h2><ul><li><p>二叉树前序遍历</p><pre><code class="language-java">public class PreOrderTraverse &#123;    // 递归遍历    public static void preOrderRecur(TreeNode root) &#123;        if (root == null) return;        System.out.print(root.val + &quot; &quot;);        preOrderRecur(root.left);        preOrderRecur(root.right);    &#125;    // 非递归遍历    public static void preOrderUnRecur(TreeNode root) &#123;        if (root == null) return;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        s.push(root);        while (!s.isEmpty()) &#123;            TreeNode cur = s.pop();            System.out.print(cur.val + &quot; &quot;);            if (cur.right != null) &#123;                s.push(cur.right);            &#125;            if (cur.left != null) &#123;                s.push(cur.left);            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>二叉树中序遍历</p><pre><code class="language-java">public class InOrderTraverse &#123;    // 递归遍历    public static void inOrderRecur(TreeNode root) &#123;        if (root == null) return;        inOrderRecur(root.left);        System.out.print(root.val + &quot; &quot;);        inOrderRecur(root.right);    &#125;        // 非递归遍历    public static void inOrderUnRecur(TreeNode root) &#123;        if (root == null) return;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        TreeNode cur = root;        while (!s.isEmpty() || cur != null) &#123;            // 先依次将左边界入栈            if (cur != null) &#123;                s.push(cur);                cur = cur.left;            &#125; else &#123;                cur = s.pop();                System.out.print(cur.val + &quot; &quot;);                cur = cur.right;            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>二叉树后序遍历</p><p>后续遍历关键在于，当节点的 <strong>右子树存在且被访问后</strong> 或者是 <strong>右子树为空</strong> 才能访问自身。</p><p>在遍历过程中，先将节点从的左孩子到最左节点压栈， 设置标志变量 flag 来判断是否访问过左孩子， pre指针来指向先前访问过的节点。所有左孩子压栈后， 最后一个节点的左孩子为空（已被访问） ， 令flag=1；</p><p>当左孩子被访问时，进入循环，取栈顶节点：</p><ol><li><p>当栈顶节点的右孩子 等于 <strong>空</strong> 或 <strong>前一个被访问的节点</strong> 时， 访问该节点， 令pre 等于当前节点， 当前节点出栈。</p></li><li><p>当栈顶节点的右孩子**不为空 **时， 继续遍历以右孩子为根节点的右子树。</p></li></ol><pre><code class="language-java">public class PostOrderTraverse &#123;    // 递归遍历    public static void postOrderRecur(TreeNode root) &#123;        if (root == null) return;        postOrderRecur(root.left);        postOrderRecur(root.right);        System.out.print(root.val + &quot; &quot;);    &#125;    // 非递归遍历    public static void postOrderUnRecur(TreeNode root) &#123;        if (root == null) return;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        TreeNode cur = root;        int flag = 0;        TreeNode pre = null; // 前一个被访问的节点        do &#123;            // 所有左节点入栈            while (cur != null) &#123;                s.push(cur);                cur = cur.left;            &#125;            flag = 1;            while (!s.isEmpty() &amp;&amp; flag == 1) &#123;                cur = s.peek();                // 若当前节点的右节点是【上一个被访问的节点】 或为【空】，则访问该节点                if (cur.right == null || cur.right == pre) &#123;                    s.pop();                    System.out.print(cur.val + &quot; &quot;);                    pre = cur;                &#125; else &#123;                    //继续遍历右子树                    cur = cur.right;                    flag = 0;                &#125;            &#125;        &#125; while (!s.isEmpty());    &#125;&#125;</code></pre><p><strong>另一种思路</strong>：由于前序遍历的顺序是 ”中左右“，后序遍历的顺序是”左右中“，因此更改前序遍历中的入栈顺序，然后将遍历结果反转，便能得到后序遍历的结果。</p><pre><code class="language-java">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果class Solution &#123;    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null)&#123;            return result;        &#125;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        stack.push(root);        while (!stack.isEmpty())&#123;            TreeNode node = stack.pop();            result.add(node.val);            if (node.left != null)&#123;                stack.push(node.left);            &#125;            if (node.right != null)&#123;                stack.push(node.right);            &#125;        &#125;        Collections.reverse(result);        return result;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"> 二叉树的最大深度</a></p><pre><code class="language-java">class Solution &#123;    public int maxDepth(TreeNode root) &#123;        if (root == null) return 0;        if (root.left == null &amp;&amp; root.right == null) return 1;        return Math.max(maxDepth(root.left) + 1, maxDepth(root.right) + 1);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a>：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><pre><code class="language-java">// 如果左子树为空，右子树不为空，最小深度是 1 + 右子树的最小深度。// 反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的最小深度。 // 如果左右子树都不为空，返回 1 + 左右子树深度最小值。class Solution &#123;    public int minDepth(TreeNode root) &#123;        if (root == null) return 0;        if (root.left != null &amp;&amp; root.right == null) return minDepth(root.left) + 1;        if (root.left == null &amp;&amp; root.right != null) return minDepth(root.right) + 1;        return Math.min(minDepth(root.left) + 1, minDepth(root.right) + 1);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></p><pre><code class="language-java">class Solution &#123;    public TreeNode invertTree(TreeNode root) &#123;        if(root==null) return null;        // 交换左右子树        TreeNode tmp = root.left;        root.left = root.right;        root.right = tmp;        invertTree(root.left);        invertTree(root.right);        return root;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>：判断二叉树是否为轴对称</p><pre><code class="language-java">class Solution &#123;    public boolean isSymmetric(TreeNode root) &#123;        if(root==null) return true;        return isSame(root.left,root.right);    &#125;    public boolean isSame(TreeNode t1,TreeNode t2)&#123;        if(t1==null &amp;&amp; t2==null) return true;        if(t1==null || t2==null) return false;        if(t1.val != t2.val) return false;        return isSame(t1.left,t2.right) &amp;&amp; isSame(t1.right,t2.left);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a>：平衡二叉树的<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1</p><pre><code class="language-java">class BalanceTree &#123;    public boolean isBalanced(TreeNode root) &#123;        if (root == null) return true;        int h1 = getHeight(root.left);        int h2 = getHeight(root.right);        if (Math.abs(h1 - h2) &gt; 1) return false;        else return isBalanced(root.left) &amp;&amp; isBalanced(root.right);    &#125;    // 求某个节点的最大高度    public int getHeight(TreeNode root) &#123;        if (root == null) return 0;        if (root.left == null &amp;&amp; root.right == null) return 1;        else return Math.max(getHeight(root.left) + 1, getHeight(root.right) + 1);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a>：给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><pre><code class="language-java">public class BinaryTreePaths &#123;    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;        List&lt;String&gt; paths = new LinkedList&lt;&gt;();        dfs(root, paths, &quot;&quot;);        return paths;    &#125;    public void dfs(TreeNode root, List&lt;String&gt; paths, String path) &#123;        if (root == null) return;        path += root.val;        if (root.left == null &amp;&amp; root.right == null) &#123;            paths.add(path);            return;        &#125;        dfs(root.left, paths, path + &quot;-&gt;&quot;);        dfs(root.right, paths, path + &quot;-&gt;&quot;);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">左叶子之和</a>：给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><pre><code class="language-java">public class LeftLeaves &#123;    // 递归法    public int sumOfLeftLeaves1(TreeNode root) &#123;        int res = 0;        if (root == null) return 0;        if (root.left == null &amp;&amp; root.right == null) return 0;        if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;            res += root.left.val;        &#125;        return res + sumOfLeftLeaves1(root.left) + sumOfLeftLeaves1(root.right);    &#125;    // 迭代法    public int sumOfLeftLeaves2(TreeNode root) &#123;        if (root == null) return 0;        int res = 0;        Stack&lt;TreeNode&gt; s = new Stack&lt;&gt;();        s.push(root);        while (!s.isEmpty()) &#123;            TreeNode node = s.pop();            if (node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) &#123;                res += node.left.val;            &#125;            if (node.left != null) s.push(node.left);            if (node.right != null) s.push(node.right);        &#125;        return res;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">找树左下角的值</a>：给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层最左边</strong> 节点的值。</p><pre><code class="language-java">// 利用层序遍历，最后一层的第一个值即为左下角的值class Solution &#123;    public int findBottomLeftValue(TreeNode root) &#123;        if (root == null) return -1;        Queue&lt;TreeNode&gt; q = new LinkedList&lt;&gt;();        int res = 0;        q.add(root);        while (!q.isEmpty()) &#123;            int size = q.size();            for (int i = 0; i &lt; size; i++) &#123;                TreeNode node = q.poll();                if (i == 0) res = node.val; // 记录最后一层第一个值                if (node.left != null) q.add(node.left);                if (node.right != null) q.add(node.right);            &#125;        &#125;        return res;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/path-sum/">路径总和</a>：给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><pre><code class="language-java">public class PathSum &#123;    public boolean hasPathSum(TreeNode root, int targetSum) &#123;        if (root == null) return false;        targetSum -= root.val;        // 找到一条路径        if (root.left == null &amp;&amp; root.right == null) &#123;            return targetSum == 0;        &#125;        if (root.left != null) &#123;            boolean left = hasPathSum(root.left, targetSum);            if (left) return true;        &#125;        if (root.right != null) &#123;            boolean right = hasPathSum(root.right, targetSum);            if (right) return true;        &#125;        return false;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p><pre><code class="language-java">public class BuildTree1 &#123;    HashMap&lt;Integer, Integer&gt; map;    public TreeNode buildTree(int[] inorder, int[] postorder) &#123;        int n = inorder.length;        if (n == 0) return null;        map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; n; i++) &#123;            map.put(inorder[i], i); // 保存中序序列值得对应位置，方便查询        &#125;        return helper(inorder, 0, n, postorder, 0, n); // 左闭右开    &#125;    public TreeNode helper(int[] inorder, int inBegin, int inEnd,                           int[] postorder, int postBegin, int postEnd) &#123;        // 不满足左闭右开，说明没有元素，返回空树        if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) return null;        // 找到后序遍历的最后一个元素在中序遍历中的位置        // 构造根节点        int rootIndex = map.get(postorder[postEnd - 1]);        TreeNode root = new TreeNode(inorder[rootIndex]);        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数        root.left = helper(inorder, inBegin, rootIndex,                            postorder, postBegin, postBegin + lenOfLeft);        root.right = helper(inorder, rootIndex + 1, inEnd,                            postorder, postBegin + lenOfLeft, postEnd - 1);        return root;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">从前序和中序遍历序列构造二叉树</a></p><pre><code class="language-java">public class BuildTree2 &#123;    HashMap&lt;Integer, Integer&gt; map;    public TreeNode buildTree(int[] preorder, int[] inorder) &#123;        int n = inorder.length;        if (n == 0) return null;        map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; n; i++) &#123;            map.put(inorder[i], i); // 保存中序序列值得对应位置，方便查询        &#125;        return helper(preorder, 0, n, inorder, 0, n); // 左闭右开    &#125;    public TreeNode helper(int[] preorder, int preBegin, int preEnd,                           int[] inorder, int inBegin, int inEnd) &#123;        // 不满足左闭右开，说明没有元素，返回空树        if (inBegin &gt;= inEnd || preBegin &gt;= preEnd) return null;        // 找到前序遍历的第一个元素在中序遍历中的位置        // 构造根节点        int rootIndex = map.get(preorder[preBegin]);        TreeNode root = new TreeNode(inorder[rootIndex]);        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数        root.left = helper(preorder, preBegin + 1, preBegin + lenOfLeft + 1,                           inorder, inBegin, rootIndex);        root.right = helper(preorder, preBegin + lenOfLeft + 1, preEnd,                           inorder, rootIndex + 1, inEnd);        return root;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/"> 验证二叉搜索树</a>：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><pre><code class="language-java">/** * 对于一个合法的二叉搜索树，节点的左子树只包含 小于 当前节点的数，节点的右子树只包含 大于 当前节点的数。 * 因此，它的中序遍历是升序的 */class Solution &#123;    long pre = Long.MIN_VALUE;    public boolean isValidBST(TreeNode root) &#123;        if (root == null) return true;        // 访问左子树        if (!isValidBST(root.left)) &#123;            return false;        &#125;                if (root.val &lt;= pre) return false;        pre = root.val;        // 访问右子树        return isValidBST(root.right);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/"> 二叉树的最近公共祖先</a></p><pre><code class="language-java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if (root == null || root == p || root == q) return root;        // 后序遍历,自底向上        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        if (left == null &amp;&amp; right == null) return null; // 未找到节点        if (left == null) return right; // 目标节点在右边找到        if (right == null) return left; // 目标节点在左边找到        // 如果left和right都不为空，则最近公共祖先就是root        return root;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/"> 二叉搜索树的最近公共祖先</a></p><pre><code class="language-java">class Solution &#123;    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;        if (root == null || root == p || root == q) return root;        /**         * 利用二叉搜索树的性质：         * 1. 若p和q节点的值都比当前节点的值小，则目标节点在左子树         * 2. 若p和q节点的值都比当前节点的值大，则目标节点在右子树         * 3. 若p和q节点的值在当前节点值得两边，则目标节点为当前节点         */        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;            return lowestCommonAncestor(root.left, p, q);        &#125; else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;            return lowestCommonAncestor(root.right, p, q);        &#125; else &#123;            return root;        &#125;    &#125;&#125;</code></pre></li></ul><h2 id="回溯">回溯</h2><ul><li><p>回溯算法模板</p><pre><code class="language-java">void backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    /**    * --&gt;循环体，树的宽度--&gt;                        */    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归，树的深度         回溯，撤销处理结果    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/combinations/">组合</a>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 <strong>任何顺序</strong> 返回答案。</p><pre><code class="language-java">class Combine &#123;    List&lt;List&lt;Integer&gt;&gt; res;    LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        process(n, k, 1);        return res;    &#125;    public void process(int n, int k, int index) &#123;        // 终止条件        if (path.size() == k) &#123;            res.add(new LinkedList&lt;&gt;(path)); // 存放结果            return;        &#125;        for (int i = index; i &lt;= n-(k-path.size())+1; i++) &#123; // jian'zhi            // 处理节点            path.add(i);            process(n, k, i + 1); // 递归            path.removeLast(); // 回溯，撤销处理结果        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/combination-sum-iii/">组合总和 III</a>：找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回<em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><pre><code class="language-java">public class CombinationSum3 &#123;    List&lt;List&lt;Integer&gt;&gt; res;    LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        process(n, k, 1);        return res;    &#125;    public void process(int target, int k, int index) &#123;        // 剪枝        if (target &lt; 0) &#123;            return;        &#125;        // 终止条件        if (path.size() == k &amp;&amp; target == 0) &#123;            res.add(new LinkedList&lt;&gt;(path));            return;        &#125;        for (int i = index; i &lt;= 9; i++) &#123;            // 处理节点            path.add(i);            target -= i;            // 递归            process(target, k, i + 1);            // 回溯            path.removeLast();            target += i;        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a>：给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 不同组合 ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><pre><code class="language-java">public class CombinationSum &#123;    List&lt;List&lt;Integer&gt;&gt; res;    LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        process(candidates, target, 0);        return res;    &#125;    public void process(int[] candidates, int target, int index) &#123;        // 剪枝        if (target &lt; 0) &#123;            return;        &#125;        if (target == 0) &#123;            res.add(new LinkedList&lt;&gt;(path));            return;        &#125;        for (int i = index; i &lt; candidates.length; i++) &#123;            // 处理节点            path.add(candidates[i]);            target -= candidates[i];            // 递归            process(candidates, target, i); // 关键：不用递归 i+1, 表示元素可以被重复取到            // 回溯            path.removeLast();            target += candidates[i];        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a>：给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><pre><code class="language-java">public class LetterCombinations &#123;    char[][] map = &#123;&#123;&#125;, &#123;&#125;, &#123;'a', 'b', 'c'&#125;, &#123;'d', 'e', 'f'&#125;, &#123;'g', 'h', 'i'&#125;, &#123;'j', 'k', 'l'&#125;,                     &#123;'m', 'n', 'o'&#125;, &#123;'p', 'q', 'r', 's'&#125;, &#123;'t', 'u', 'v'&#125;, &#123;'w', 'x', 'y', 'z'&#125;&#125;;    List&lt;String&gt; res;    StringBuilder sb = new StringBuilder();    public List&lt;String&gt; letterCombinations(String digits) &#123;        res = new LinkedList&lt;&gt;();        if (digits.length() == 0) &#123;            return res;        &#125;        process(digits, 0);        return res;    &#125;    public void process(String digits, int index) &#123;        // 终止条件        if (index == digits.length()) &#123;            res.add(sb.toString());            return;        &#125;        int digit = digits.charAt(index) - '0';        char[] str = map[digit];        for (int i = 0; i &lt; str.length; i++) &#123;            sb.append(str[i]);            process(digits, index + 1); // 由于是不同数字之间组合，所以是 index与 index+1 ...之间组合            sb.deleteCharAt(sb.length() - 1); // 回溯，重新尝试        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和 II</a>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。注意：**解集不能包含重复的组合。 **</p><p>由于<code>candidates</code>中存在重复元素，因此本题的关键在于如何去重。</p><pre><code class="language-java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; res;    LinkedList&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        Arrays.sort(candidates); // 排序，使相同元素在一起        process(candidates, target, 0);        return res;    &#125;    public void process(int[] candidates, int target, int index) &#123;        // 剪枝        if (target &lt; 0) &#123;            return;        &#125;        if (target == 0) &#123;            LinkedList&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(path);//            // 简单判断去重，但是会超时//            if (!res.contains(tmp)) &#123;//                res.add(tmp);//            &#125;            res.add(tmp);            return;        &#125;        for (int i = index; i &lt; candidates.length; i++) &#123;            // 去重            if (i &gt; index &amp;&amp; candidates[i] == candidates[i - 1]) &#123;                continue;            &#125;            // 处理节点            path.add(candidates[i]);            target -= candidates[i];            // 递归            process(candidates, target, i + 1);            // 回溯            path.removeLast();            target += candidates[i];        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a>：给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><pre><code class="language-java">public class PalindromePartition &#123;    List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;String&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        if (s.length() == 0) &#123;            return null;        &#125;        process(s, 0);        return res;    &#125;    public void process(String s, int index) &#123;        if (index &gt;= s.length()) &#123;            res.add(new LinkedList&lt;&gt;(path));            return;        &#125;        for (int i = index; i &lt; s.length(); i++) &#123;            if (isPalindrome(s, index, i)) &#123;                String tmp = s.substring(index, i + 1);                path.add(tmp);            &#125; else &#123;                continue;            &#125;            process(s, i + 1); // 递归            path.remove(path.size() - 1); //回溯        &#125;    &#125;    // 判断回文    public boolean isPalindrome(String s, int start, int end) &#123;        for (int i = start, j = end; i &lt; j; i++, j--) &#123;            if (s.charAt(i) != s.charAt(j)) &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/subsets/">子集</a>：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><pre><code class="language-java">class Subsets &#123;    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        res.add(new LinkedList&lt;&gt;()); // 空集        process(nums, 0);        return res;    &#125;    public void process(int[] nums, int index) &#123;        if (!res.contains(path)) &#123;            res.add(new LinkedList&lt;&gt;(path));        &#125;        if (path.size() == nums.length) return; // 说明找完了        for (int i = index; i &lt; nums.length; i++) &#123;            path.add(nums[i]);            process(nums, i + 1);            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/subsets-ii/">子集 II</a>：给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><pre><code class="language-java">public class Subsets2 &#123;    List&lt;List&lt;Integer&gt;&gt; res;    List&lt;Integer&gt; path;    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;        res = new LinkedList&lt;&gt;();        path = new LinkedList&lt;&gt;();        Arrays.sort(nums); // 排序        res.add(new LinkedList&lt;&gt;()); // 空集        process(nums, 0);        return res;    &#125;    public void process(int[] nums, int index) &#123;        if (!res.contains(path)) &#123;            res.add(new LinkedList&lt;&gt;(path));        &#125;        if (path.size() == nums.length) return; // 说明找完了        for (int i = index; i &lt; nums.length; i++) &#123;            if (i &gt; index &amp;&amp; nums[i] == nums[i - 1]) &#123; // 去重                continue;            &#125;            path.add(nums[i]);            process(nums, i + 1);            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">递增子序列</a>：给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。数组中可能含有重复元素，如出现<strong>两个整数相等，也可以视作递增序列的一种特殊情况</strong>。</p><pre><code class="language-java">class Solution &#123;    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;        process(nums, 0);        return res;    &#125;    public void process(int[] nums, int index) &#123;        if (path.size() &gt; 1) &#123;            res.add(new LinkedList&lt;&gt;(path));        &#125;        // HashSet 去重        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();        for (int i = index; i &lt; nums.length; i++) &#123;            if (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - 1) || hs.contains(nums[i])) &#123;                continue;            &#125;            path.add(nums[i]);            hs.add(nums[i]);            process(nums, i + 1);            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/permutations/">全排列</a>：给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><pre><code class="language-java">public class Permute &#123;    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        boolean[] used = new boolean[nums.length];        process(nums, used);        return res;    &#125;    /**     * 全排列问题，每次都需要从头开始搜索,因此不用参数index     * used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。     */    public void process(int[] nums, boolean[] used) &#123;        if (path.size() == nums.length) &#123;            res.add(new LinkedList&lt;&gt;(path));            return;        &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (used[i]) &#123;                continue;            &#125;            path.add(nums[i]);            used[i] = true;            process(nums, used);            // 回溯            used[i] = false;            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/permutations-ii/"> 全排列 II</a>：给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有<strong>不重复</strong>的全排列。</p><pre><code class="language-java">public class PermuteUnique &#123;    List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;();    List&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;        boolean[] used = new boolean[nums.length];        process(nums, used);        return res;    &#125;    public void process(int[] nums, boolean[] used) &#123;        if (path.size() == nums.length) &#123;            res.add(new LinkedList&lt;&gt;(path));            return;        &#125;        // HashSet 去重        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;            if (used[i] || hs.contains(nums[i])) &#123;                continue;            &#125;            path.add(nums[i]);            hs.add(nums[i]);            used[i] = true;            process(nums, used);            // 回溯            used[i] = false;            path.remove(path.size() - 1);        &#125;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/n-queens/">N 皇后</a></p><pre><code class="language-java">class Solution &#123;    List&lt;List&lt;String&gt;&gt; res = new LinkedList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;        char[][] matrix = new char[n][n];        for (int i = 0; i &lt; matrix.length; i++) &#123;            for (int j = 0; j &lt; matrix[0].length; j++) &#123;                matrix[i][j] = '.';            &#125;        &#125;        process(matrix,n,0);        return res;    &#125;    public void process(char[][] matrix, int n, int row) &#123;        if (row == n) &#123;            List&lt;String&gt; list = new LinkedList&lt;&gt;();            for (int i = 0; i &lt; n; i++) &#123;                StringBuilder sb = new StringBuilder();                int k = 0;                while (k &lt; n) &#123;                    sb.append(matrix[i][k++]);                &#125;                list.add(sb.toString());            &#125;            res.add(list);            return;        &#125;        for (int col = 0; col &lt; n; col++) &#123;            if (isValid(matrix, row, col, n)) &#123;                matrix[row][col] = 'Q'; // 放置皇后                process(matrix, n, row + 1);                matrix[row][col] = '.'; // 回溯，撤销            &#125;        &#125;    &#125;    // 检查是否合法    public static boolean isValid(char[][] matrix, int row, int col, int n) &#123;        // 检查列        for (int i = 0; i &lt; row; i++) &#123;            if (matrix[i][col] == 'Q') &#123;                return false;            &#125;        &#125;        // 检查左上        for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;            if (matrix[i][j] == 'Q') &#123;                return false;            &#125;        &#125;        // 检查右上        for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt; n; i--, j++) &#123;            if (matrix[i][j] == 'Q') &#123;                return false;            &#125;        &#125;        return true;    &#125;&#125;</code></pre></li></ul><h2 id="贪心算法">贪心算法</h2><ul><li><p><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a>：对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><pre><code class="language-java">class BiscuitDistribution &#123;    public int findContentChildren(int[] g, int[] s) &#123;        // 排序        Arrays.sort(g);        Arrays.sort(s);        int res = 0;        int child = g.length - 1;        for (int i = s.length - 1; i &gt;= 0; i--) &#123;            if (child &lt; 0) break;            // 不能分配            while (child &gt; 0 &amp;&amp; s[i] &lt; g[child]) &#123;                child--;            &#125;            // 可以分配            if (s[i] &gt;= g[child]) &#123;                res++;                child--;            &#125;        &#125;        return res;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></p><pre><code class="language-java">public class WiggleSubsequence &#123;    public int wiggleMaxLength(int[] nums) &#123;        if (nums.length &lt;= 1) &#123;            return nums.length;        &#125;        int ans = 1;        int pre = 0;        int cur = 0;        for (int i = 1; i &lt; nums.length; i++) &#123;            cur = nums[i] - nums[i - 1];            if ((cur &gt; 0 &amp;&amp; pre &lt;= 0) || (cur &lt; 0 &amp;&amp; pre &gt;= 0)) &#123;                ans++;                pre = cur;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><pre><code class="language-java">public class MaxSubArray &#123;    public int maxSubArray(int[] nums) &#123;        if (nums.length &lt;= 1) &#123;            return nums[0];        &#125;        int res = Integer.MIN_VALUE;        int count = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;            count += nums[i];            res = Math.max(res, count);            // 重置，因为遇到负数一定会使res减小            if (count &lt; 0) &#123;                count = 0;            &#125;        &#125;        return res;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>：给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><pre><code class="language-java">/** * 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。 * 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。 * 就是把利润分解为每天为单位的维度 */public class MaxProfit &#123;    public int maxProfit(int[] prices) &#123;        if (prices.length &lt;= 1) &#123;            return 0;        &#125;        int ans = 0;        for (int i = 1; i &lt; prices.length; i++) &#123;            ans += Math.max(0, prices[i] - prices[i - 1]);        &#125;        return ans;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code>。</p><pre><code class="language-java">class MaxProfit &#123;    public int maxProfit(int[] prices) &#123;        int ans = 0;        for (int i = 1; i &lt; prices.length; i++) &#123;            ans = Math.max(prices[i] - prices[i - 1], ans);            prices[i] = Math.min(prices[i], prices[i - 1]);        &#125;        return ans;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a>：给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><pre><code class="language-java">/** * 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。 * 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。 */class Solution &#123;    public boolean canJump(int[] nums) &#123;        if (nums.length == 1) return true;        int coverRange = 0;        for (int i = 0; i &lt;= coverRange; i++) &#123;            coverRange = Math.max(coverRange, i + nums[i]);            if (coverRange &gt;= nums.length - 1) &#123;                return true;            &#125;        &#125;        return false;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a>：给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><pre><code class="language-java">class Solution &#123;    public int jump(int[] nums) &#123;        if (nums.length &lt;= 1) &#123;            return 0;        &#125;        int next = 0;        int step = 0;        int cur = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;            next = Math.max(next, i + nums[i]);            if (next &gt;= nums.length - 1) &#123;                step++;                break;            &#125;            if (i == cur) &#123;                cur = next;                step++;            &#125;        &#125;        return step;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/gas-station/">加油站</a></p><pre><code class="language-java">class Solution &#123;    // 暴力模拟 O(n^2)    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        for(int i=0;i&lt;gas.length;i++)&#123;            int rest = gas[i] - cost[i]; // 剩余油量            int pos = (i+1) % gas.length; // 模拟出发的位置            while(rest&gt;0 &amp;&amp; pos!=i)&#123;                rest += gas[pos] - cost[pos];                pos = (pos + 1) % gas.length;            &#125;            if(rest&gt;=0 &amp;&amp; pos==i)&#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 贪心 O(N)    public int canCompleteCircuit(int[] gas, int[] cost) &#123;        int rest = 0;        int total = 0;        int pos = 0;        for(int i=0;i&lt;gas.length;i++)&#123;            rest += gas[i] - cost[i];             total += gas[i] - cost[i];            // 如果之前累加剩余油量为负值，则肯定无法从i之前的位置到达            if(rest&lt;0)&#123;                pos = i + 1;                rest = 0;            &#125;        &#125;        if(total&lt;0) return -1;        return pos;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/candy/">分发糖果</a>：<code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong>。</p><pre><code class="language-java">/** * 本题采用了两次贪心的策略。 * 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。 * 一次是从右到左遍历，只比较左边孩子评分比右边大的情况 */class Candy &#123;    public static int candy(int[] ratings) &#123;        int[] candys = new int[ratings.length];        candys[0] = 1;        // 从前往后，右边比左边大的情况        for (int i = 1; i &lt; ratings.length; i++) &#123;            if (ratings[i] &gt; ratings[i - 1]) &#123;                candys[i] = candys[i - 1] + 1;            &#125; else &#123;                candys[i] = 1;            &#125;        &#125;        // 从前往后，左边比右边大的情况        for (int i = ratings.length - 2; i &gt;= 0; i--) &#123;            if (ratings[i] &gt; ratings[i + 1]) &#123;                candys[i] = Math.max(candys[i + 1] + 1, candys[i]);            &#125;        &#125;        int res = 0;        for (int candy : candys) &#123;            res += candy;        &#125;        return res;    &#125;&#125;</code></pre></li></ul><h2 id="动态规划">动态规划</h2><ul><li><p><a href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></p><pre><code class="language-java">class Solution &#123;    public int fib(int n) &#123;        if (n == 0 || n == 1) return n;        int a = 0;        int b = 1;        for (int i = 2; i &lt;= n; i++) &#123;            int sum = a + b;            a = b;            b = sum;        &#125;        return b;    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a>：给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><pre><code class="language-java">class Solution &#123;    public int minCostClimbingStairs(int[] cost) &#123;        int n = cost.length;        int[] dp = new int[n + 1]; // dp[i]表示爬前i个楼梯所需的最小花费        dp[0] = 0;        dp[1] = 0;        for (int i = 2; i &lt;= n; i++) &#123;            int p1 = dp[i - 1] + cost[i - 1];            int p2 = dp[i - 2] + cost[i - 2];            dp[i] = Math.min(p1, p2);        &#125;        return dp[n];    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></p><pre><code class="language-java">// 暴力递归class Solution &#123;    public int rob(int[] nums) &#123;        return helper(nums, 0);    &#125;    public int helper(int[] nums, int index) &#123;        if (index &lt; 0 || index &gt; nums.length - 1) &#123;            return 0;        &#125;        return Math.max(nums[index] + helper(nums, index + 2), helper(nums, index + 1));    &#125;&#125;// 动态规划class Solution &#123;    public int rob(int[] nums) &#123;        int n = nums.length;        if (n == 1) &#123;            return nums[0];        &#125;        int[] money = new int[n]; // 偷盗前i个房屋，能获得的最大价值        money[0] = nums[0];        money[1] = Math.max(nums[0], nums[1]);        for (int i = 2; i &lt; n; i++) &#123;            money[i] = Math.max(nums[i] + money[i - 2], money[i - 1]);        &#125;        return money[n - 1];    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></p><pre><code class="language-java">class Solution &#123;    public int rob(int[] nums) &#123;        int n = nums.length;        if (n == 1) &#123;            return nums[0];        &#125;        // 两种情况：取首或取尾        return Math.max(helper(nums, 0, n - 2), helper(nums, 1, n - 1));    &#125;    public int helper(int[] nums, int start, int end) &#123;        if (start == end) &#123;            return nums[start];        &#125;        int[] money = new int[nums.length]; // 偷盗前i个房屋，能获得的最大价值        money[start] = nums[start];        money[start + 1] = Math.max(nums[start], nums[start + 1]);        for (int i = start + 2; i &lt;= end; i++) &#123;            money[i] = Math.max(nums[i] + money[i - 2], money[i - 1]);        &#125;        return money[end];    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 III</a></p><pre><code class="language-java">class Solution &#123;    // 暴力递归    public int rob(TreeNode root) &#123;        if (root == null) return 0;        if (root.left == null &amp;&amp; root.right == null) &#123;            return root.val;        &#125;        int val1 = root.val;        // 偷父节点        if (root.left != null) &#123;            val1 += rob(root.left.left) + rob(root.left.right);        &#125;        if (root.right != null) &#123;            val1 += rob(root.right.left) + rob(root.right.right);        &#125;        // 不偷父节点        int val2 = rob(root.left) + rob(root.right);        return Math.max(val1, val2);    &#125;        // 优化    // 通过map记录计算过的节点，降低时间复杂度public int rob(TreeNode root) &#123;        if (root == null) return 0;        if (root.left == null &amp;&amp; root.right == null) &#123;            return root.val;        &#125;        // 如果已经计算过，则直接返回结果        if (map.containsKey(root)) &#123;            return map.get(root);        &#125;        int val1 = root.val;        // 偷父节点        if (root.left != null) &#123;            val1 += rob(root.left.left) + rob(root.left.right);        &#125;        if (root.right != null) &#123;            val1 += rob(root.right.left) + rob(root.right.right);        &#125;        // 不偷父节点        int val2 = rob(root.left) + rob(root.right);        map.put(root, Math.max(val1, val2)); // 记录中间结果        return Math.max(val1, val2);    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a>：一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p><pre><code class="language-java">public class RobotPath &#123;    static int ans = 0;    // 暴力递归    public static int uniquePaths1(int m, int n) &#123;        int[][] matrix = new int[m][n];        dfs(matrix, 0, 0);        return ans;    &#125;    public static void dfs(int[][] matrix, int x, int y) &#123;        if (x &lt; 0 || y &lt; 0 || x &gt; matrix.length - 1 ||                y &gt; matrix[0].length - 1 || matrix[x][y] != 0) &#123;            return;        &#125;        // 找到一条路径        if (x == matrix.length - 1 &amp;&amp; y == matrix[0].length - 1) &#123;            ans++;        &#125;        matrix[x][y] = 1; // 标记，已经过的位置        dfs(matrix, x + 1, y);        dfs(matrix, x, y + 1);        matrix[x][y] = 0; // 回溯，撤回结果    &#125;    // 动态规划    public static int uniquePaths2(int m, int n) &#123;        int[][] dp = new int[m][n]; // dp[i][j]表示到达(i,j)的路径数        for (int i = 0; i &lt; m; i++) dp[i][0] = 1;        for (int j = 0; j &lt; n; j++) dp[0][j] = 1;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++) &#123;                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></p><pre><code class="language-java">public class RobotPathII &#123;    static int ans = 0;    // 暴力递归    public static int uniquePathsWithObstacles1(int[][] obstacleGrid) &#123;        dfs(obstacleGrid, 0, 0);        return ans;    &#125;    public static void dfs(int[][] ob, int x, int y) &#123;        if (x &lt; 0 || y &lt; 0 || x &gt; ob.length - 1 || y &gt; ob[0].length - 1 || ob[x][y] != 0) &#123;            return;        &#125;        if (x == ob.length - 1 &amp;&amp; y == ob[0].length - 1) &#123;            ans++;        &#125;        ob[x][y] = 2;        dfs(ob, x + 1, y);        dfs(ob, x, y + 1);        ob[x][y] = 0;    &#125;        // 动态规划    public static int uniquePathsWithObstacles2(int[][] obstacleGrid) &#123;        int m = obstacleGrid.length;        int n = obstacleGrid[0].length;        int[][] dp = new int[m][n];  // dp[i][j]:到达(i,j)的路径数        for (int i = 0; i &lt; m; i++) &#123;            if (obstacleGrid[i][0] != 1) &#123;                dp[i][0] = 1;            &#125;        &#125;        for (int j = 0; j &lt; n; j++) &#123;            if (obstacleGrid[0][j] != 1) &#123;                dp[0][j] = 1;            &#125;        &#125;        for (int i = 1; i &lt; m; i++) &#123;            for (int j = 1; j &lt; n; j++) &#123;                if (obstacleGrid[i][j] == 0) &#123;                    dp[i][j] = dp[i][j - 1] + dp[i - 1][j];                &#125;            &#125;        &#125;        return dp[m - 1][n - 1];    &#125;&#125;</code></pre></li><li><p><a href="https://leetcode.cn/problems/unique-paths-iii/">不同路径 III</a></p><pre><code class="language-java">public class RobotPathIII &#123;    public static int uniquePathsIII(int[][] grid) &#123;        int m = grid.length;        int n = grid[0].length;        int rest = 1; // 起点到终点需要一步（无障碍）        int[] start = new int[2];        for (int i = 0; i &lt; m; i++) &#123;            for (int j = 0; j &lt; n; j++) &#123;                if (grid[i][j] == 1) &#123;                    start[0] = i;                    start[1] = j;                &#125;                if (grid[i][j] == 0) &#123;                    rest++;                &#125;            &#125;        &#125;        return dfs(grid, start[0], start[1], rest);    &#125;    // 暴力递归    public static int dfs(int[][] grid, int x, int y, int rest) &#123;        if (x &lt; 0 || y &lt; 0 || x &gt; grid.length - 1 || y &gt; grid[0].length - 1 || grid[x][y] == -1) &#123;            return 0;        &#125;        if (grid[x][y] == 2) &#123;            return rest == 0 ? 1 : 0;        &#125;        grid[x][y] = -1;        int sum = 0;        sum += dfs(grid, x + 1, y, rest - 1);        sum += dfs(grid, x, y + 1, rest - 1);        sum += dfs(grid, x - 1, y, rest - 1);        sum += dfs(grid, x, y - 1, rest - 1);        grid[x][y] = 0;        return sum;    &#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Web开发相关</title>
      <link href="/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Web访问流程">Web访问流程</h2><ul><li>1、输入地址</li><li>2、浏览器查找域名的 IP 地址</li><li>3、浏览器向 <code>web</code> 服务器发送一个 <code>HTTP</code> 请求</li><li>4、服务器的永久重定向响应</li><li>5、浏览器跟踪重定向地址</li><li>6、服务器处理请求</li><li>7、服务器返回一个 <code>HTTP</code> 响应</li><li>8、浏览器显示 <code>HTML</code></li><li>9、浏览器发送请求获取嵌入在 <code>HTML</code> 中的资源（如图片、音频、视频、CSS、JS等等）</li></ul><h2 id="TCP-IP协议">TCP/IP协议</h2><ul><li><p>四个概念层</p><ul><li><strong>应用层</strong>：为用户提供所需要的各种服务；应用层协议包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（域名解析）以及许多其他协议。</li><li><strong>传输层</strong>：为应用层实体提供端到端的通信功能，保证了数据包的传输顺序和数据的的完整性；<strong>TCP</strong>传输控制协议和<strong>UDP</strong>用户数据报协议。<ul><li><strong>TCP</strong>协议是一个<strong>面向连接的、可靠的</strong>传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。</li><li><strong>UDP</strong>协议是一个<strong>面向无连接</strong>的数据报协议，是一个**“尽力传递”和“不可靠”**协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。</li><li>总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。</li></ul></li><li><strong>网络层</strong>：主要解决主机到主机之间的通信问题；网络层协议的代表包括：ICMP、IP、IGMP等。</li><li><strong>链路层</strong>：其主要协议有ARP、RARP等。</li></ul></li><li><p><strong>IP协议</strong></p><ul><li>互联网上每个计算机的<strong>唯一标识</strong>就是IP地址；</li><li><strong>分组传输</strong>：IP协议将数据分成若干个数据包进行传输，每个数据包包含了目标地址等信息。</li><li><strong>不可靠传输</strong>：IP协议不保证数据包的可靠传输，数据包在传输过程中可能会丢失、重复或乱序。</li><li><strong>简单路由</strong>：IP协议使用简单的路由算法，每个路由器只根据目标地址来选择下一个路由器，而不考虑其他因素。</li><li><strong>网络层协议</strong>：IP协议位于网络层，它与上层协议（如TCP、UDP）和下层协议（如数据链路层）进行交互。</li></ul></li><li><p><strong>IPV4</strong></p><ul><li>共四组，每组8个<code>bit</code>；如<code>192.168.1.10</code>；</li><li>共$2^{32}$ 个IP地址，目前已经分配完了；</li></ul></li><li><p><strong>IPV6</strong></p><ul><li>共八组，每组16个<code>bit</code>；</li><li>共$2^{128}$个IP地址；</li></ul></li><li><p><strong>特殊IP</strong></p><ul><li><code>127.0.0.1</code>也称<code>localhost:</code>，本地IP，永远只会寻找本地IP；</li></ul></li><li><p><strong>TCP协议</strong></p><ul><li><p>建立在IP协议之上，负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。</p></li><li><p><strong>TCP三次握手</strong></p><ul><li><p>客户端向服务器发送SYN（同步）数据包，表示客户端想要建立连接，并告诉服务器自己的初始序号（seq=x）。</p></li><li><p>服务器接收到客户端的SYN数据包后，向客户端发送SYN+ACK（同步和确认）数据包，表示服务器已经收到了客户端的请求，并告诉客户端自己的初始序号（seq=y）和确认序号（ack=x+1）。</p></li><li><p>客户端接收到服务器的SYN+ACK数据包后，向服务器发送ACK（确认）数据包，告诉服务器已经收到了服务器的确认，并确认自己的序列号（seq=x+1），服务器的初始序号（ack = y+1）。此时，TCP连接建立，客户端进入<strong>ESTABLISHED已建立连接状态</strong> 触发三次握手。</p></li><li><p>TCP三次握手的目的是为了确保客户端和服务器之间的通信能够正常进行，防止因为网络延迟等因素导致的连接失败。同时，它也可以防止网络中的恶意攻击，比如TCP SYN攻击等。</p></li></ul></li><li><p>断开一个 TCP 连接则需要**“四次挥手**”，缺一不可 ：</p><ol><li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li><li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li><li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li></ol></li></ul></li><li><p>socket</p><ul><li><p>Socket通常包括以下几个要素：</p><ul><li>IP地址：用于标识网络中的计算机。</li><li>端口号：用于标识计算机上的进程。</li><li>协议类型：用于标识通信使用的协议类型，比如TCP、UDP等。</li></ul></li><li><p>Socket通信的流程通常包括以下几个步骤：</p><ul><li>服务器程序创建一个Socket，并绑定到一个IP地址和端口号。</li><li>客户端程序创建一个Socket，并连接到服务器的IP地址和端口号。</li><li>服务器程序接收连接请求，并创建一个新的Socket来处理客户端请求。</li><li>客户端程序发送数据到服务器，服务器程序接收数据并处理。</li><li>服务器程序发送数据到客户端，客户端程序接收数据并处理。</li><li>客户端和服务器程序关闭Socket。</li></ul></li></ul></li></ul><h2 id="端口">端口</h2><ul><li>应用程序的唯一标识；</li><li>由两个字节表示的整数，范围0~65535；</li><li>一个端口只能被一个应用程序使用；</li></ul><h2 id="HTTP">HTTP</h2><ul><li><p><strong>HTTP（Hypertext Transfer Protocol）</strong>（超文本传输协议）是一种应用层协议，用于在Web浏览器和Web服务器之间传输数据。</p></li><li><p>HTTP协议的基本工作流程如下：</p><ol><li>客户端向服务器发送HTTP请求，请求可以是<strong>GET、POST、PUT、DELETE</strong>等方法，其中GET方法用于获取资源，POST方法用于提交数据，PUT方法用于修改资源，DELETE方法用于删除资源。</li><li>服务器接收到请求后，会根据请求的方法和URI（Uniform Resource Identifier）来确定要响应的资源，并返回HTTP响应消息。响应消息包括状态行、消息头和消息体。</li><li>客户端接收到响应消息后，会解析消息头和消息体，并根据<strong>状态码</strong>来判断请求是否成功。</li></ol></li><li><p><strong>报文</strong></p><ul><li><p>报文结构</p><ul><li>起始行（请求行，响应行）</li><li>首部（key-value的形式）</li><li>主体</li></ul></li><li><p><strong>请求报文</strong></p></li></ul><pre><code class="language-http">GET /v3/api-docs HTTP/1.1Host: localhost:8080Accept: application/json,*/*//首部与主体之间有空行...  // 请求主体：客户端发给服务端的数据// 以HTTP协议的1.1版本请求访问localhost:8080服务器上的/v3/api-docs资源</code></pre><ul><li><strong>响应报文</strong></li></ul><pre><code class="language-http">HTTP/1.1 200 OKDate:Sun,20 Dec 2020 06:33:44 GMTContent-Type:application/json...  //响应主体：服务端返回给客户端的内容//</code></pre></li><li><p>状态码</p><ul><li>1xx：信息状态码</li><li>2xx：成功状态码</li><li>3xx：重定向状态码</li><li>4xx：客户端错误状态码</li><li>5xx：服务端错误状态码</li></ul></li><li><p><code>HTTP</code>方法的安全性的幂等性</p><ul><li>安全性：不会对服务端造成影响，即无论怎么请求，服务端都不会因此而发生变化；简而言之就是<strong>只读</strong>。</li><li>幂等性：多次请求对服务器的影响与第一次一样；</li></ul><table><thead><tr><th>HTTP方法</th><th>接口说明</th><th>安全性</th><th>幂等性</th></tr></thead><tbody><tr><td>GET</td><td>获取资源(Read)</td><td>安全</td><td>幂等</td></tr><tr><td>POST</td><td>创建资源(Create)</td><td>不安全</td><td>非幂等</td></tr><tr><td>PUT</td><td>更新资源(Update)</td><td>不安全</td><td>幂等</td></tr><tr><td>DELETE</td><td>删除资源(Delete)</td><td>不安全</td><td>幂等</td></tr></tbody></table></li></ul><h2 id="HTTPS">HTTPS</h2><ul><li>HTTPS（HTTP安全）是一种用于Web服务器和客户端（如Web浏览器）通信的协议，它在HTTP协议的基础上<strong>添加了加密和身份验证功能，从而提供更安全的数据通信</strong>。HTTPS使用TLS（传输层安全）协议来加密数据传输，从而防止中间人攻击和窃听。</li></ul><h2 id="常用CMD命令">常用CMD命令</h2><ul><li><code>ipconfig</code>：查看本机IP；</li><li><code>ping</code>：通常用于<strong>测试网络连接是否正常</strong>，以及确定网络延迟和数据包丢失率等问题。它也可以用于诊断网络故障，并提供有关网络性能的有用信息。</li></ul><h2 id="RESTful">RESTful</h2><ul><li><p>REST（Representational State Transfer）:资源以某种表现形式在HTTP方法的作用下发生变化；</p></li><li><p><code>RESTful</code>实践</p><ul><li><p>获取数据</p><pre><code class="language-http">GET &quot;http://localhost:8080/rest/user/1&quot; </code></pre><p>定位id为1的用户（资源），用GET方法获取，查询资源；</p></li><li><p>新增数据</p><pre><code class="language-http">POST &quot;http://localhost:8080/rest/user&quot;Content-Type:application/json &#123;&quot;name&quot;:&quot;ming&quot;,&quot;age&quot;:3,&quot;email&quot;:&quot;ming@test.com&quot;&#125;</code></pre><p>POST方法的参数通常会被放在请求体中，以Content-Type中的格式（JSON）提交到服务端；</p></li><li><p>更新数据</p><pre><code class="language-http">PUT &quot;http://localhost:8080/rest/user&quot;Content-Type:application/json &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ming&quot;,&quot;age&quot;:21,&quot;email&quot;:&quot;ming@test.com&quot;&#125;</code></pre><p>与POST的区别在于请求参数还要指定一个唯一字段（如id）；</p></li><li><p>删除数据</p><pre><code class="language-http">DELETE &quot;http://localhost:8080/rest/user/1&quot; </code></pre></li></ul></li><li><p>RESTful风格由<code>URI</code>定位资源</p><ul><li><code>URI</code>：Uniform Resource Identifier</li><li><code>URL</code>：Uniform Resource Locator</li><li><code>URN</code>：Uniform Resource Name</li></ul><p>所有的<code>URL</code>和<code>URN</code>都可以称为<code>URI</code>；</p><p><code>URL</code>可以定位资源，而<code>URN</code>不行；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点评项目</title>
      <link href="/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>点评项目是前后端分离项目，前端部署在nginx服务器上，后端部署在tomcat上。</p><h2 id="用户登录">用户登录</h2><ul><li><p><strong>权限认证方式</strong></p><ul><li><p><code>HTTP</code>是无状态的；</p></li><li><p><code>Session</code>（会话）认证：服务器为了保存用户状态而创建的一个对象。key-value形式存储；</p></li><li><p><code>Token</code>（令牌）：由服务端生成的一串字符串，作为客户端进行请求的一个凭证；当用户第一次登陆后，服务器会生成一个<code>Token</code>并返回给客户端，之后客户端再进行需要权限的请求时只需要带上这个<code>Token</code>即可，无需再携带用户名和密码进行认证；通过某种算法策略生成唯一的<code>Token</code>；</p></li></ul></li><li><p>集群**<code>session</code>共享问题**：集群模式下多台<code>tomcat</code>服务器不共享<code>session</code>存储空间，当请求切换到不同<code>tomcat</code>服务时导致数据丢失的问题。</p><p>因为<code>Redis</code>满足<strong>数据共享，内存存储，k-v键值对结构</strong>，因此使用<code>Redis</code>替代<code>session</code>可以解决<code>session</code>集群共享问题；</p></li><li><p><strong>登陆验证流程</strong></p><ol><li>前端提交手机号和验证码；</li><li>校验手机号，如果不符合，返回错误信息；</li><li>从<code>redis</code>获取验证码并校验，如果不一致，则返回错误信息；</li><li>如果一致，根据手机号查询用户；</li><li>判断用户是否存在，若不存在，创建新用户并保存（注册）；</li><li>保存用户信息到 <code>redis</code>中；<ol><li>生成随机<code>token</code>，作为登录令牌；</li><li>将User对象转为<code>HashMap</code>存储；</li><li>存入<code>Redis</code>，并设置<code>key</code>有效期；</li><li>返回<code>token</code>；</li></ol></li></ol></li><li><p><strong>刷新<code>Token</code>有效期拦截器</strong>：因为<code>Token</code>设置的有效期是固定的，因此如果用户一直在登陆状态，则需要一直刷新<code>Token</code>的有效期；</p><ul><li>拦截所有请求</li><li>获取<code>Token</code>；</li><li>基于<code>Token</code>获取Redis中的用户信息；</li><li>保存用户信息到<code>ThreadLocal</code>；</li><li>刷新<code>Token</code>有效期；</li></ul></li><li><p><strong>登录拦截器</strong>：拦截需要用户登录的请求，查询<code>ThreadLocal</code>中是否存在用户，存在则放行；</p><p><img src="https://img-blog.csdnimg.cn/78ed142c48c3448a8fb240194f22fce8.png" alt="拦截器"></p></li></ul><h2 id="商户查询缓存">商户查询缓存</h2><h3 id="简介">简介</h3><p>缓存是数据交换得缓冲区（Cache），用于存储临时数据，一般读写性能较高；</p><ul><li><p>缓存的作用</p><ul><li>降低后端负载</li><li>提高读写速率，降低响应速率</li></ul></li><li><p>缓存的成本</p><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本（集群部署等）</li></ul></li><li><p>通常我们这样使用缓存：</p><ul><li>写请求只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul></li></ul><p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230712110056150.png" alt="image-20230712110056150"></p><p>​这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「<strong>热数据</strong>」，缓存利用率得以最大化。</p><h3 id="缓存更新策略">缓存更新策略</h3><ul><li><p>缓存更新策略</p><ul><li>内存淘汰：利用Redis的内存淘汰机制；</li><li>超时剔除：给缓存数据添加超时时间；</li><li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存；</li></ul></li><li><p><strong>删除缓存还是更新缓存？</strong></p><ul><li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多；</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（<strong>更优</strong>）</li></ul></li><li><p>如何保证缓存和数据库操作的原子性？</p><ul><li>单体系统，将缓存和数据库放在一个事务中；</li><li>分布式系统：利用TCC等分布式事务方案；</li></ul></li><li><p>这里存在<strong>数据一致性问题</strong>，当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。这两个操作并非是原子的，所以有先后顺序；</p><ul><li><p>先删除缓存，再更新数据库：</p><ul><li><p>初始化（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 删除缓存后（数据库：1 ，缓存：null）</p></li><li><p><em>线程2</em> 前来查询缓存未命中，查询数据库，并将查询到的数据写入缓存（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 再更新数据库（数据库：2 ，缓存：1）</p></li><li><p>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率较大</strong>，因为Redis的读写速度比数据库快很多，并发情况下很容易发生这种情况。</p></li></ul></li><li><p>先更新数据库，再删除缓存</p><ul><li>初始化，恰好缓存失效（数据库：1 ，缓存：null）</li><li><em>线程1</em> 查询缓存未命中并查询数据库（1）</li><li><em>线程2</em> 更新数据库（数据库：2 ，缓存：null）</li><li><em>线程2</em>  删除缓存（数据库：2 ，缓存：null）</li><li><em>线程1</em> 写入缓存（数据库：2 ，缓存：1）</li><li>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率很小</strong>（线程1之前缓存恰好失效；Redis写入速度很快，在其之前有线程插入并更新数据库的概率很小）</li></ul></li></ul></li><li><p>因此，缓存更新策略的最佳实践方案为：</p><ul><li>低一致性需求：使用Redis自带的内存淘汰机制；</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案；<ul><li>读操作：<ul><li>缓存命中则直接返回；</li><li>缓存未命中则直接查询数据库，并写入缓存，并设定超时时间；</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存；</li><li>要确保数据库与缓存操作的原子性；</li></ul></li></ul></li></ul></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul><li><p>缓存穿透是指客户端<strong>请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远都不会生效，这些请求都会到数据库。（可能会被无效请求恶意攻击）。</p></li><li><p>解决方案：</p><ul><li><p>缓存空对象：对于无效的请求，缓存一个null对象</p><ul><li><p>优点：实现简单，维护简单</p></li><li><p>缺点：</p><ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>请求与Redis缓存之间设置一布隆过滤器，由布隆过滤器判断请求数据是否存在，存在则放行，不存在则直接返回。</li><li>布隆过滤器并不是存储了所有数据，而是通过某种算法来判断请求数据是否存在。</li></ul></li></ul></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul><li>缓存雪崩是指 <strong>同一时段大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</li><li>解决方案：<ul><li>给不同的key添加随机失效时间；</li><li>利用Redis集群提高服务的可用性；</li><li>给缓存业务添加降级限流策略；</li><li>给业务添加多级缓存；</li></ul></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul><li><p>缓存击穿问题也被称为<strong>热点key</strong>问题，就是一个<strong>被高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求在瞬间给数据库带来巨大的冲击。</p></li><li><p>解决方案：</p><ul><li><p>互斥锁：查询缓存未命中时，先获取互斥锁，获取锁成功后查询数据库并重建缓存，写入缓存后再释放锁；这样，其他线程请求无法在缓存重建期间查询缓存。</p><p>线程需要等待，性能收到影响；可能有死锁风险。</p></li><li><p>逻辑过期：<strong>给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL</strong>。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。</p><ul><li>优点：<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点：<ul><li>不保证一致性(因为会返回过期数据)</li><li>有额外的内存消耗(同时缓存了逻辑过期时间的字段)</li><li>实现复杂</li></ul></li></ul></li></ul></li></ul><h2 id="优惠券秒杀">优惠券秒杀</h2><p>Redis的计数器，lua脚本Redis，分布式锁，消息队列</p><h3 id="分布式全局唯一ID">分布式全局唯一ID</h3><ul><li><p>**<em>UUID(通用唯一标识符)**表示一个128位长的唯一值。 它也被普遍称为</em>GUID(全球唯一标识符)。我们可以使用*UUID*类来生成随机文件名，会话或事务ID。 UUID的另一种流行用法是在数据库中生成主键值。<strong>有极小的概率会重复</strong>。</p></li><li><p><strong>雪花算法</strong></p><p>由64位<code>bit</code>字符组成（Long）<br>$$<br>0\quad \quad0000 … 0000\quad\quad\quad 000000 0000 \quad\quad 0000 0000 0000<br>$$<br>​                                                       <strong>符号位   时间戳：41 bit          机器ID：10 bit</strong>      <strong>12 bit 序列号</strong></p><ul><li><p>组成：</p><ul><li>符号位：1 bit，生成ID一般均为正数，因此为0；</li><li>时间戳：41 bit，单位为ms，可以使用约69年；</li><li>机器ID：10 bit，可以支持1024个分布式机器；</li><li>序列号：12 bit，表示每ms可以生成$2^{12}=1024$个不同ID；</li></ul></li><li><p>特点</p><ul><li>按时间递增</li><li>唯一性</li><li>生成效率高</li></ul></li></ul><pre><code class="language-java">/** * 生成全局唯一ID（** 雪花算法 **） */@Componentpublic class UIDWorker &#123;    // 开始时间戳    private static final long BEGIN_TIMESTAMP = 1692213900;    @Resource    private StringRedisTemplate stringRedisTemplate;    public Long nextId(String prefix)&#123;        // 生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 机器ID        long machineId = 1;        // 生成序列号(通过Redis自增生成序列)        String nowDateTime = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        long increment = stringRedisTemplate.opsForValue()                         .increment(&quot;icr&quot; + prefix + &quot;:&quot; + nowDateTime);        // 拼接并返回        long id = timestamp &lt;&lt; 22 | machineId &lt;&lt; 12 | increment;        return id;    &#125;&#125;</code></pre></li><li><p>雪花算法的**时钟回拨 **问题</p><ul><li>由于雪花算法对于时钟特别敏感，因此如果时钟出现回拨现象，有可能导致获取的ID重复。</li><li>正常来说只要不是不是有人手贱或者出于泄愤的目的进行干扰，系统的时间漂移是一个在毫秒级别的极短的时间。因此可以在获取 ID 的时候，记录一下当前的时间戳。然后在下一次过来获取的时候，<strong>对比一下当前时间戳和上次记录的时间戳，如果发现当前时间戳小于上次记录的时间戳，所以出现了时钟回拨现象，对外抛出异常，本次 ID 获取失败</strong>。理论上当前时间戳会很快的追赶上上次记录的时间戳。</li></ul></li></ul><h3 id="超卖问题">超卖问题</h3><ul><li><p>高并发场景下，做个线程交叉执行可能会出现超卖问题；</p><ul><li><p><code>初始</code>：库存：1；</p></li><li><p><code>线程1</code>：查询库存为1；</p></li><li><p><code>线程2</code>：查询库存为1；</p></li><li><p><code>线程1</code>：扣减库存，下单成功；</p></li><li><p><code>线程2</code>：扣减库存，下单成功；</p></li><li><p><code>库存</code>：<strong>-1</strong>（出现超买问题）；</p></li></ul></li><li><p>解决方案：加锁</p></li><li><p><strong>悲观锁</strong></p><ul><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li><li>例如<code>Synchronized</code>，<code>Lock</code>都属于悲观锁；</li><li>特点：简单直接，性能差；</li></ul></li><li><p><strong>乐观锁</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，只是<strong>在更新数据时判断是否有其他线程对数据进行了修改</strong>。<ul><li>如果没有，则认为是安全的，更新数据；</li><li>如果游，则重试或者抛出异常；</li></ul></li><li>特点：性能好，但容易出现成功率过低的问题；</li></ul></li><li><p>乐观锁的实现方式</p><ul><li><p><strong>版本号法</strong>：为资源添加一个version版本号，当修改资源后version就加一，修改资源前判断版本号是否被修改；</p><ul><li><p><code>初始</code>：库存：1；（ version = 1 ）</p></li><li><p><code>线程1</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程2</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程1</code>：扣减库存，下单成功；（ version = 2 ）</p></li><li><p><code>线程2</code>：此时发现version与查询时的不同，说明资源被其他线程修改，下单失败；</p></li></ul></li><li><p><strong>CAS</strong>（<code>Compare And Swap</code>）：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。<br>（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。<br>（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p><pre><code class="language-java">// 扣减库存boolean isSuccess = seckillVoucherService.update()        .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1        .eq(&quot;voucher_id&quot;, voucherId) // where ...        .eq(&quot;stock&quot;,voucher.getStock())        .update();</code></pre><p>该方法能够解决超卖问题，但是高并发场景下成功率过低，影响业务；</p></li></ul></li></ul><h3 id="一人一单">一人一单</h3><ul><li><p>业务场景下，同一个用户对同一优惠券只能下一次单。（抵制黄牛！）</p></li><li><p>加<code>sycronized</code>锁实现</p><pre><code class="language-java">@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    // 获取用户Id    Long userId = UserHolder.getUser().getId();    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串    synchronized (userId.toString().intern())&#123;        // 一人一单        Long count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        if(count&gt;0)&#123;            return Result.fail(&quot;用户已经抢购过该优惠券！&quot;);        &#125;    &#125;&#125;</code></pre></li><li><p>以上代码可能会导致线程安全问题</p><pre><code class="language-java">@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    ...    synchronized (userId.toString().intern())&#123;        // 一人一单        ...    &#125;    // 锁释放，此时其他线程可以进来    // 而事务尚未提交，线程不安全！&#125;</code></pre></li><li><p>优化</p><pre><code class="language-java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串    synchronized (userId.toString().intern()) &#123;        return this.createVoucherOrder(voucherId); // **事务失效** 问题        // 事务已提交    &#125; // 释放锁&#125;@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    ...&#125;</code></pre></li><li><p>以上有可能导致<strong>事务失效</strong>问题，解决方案如下：</p><pre><code class="language-java">Long userId = UserHolder.getUser().getId();synchronized (userId.toString().intern()) &#123;    // 拿到当前对象的代理对象    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    return proxy.createVoucherOrder(voucherId);&#125;</code></pre></li></ul><h2 id="分布式锁">分布式锁</h2><h3 id="简介-v2">简介</h3><ul><li><p><code>sycronized</code>只能在一个<code>JVM</code>内部实现不同线程之间的互斥，集群下可能出现线程安全问题</p></li><li><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见的互斥锁。</p></li><li><p>特点：</p><ul><li>多进程可见</li><li>互斥</li><li>高性能</li><li>高可用</li><li>安全性</li></ul></li><li><p>实现方式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身的互斥锁机制</td><td style="text-align:center">利用setnx命令</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超时时间，到期释放</td></tr></tbody></table></li></ul><h3 id="基于Redis实现分布式锁">基于Redis实现分布式锁</h3><ul><li><p>获取锁</p><pre><code class="language-sql"># 利用setnx的互斥特性SETNX lock thread1# 添加锁过期时间，避免服务宕机引起的死锁EXPIRE lock 30</code></pre><p>以上两条命令不具备原子性，可以使用以下命令：</p><pre><code class="language-sql">SET lock thread NX EX 30</code></pre></li><li><p>释放锁</p><p>手动释放或超时释放</p><pre><code class="language-sql"># 删除即可DEL lock</code></pre></li><li><p>实现Redis分布式锁</p><pre><code class="language-java">public interface ILock &#123;    /**     * 尝试获取锁     * @param timeoutSec 锁持有的超时时间，过期后自动释放     * @return true代表获取锁成功; false代表获取锁失败     */    boolean tryLock(long timeoutSec);    /**     * 释放锁     */    void unlock();&#125;</code></pre><pre><code class="language-java">public class SimpleRedisLock implements ILock &#123;    private StringRedisTemplate stringRedisTemplate;    private String lockName;    private static final String ID_PREFIX = UUID.randomUUID(true) + &quot;-&quot;;    private static final String LOCK_PREFIX = &quot;lock_&quot;;    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String lockName) &#123;        this.lockName = lockName;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean tryLock(long timeoutSec) &#123;         /*          获取锁时存入线程标识          解决分布式锁 **误删** 问题         */                // 获取线程标示        String threadId = ID_PREFIX + Thread.currentThread().getId();        // 获取锁        Boolean isSuccess = stringRedisTemplate.opsForValue()                .setIfAbsent(LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.MINUTES);//        return isSuccess;  // 可能会在自动拆箱过程中出现空指针        return Boolean.TRUE.equals(isSuccess);    &#125;    @Override    public void unlock() &#123;        /*         释放锁时先获取锁中的线程标识，判断是否与当前标识相同         如果一致则释放锁，不一致则不释放锁；         */        String threadId = ID_PREFIX + Thread.currentThread().getId();        String id = stringRedisTemplate.opsForValue().get(LOCK_PREFIX + lockName);        if (threadId.equals(id)) &#123;            stringRedisTemplate.delete(LOCK_PREFIX + lockName);        &#125;    &#125;&#125;</code></pre></li><li><p>解决分布式锁 <strong>误删</strong> 问题</p><ul><li><p><code>线程1</code>：获取锁成功（<code>lock1</code>），执行任务；（任务时间较久或宕机）</p></li><li><p>超过超时时间，锁自动释放；</p></li><li><p><code>线程2</code>：获取锁成功（<code>lock1</code>），执行任务；</p></li><li><p><code>线程1</code>：任务执行成功，释放锁；</p></li><li><p>此时<code>线程2</code>还未执行完毕，<code>线程 1 </code>误删了<code>线程 2 </code>的锁；</p></li></ul><p>解决方案：</p></li><li><p>获取锁时存入线程标识（可以使用<code>UUID</code>）；</p><ul><li>释放锁时先获取锁中的线程标识，判断是否与当前标识相同，如果一致则释放锁，不一致则不释放锁；</li></ul></li><li><p>分布式锁的<strong>原子性</strong></p><ul><li><p>由于上述判断线程标识与释放锁的操作不具备原子性，因此可能会有线程安全问题；</p></li><li><p>Redis提供了lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性；</p><pre><code class="language-lua">EVAL script key [key ...]  # 执行脚本</code></pre></li></ul></li><li><p>实现思路总结</p><ul><li>利用<code>SETNX</code>命令获取锁，设置过期时间，并存入线程标识；</li><li>释放锁时先判断标识是否一致，一致则删除锁；</li></ul></li><li><p>基于<code>SETNX</code>实现分布式锁的问题：</p><ul><li>不可重入：同一个线程无法多次获取同一把锁；</li><li>不可重试：获取锁失败时返回false，没有重试机制；</li><li>超时释放：超时释放虽然可以避免死锁；设置超时时间过短，若业务执行时间过长，也会导致锁释放，存在安全隐患；设置超时时间过长，导致业务停滞；</li><li>主从一致性</li></ul></li></ul><h3 id="Redisson">Redisson</h3><ul><li><p><strong>Redisson使用</strong></p><ul><li><p>引入依赖</p><pre><code class="language-xml">        &lt;dependency&gt;            &lt;groupId&gt;org.redisson&lt;/groupId&gt;            &lt;artifactId&gt;redisson&lt;/artifactId&gt;            &lt;version&gt;3.13.6&lt;/version&gt;        &lt;/dependency&gt;</code></pre></li><li><p>配置文件</p><pre><code class="language-java">// Reddision 配置@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient() &#123;        // 配置        Config config = new Config();        // 单节点        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;lm12138&quot;);        // 创建RedissonClient对象        return Redisson.create(config);    &#125;&#125;</code></pre></li><li><p>使用 <code>Redisson</code></p><pre><code class="language-java">@Resourceprivate RedissonClient redissonClient;@Testprivate void testRedisson() &#123;    // 获取锁，指定锁名称    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);    boolean isLock = lock.tryLock();    // 判断是否获取锁成功    if(!isLock)&#123;        try &#123;           // 业务逻辑        &#125; finally &#123;          // 释放锁          lock.unlock();        &#125;    &#125;&#125;</code></pre></li></ul></li></ul><h3 id="秒杀优化">秒杀优化</h3><ul><li><p>秒杀流程回顾：</p><ul><li>查询优惠券（数据库）</li><li>判断秒杀库存</li><li>查询订单（数据库）</li><li>校验一人一单</li><li>减库存（数据库）</li><li>创建订单（数据库）</li></ul></li><li><p><strong>异步秒杀</strong>：</p><ul><li>新增秒杀优惠券的同时，将秒杀库存保存到Redis中；</li><li>基于lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul></li></ul><h2 id="点赞与评论">点赞与评论</h2><ul><li>基于SortedSet的点赞排行榜<ul><li>从Redis中查询，判断用户是否赞；</li><li>若未点赞，数据库点赞数 +1，并且将用户和点赞时间（score）存入Redis；</li><li>若已经点赞，数据库点赞数 -1，并且将用户移除Redis；</li><li>查询 top5 的点赞用户 <code>zrange key 0 4</code></li></ul></li></ul><h2 id="好友关注">好友关注</h2><p>基于set集合的关注，取关，共同关注和消息推送等功能</p><h2 id="附近的商户">附近的商户</h2><p>redis的GeoHash的应用</p><h2 id="UV统计">UV统计</h2><p>Redis的HyperLog的统计功能</p><h2 id="用户签到">用户签到</h2><p>Redis的BitMap数据统计功能</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置ssh</title>
      <link href="/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/"/>
      <url>/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/</url>
      
        <content type="html"><![CDATA[<ul><li><p>安装ssh服务器</p><pre><code class="language-bash">sudo apt install openssh-server</code></pre></li><li><p>安装ssh客户端</p><pre><code class="language-bash">sudo apt install openssh-client</code></pre></li><li><p>配置<code>ssh</code>客户端，去掉<code>PasswordAuthentication yes</code>前面的#号，保存退出；配置ssh服务器，把<code>PermitRootLogin prohibit-password</code>改成<code>PermitRootLogin yes</code>，保存退出。</p><pre><code class="language-bash">sudo vi /etc/ssh/ssh_config</code></pre></li><li><p>重启ssh服务</p><pre><code class="language-bash">sudo /etc/init.d/ssh restart</code></pre></li><li><p>启动ssh服务</p><pre><code class="language-bash">sudo /etc/init.d/ssh start</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu上安装anaconda</title>
      <link href="/2023/07/01/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85anaconda/"/>
      <url>/2023/07/01/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85anaconda/</url>
      
        <content type="html"><![CDATA[<ul><li><p>官网下载 <a href="https://www.anaconda.com/%E5%AE%89%E8%A3%85%E5%8C%85">https://www.anaconda.com/安装包</a></p></li><li><p><a href="http://xn--jn2aw7m.sh">运行.sh</a> 文件</p><pre><code class="language-shell">bash Anaconda3-2021.11-Linux-x86_64.sh/home/lm/anaconda3 # 安装路径</code></pre></li><li><p>配置环境</p><pre><code class="language-shell">sudo vim ~/.bashrcexport PATH=/home/lm/anaconda3/bin:$PATHsource ~/anaconda3/bin/activate #修改终端的默认 python 为 anaconda</code></pre></li><li><p>保存环境配置</p><pre><code class="language-shell">source ~/.bashrc</code></pre></li><li><p>查看版本</p><pre><code class="language-shell">conda --version</code></pre></li><li><p>虚拟环境</p><pre><code class="language-shell">conda create -n env_name python=3.8</code></pre></li><li><p>激活环境</p><pre><code>conda activate env_name</code></pre></li><li><p>查看环境</p><pre><code class="language-shell">conda info --envs或conda info -e或conda env list</code></pre></li><li><p>复制环境</p><pre><code class="language-shell">conda create --name new_env_name --clone copied_env_name</code></pre></li><li><p>删除环境</p><pre><code class="language-shell">conda remove --name env_name --all</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写IOC容器</title>
      <link href="/2023/07/01/%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/07/01/%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>实现：<strong>Java 反射 + 注解</strong></p><ul><li><p>创建两个注解：</p><ul><li><p><code>@Bean </code>：创建对象</p><pre><code class="language-java">@Target(ElementType.TYPE) // 作用在类对象上@Retention(RetentionPolicy.RUNTIME) // 运行时生效public @interface Bean &#123;&#125;</code></pre></li><li><p><code>@Di</code>：属性注入</p><pre><code class="language-java">@Target(ElementType.FIELD) // 使用在属性上@Retention(RetentionPolicy.RUNTIME) // 运行时生效public @interface Di &#123;&#125;</code></pre></li></ul></li><li><p>创建Bean容器接口 ApplicationContext，定义方法，返回对象；</p><pre><code class="language-java">public interface ApplicationContext &#123;    // 返回Bean对象    Object getBean(Class clazz) throws NoSuchMethodException;&#125;</code></pre></li><li><p>实现Bean容器接口</p><ul><li>返回对象</li><li>创建有参构造器，传递包路径，设置包扫描规则</li><li>根据包规则加载Bean（）</li><li>属性注入</li></ul><pre><code class="language-java">public class AnnotationApplicationContext implements ApplicationContext &#123;    // 创建map集合，存放Bean对象    private  Map&lt;Class,Object&gt; beanFactory = new HashMap&lt;&gt;();    private  String rootPath; // 前路径        // fa    @Override    public Object getBean(Class clazz) throws NoSuchMethodException &#123;        return beanFactory.get(clazz);    &#125;    // 创建有参构造器，传递包路径，设置包扫描规则    // 当前包及子包中，如果哪个类有@Bean注解，则通过反射将其实例化    public  AnnotationApplicationContext(String basePackage)&#123;        try &#123;            // 1. 将.替换为\            String packagePath = basePackage.replaceAll(&quot;\\.&quot;,&quot;\\\\&quot;);            // 2. 获取包的绝对路径            Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader()                                    .getResources(packagePath);            while(urls.hasMoreElements())&#123;                URL url = urls.nextElement();                String filePath = URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8);                // 截取前路径                rootPath = filePath.substring(0, filePath.length() - packagePath.length());                // 包扫描                loadBean(new File(filePath));            &#125;        &#125; catch (Exception e) &#123;            throw new RuntimeException(e);        &#125;        // 属性注入        loadDi();    &#125;</code></pre></li><li><p>包扫描加载<code>Bean</code>实现</p><pre><code class="language-java">// 包扫描过程，实例化public void loadBean(File file) throws Exception &#123;    // 判断当前内容是否是一个文件夹    if(file.isDirectory()) &#123;        // 获取文件夹中的所有内容        File[] subFiles = file.listFiles();        // 判断文件夹是否为空        if(subFiles==null||subFiles.length==0)&#123;            return;        &#125;        // 遍历文件夹所有内容        for(File subfile:subFiles)&#123;            // 递归遍历文件夹及子文件夹            if(subfile.isDirectory())&#123;                // 如果是文件夹，递归遍历                loadBean(subfile);            &#125;else&#123;                // 得到包路径+类名                String pathWithClass = subfile.getAbsolutePath().substring(rootPath.length()-1);                // 判断当前文件类型是否为.class                if(pathWithClass.endsWith(&quot;.class&quot;))&#123;                    // 把\换成. 并去掉.class后缀                    String allName = pathWithClass.replaceAll(&quot;\\\\&quot;,&quot;.&quot;).replace(&quot;.class&quot;,&quot;&quot;);                    // 对有注解 @Bean的类进行实例化                    Class&lt;?&gt; clazz = Class.forName(allName);                    // 判断是否为接口                    if(!clazz.isInterface())&#123;                        // 判断有无注解                        Bean annotation = clazz.getAnnotation(Bean.class);                        if(annotation != null)&#123;                            // 实例化对象                            Object instance = clazz.getConstructor().newInstance();                            // 实例化后的对象放入到map集合中                            // 如果有接口，接口作为key                            if(clazz.getInterfaces().length&gt;0)&#123;                                beanFactory.put(clazz.getInterfaces()[0],instance);                            &#125;else&#123;                                beanFactory.put(clazz,instance);                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p>属性注入实现</p><pre><code class="language-java">public void loadDi()&#123;    // 遍历 map 集合    for(Map.Entry&lt;Class,Object&gt; entry:beanFactory.entrySet())&#123;        Object obj = entry.getValue();        Class&lt;?&gt; clazz = obj.getClass();        // 获取每个对象的属性        Field[] fields = clazz.getDeclaredFields();        // 遍历得到对象的属性数组，得到每个属性        for(Field field:fields)&#123;            // 判断属性上是否有 @Di 注解，把对象进行注入            Di annotation = field.getAnnotation(Di.class);            if(annotation!=null)&#123;                field.setAccessible(true);                try &#123;                    field.set(obj,beanFactory.get(field.getType()));                &#125; catch (IllegalAccessException e) &#123;                    throw new RuntimeException(e);                &#125;            &#125;        &#125;    &#125;&#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lucy in the Sky with Diamonds</title>
      <link href="/2023/06/30/Lucy-in-the-Sky-with-Diamonds/"/>
      <url>/2023/06/30/Lucy-in-the-Sky-with-Diamonds/</url>
      
        <content type="html"><![CDATA[<p>1967年，甲壳虫乐队发行了一首单曲——《露西在缀满钻石的天空中》(Lucy in the Sky with Diamonds) ，被称作是他们最伟大的作品之一。这首歌曲最初的灵感来自于约翰·列侬 (John Lennon) 的儿子小朱利安 (Julian) 所创作的一幅肖像画，画上描绘的是一位女孩在缀满钻石的天空中。</br><br>1974年，在东非大裂谷附近的阿法尔地区科考队发现了一具完整度约40%的古人类化石，考古队员们通过初步观察，发现化石的骨骼属于女性。而在她刚刚被发现的当天晚上，大家为了庆祝这个伟大的发现，在营地上跳起舞来。这时录音机里正循环播放着披头士乐队的歌曲《露西在缀满钻石的天空中》 （Lucy in the Sky with Diamonds），故将其命名为“<a href="https://zh.wikipedia.org/wiki/%E9%9C%B2%E8%A5%BF_(%E5%8D%97%E6%96%B9%E5%8F%A4%E7%8C%BF)">露西</a>（Lucy）”。</br><br>2004年，哈佛史密森天体物理中心 (Harvard-Smithsonian Centre) 的天文学家们作出了一个惊人的发现，在我们已知的宇宙中存在着一枚巨大的“天然钻石”，这似乎与甲壳虫乐队那首预言般的标志性歌曲有着某种联系。这颗钻石星球是一颗白矮星，位于半人马座，编号为V886或BPM 37093，直径约为4000公里，可能是有史以来被观测到的最大的天然钻石。受甲壳虫乐队的启发，发现她的科学家将她命名为露西 (Lucy)，这真的是一颗名副其实的在天空中镶满钻石的星球。这颗令人震惊的钻石星球重达10的34次方克拉，让地球上最大的天然钻石也相形见绌。它散发出如此璀璨的光芒，以至于我们在距离近50光年的半人马座上都能看到它。科学家们一直在研究这个星球所发出的低沉的嗡嗡声，终于在2004年证实了它是一颗白矮星——一颗巨大的垂死恒星，她的表面已完全结晶化，诞生了天然钻石。</p>]]></content>
      
      
      <categories>
          
          <category> 没用的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canon的故事</title>
      <link href="/2023/06/30/Canon%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2023/06/30/Canon%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>卡农Canon——复调音乐的一种,原意为“规律”。一个声部的曲调自始至终追逐着另一声部,直到最后的一个小结,最后的一个和弦,它们会融合在一起，永不分离。 <br /><br>卡农的作者帕卡贝尔（Pachelbel），德国人。在他十几岁的时候，战乱使他沦为孤儿。流浪到英国的他被一个钢琴师收养，此后他天天听琴师弹琴，耳濡目染也学会了钢琴。在他旁边的镇上有一个美丽的女孩叫Barbara，自从她在教堂听了Pachelbel弹的曲子，就爱上了他。害羞的Barbara不敢向Pachelbel表白，于是就找了个理由去Pachelbel那学钢琴。她对Pachelbel说自己热爱音乐，希望可以拜师学艺。之后的半年里，Barbara 为了证明自己的决心，努力练习钢琴，最终在一次比赛中获奖。而当她拿着奖杯想去和Pachelbel告白时，却得知Pachelbel被征去打仗。与此同时，同村一位心仪Barbara许久的男子为了让她对Pachelbel死心，令人从前线运来一具碎尸体并称这是Pachelbel。Pachelbel没有任何亲戚，所以Barbara无法求证，认为他已经战死。悲痛欲绝的她，最终在Pachelbel教她弹琴的教堂里割腕自杀。 <br /><br>而远在战场的Pachebel对此一无所知，离开小镇之后他才明白自己内心对Barbara的情愫。在战乱中，九死一生的他每次想起Barbara，都会有活下去的力量。他为Barbara写下了一首曲子，想等自己回去后向她求婚。这首曲子就是我们所熟悉的《卡农》。三年后，当Pachelbel回到小镇上，才得知Barbara早已离开人世，才明白原来心爱的女孩也一直爱着自己。Pachelbel来到当初两人相遇的那个教堂，流着泪弹出了那首永远没机会被爱人听见的《卡农》。 <br /><br>而直到今天，人们已很难去定义《卡农》到底表达的是何种情感。不同的人，在不同的时间听到这首曲子，或许都会有自己的理解。那些不可追的往日、未曾开口的秘密、曾一起共度的时光、对未来的期许……都融在了音符里。如同曲中一个声部追随另一个声部到最后一个和弦，我追随你，直到生命尽头，永不分离。</p>]]></content>
      
      
      <categories>
          
          <category> 没用的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="/2023/06/28/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Bean">Bean</h2><ul><li><p>spring中的 Bean 就是 java 对象</p></li><li><p><strong>如何使用反射创建对象？</strong></p><ul><li>加载bean.xml配置文件</li><li>对xml文件进行解析</li><li>获取xml文件bean标签属性值：id值属性值和class属性值</li><li>使用反射根据类全路径创建对象</li><li>将创建的对象放到一个Map中（<code>key</code>：唯一标识，<code>value</code>：类的定义）</li></ul><pre><code class="language-java">public class TestUser &#123;    @Test    public void testUserObject1()&#123;        // 加载spring配置文件        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);        // 获取创建的对象        User user = (User)context.getBean(&quot;user&quot;);        System.out.println(user);        // 调用方法进行测试        user.hello();    &#125;    // 通过反射创建对象    @Test    public void testUserObject2() throws Exception&#123;        // 获取类class对象        Class clazz = Class.forName(&quot;com.lm.spring6.User&quot;);                // 调用方法创建对象        User user = (User)clazz.getDeclaredConstructor().newInstance();    &#125;&#125;</code></pre></li></ul><h2 id="Ioc容器">Ioc容器</h2><ul><li><p><strong>IOC容器</strong></p><ul><li><p>spring通过<strong>IOC容器</strong>来管理：<strong>所有对象的实例化和初始化，控制对象与对象之间的依赖关系。</strong></p></li><li><p>容器使用map集合，存放Bean对象。</p><p><img src="/images/IoC%E5%AE%B9%E5%99%A8.png" alt="IoC容器"></p><center>    IOC容器在spring中的实现</center></li></ul></li><li><p><strong>依赖注入</strong></p><ul><li>指spring创建对象过程中，将对象依赖属性通过配置注入</li><li>实现方式有两种：<ul><li>set注入</li><li>构造注入</li></ul></li></ul></li><li><p><strong>IOC就是一种控制反转的思想，而依赖注入是对IOC的实现</strong></p></li></ul><h2 id="IOC基于xml管理Bean">IOC基于xml管理Bean</h2><ul><li><p>获取<code>Bean</code>的方式</p><pre><code class="language-xml">&lt;!--完成User对象创建    Bean标签        id属性：唯一标识        class属性：要创建对象所在类的全路径（包名+类名）    --&gt;    &lt;bean id=&quot;user&quot; class=&quot;com.lm.spring6.User&quot;&gt;&lt;/bean&gt;</code></pre><pre><code class="language-java">// 1.根据id获取BeanApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);//获取ioc容器User user1 = (User)context.getBean(&quot;user&quot;);//获取BeanSystem.out.println(&quot;根据id获取Bean:&quot;+user1);//2.根据类型获取BeanUser user2 = context.getBean(User.class);System.out.println(&quot;根据类型获取Bean:&quot;+user2);//3.根据id和类型获取BeanUser user3 = context.getBean(&quot;user&quot;, User.class);System.out.println(&quot;根据id和类型获取Bean:&quot;+user3);</code></pre><ul><li>如果一个组件类实现了接口，可以通过接口类型获取Bean；但是如果一个接口有多个实现类，则无法获取Bean;</li></ul></li><li><p>依赖注入-基于setter方法</p><ul><li>创建类，定义属性，生成属性set方法</li></ul><pre><code class="language-java">public class Book &#123;    private String name;    private String author;&#125;// set,get,constructor方法忽略</code></pre><ul><li>在spring配置文件中配置</li></ul><pre><code class="language-xml">    &lt;!--set 方法注入--&gt;    &lt;bean id=&quot;book&quot; class=&quot;com.lm.spring6.di.Book&quot;&gt;        &lt;property name=&quot;name&quot; value=&quot;book1&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;author&quot; value=&quot;ming&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><ul><li>测试</li></ul><pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);Book book = context.getBean(&quot;book&quot;, Book.class);</code></pre></li><li><p>依赖注入-基于构造器</p><ul><li>配置文件</li></ul><pre><code class="language-xml">    &lt;!--constructor 构造方法注入--&gt;    &lt;bean id=&quot;bookCon&quot; class=&quot;com.lm.spring6.di.Book&quot;&gt;        &lt;constructor-arg name=&quot;name&quot; value=&quot;book2&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg name=&quot;author&quot; value=&quot;ming&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><ul><li>测试</li></ul><pre><code class="language-java">ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di.xml&quot;);Book book = context.getBean(&quot;bookCon&quot;, Book.class);</code></pre></li><li><p>特殊类型注入</p><ul><li>创建类，定义属性</li></ul><pre><code class="language-java">public class Student &#123;    private String name;    private School school;        private String[] course;    public void study()&#123;        school.info(); // 调用 School对象的方法    &#125;&#125;public class School &#123;    private String name;    public void info()&#123;        System.out.println(&quot;name:&quot; + name);    &#125;&#125;</code></pre><ul><li>配置文件</li></ul><pre><code class="language-xml">    &lt;!--    方法一：引入外部bean    1. 创建对象：student 和 school    2. 在student的标签中，使用property引入school的bean    --&gt;    &lt;bean id=&quot;student&quot; class=&quot;com.lm.spring6.ditest.Student&quot;&gt;        &lt;!--普通类型注入--&gt;        &lt;property name=&quot;name&quot; value=&quot;ming&quot;&gt;&lt;/property&gt;        &lt;!--对象类型注入--&gt;        &lt;property name=&quot;school&quot; ref=&quot;school&quot;&gt;&lt;/property&gt;        &lt;!--数组类型注入--&gt;        &lt;property name=&quot;course&quot;&gt;            &lt;array&gt;                &lt;value&gt;数学&lt;/value&gt;                &lt;value&gt;英语&lt;/value&gt;            &lt;/array&gt;        &lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;school&quot; class=&quot;com.lm.spring6.ditest.School&quot;&gt;        &lt;!--普通类型注入--&gt;        &lt;property name=&quot;name&quot; value=&quot;sjtu&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre><ul><li>测试</li></ul><pre><code class="language-java">@Testpublic static void main(String[] args) &#123;     ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-di-test.xml&quot;);     Student student = context.getBean(&quot;student&quot;,Student.class);     student.study();&#125;</code></pre></li><li><p>引入外部属性文件（<code>jdbc.properties</code>）</p><pre><code class="language-xml">bean-jdbc.xml&lt;!--引入外部属性标签--&gt;    &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;&gt;&lt;/context:property-placeholder&gt;    &lt;!--完成数据库注入--&gt;    &lt;bean id=&quot;druidDataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;    &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;&gt;&lt;/property&gt;    &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;</code></pre></li><li><p>Bean 的作用域</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">创建对象的时机</th></tr></thead><tbody><tr><td style="text-align:center">singleton（默认）</td><td style="text-align:center">在IOC容器中这个Bean的对象始终为单实例</td><td style="text-align:center">IOC容器初始化时</td></tr><tr><td style="text-align:center">prototype</td><td style="text-align:center">这个Bean在容器中有多个实例</td><td style="text-align:center">获取Bean时</td></tr></tbody></table><pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.lm.spring6.User&quot; scope=&quot;singleton&quot;&gt;&lt;/bean&gt;</code></pre></li><li><p>Bean 的生命周期</p><ul><li>Bean 对象从创建到销毁的过程<ol><li>Bean对象的创建（调用无参数构造）</li><li>给Bean对象设置相关的属性（属性注入）</li><li>Bean后置处理器（初始化之前）</li><li>对Bean对象初始化（调用指定的初始化方法）</li><li>Bean后置处理器（初始化之后）</li><li>Bean对象创建完成，可以使用</li><li>Bean对象的销毁（配置指定销毁方法）</li></ol></li><li>对象属性及方法定义</li></ul><pre><code class="language-java">public class User &#123;    private  String name;    public User()&#123;        System.out.println(&quot;1.Bean对象创建，调用无参数构造……&quot;);    &#125;    // 初始化方法    public void initMethod()&#123;        System.out.println(&quot;4.调用指定初始化方法&quot;);    &#125;    // 销毁方法    public void destroyMethod()&#123;        System.out.println(&quot;7.Bean对象的销毁&quot;);    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        System.out.println(&quot;2.设置属性值……&quot;);        this.name = name;    &#125;&#125;</code></pre><ul><li>后置处理器</li></ul><pre><code class="language-java">public class MyBeanPost implements BeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;3.Bean后置处理器（初始化之前）&quot;);        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;5.Bean后置处理器（初始化之后）&quot;);        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);    &#125;&#125;</code></pre><ul><li>配置文件(<code>bean-life.xml</code>)</li></ul><pre><code class="language-xml">&lt;bean id=&quot;user&quot; class=&quot;com.lm.spring6.beanlife.User&quot; scope=&quot;singleton&quot;      init-method=&quot;initMethod&quot; destroy-method=&quot;destroyMethod&quot;&gt;      &lt;property name=&quot;name&quot; value=&quot;ming&quot;&gt;&lt;/property&gt;&lt;/bean&gt;    &lt;!--Bean的后置处理器需要放入IOC容器才能生效--&gt;&lt;bean id=&quot;myBeanPost&quot; class=&quot;com.lm.spring6.beanlife.MyBeanPost&quot;&gt;&lt;/bean&gt;</code></pre><ul><li>测试</li></ul><pre><code class="language-java">public class TestUser &#123;    public static void main(String[] args) &#123;        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean-life.xml&quot;);        context.getBean(&quot;user&quot;,User.class);        System.out.println(&quot;6.Bean对象创建完成，可以使用&quot;);        // 注意：使用ClassPathXmlApplicationContext接口，才有close()方法        context.close();// 销毁对象    &#125;&#125;</code></pre></li><li><p>基于xml实现自动装配</p><pre><code class="language-xml">&lt;bean id=&quot;userController&quot; class=&quot;com.lm.spring6.auto.controller.UserController&quot;       autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userService&quot; class=&quot;com.lm.spring6.auto.service.UserServiceImpl&quot; autowire=&quot;byType&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;userDao&quot; class=&quot;com.lm.spring6.auto.dao.UserDaoImpl&quot;&gt;&lt;/bean&gt;</code></pre><p>自动装配方式有两种：</p><ul><li><code>byType</code>：根据类型匹配Ioc容器中的Bean，为属性自动复赋值；</li><li><code>byName</code>：将自动装配的属性名，作为Bean的id去匹配对应的Bean进行属性赋值；</li></ul></li></ul><h2 id="基于注解管理Bean">基于注解管理Bean</h2><ul><li><p>spring 通过注解实现自动装配的步骤如下：</p><ul><li>引入依赖</li><li>开启组件扫描</li><li>使用注解定义Bean</li><li>依赖注入</li></ul><pre><code class="language-xml">&lt;!--开启组件扫描扫描路径下的所有包，如果一个类加了注解，则将其装配到容器--&gt;    &lt;context:component-scan base-package=&quot;com.lm&quot;&gt;&lt;/context:component-scan&gt;</code></pre></li><li><p>可以定义Bean的注解</p><ul><li><code>@Component</code>：泛化的概念，可以用于任何层；</li><li><code>@Respository</code>：用于数据访问层；</li><li><code>@Service</code>：用于业务层；</li><li><code>@Controller</code>：用于控制层；</li></ul></li><li><p><code>@Autowired</code>注入</p><ul><li>默认<code>byType</code>方式装配</li><li>注入方法</li></ul><pre><code class="language-java">@Controllerpublic class UserController &#123;    // 方法一：属性注入    @Autowired    private UserService userService;    // 方法2：set方法注入    @Autowired    public void setUserService(UserService userService) &#123;        this.userService = userService;    &#125;    // 方法3：构造方法注入    @Autowired    public UserController(UserService userService)&#123;        this.userService = userService;    &#125;        // 方法4：形参上注入    private UserService userService;    public UserController(@Autowired UserService userService)&#123;        this.userService = userService;    &#125;    public void addUser()&#123;        System.out.println(&quot;Controller方法执行……&quot;);        userService.addUserService();    &#125;&#125;</code></pre></li><li><p><code>@Resource</code>注入</p><ul><li><code>@Resource</code>时java扩展包中的，也就是JDK的，所以是标准注解，更加通用；</li><li><code>@Autowired</code>是spring框架中的；</li><li>默认根据 <code>byName</code>装配；</li></ul></li></ul><h2 id="反射机制">反射机制</h2><ul><li><p>获取Class对象的方式</p><pre><code class="language-java">// 类名.classClass clazz1 = User.class;// 对象.getClass()Class clazz2 = new User().getClass();// Class.forName(&quot;全路径&quot;)Class clazz3 = Class.forName(&quot;com.lm.User&quot;);// 实例化User user =(User)clazz1.getDeclaredConstructor().newInstance();</code></pre></li><li><p>获取构造方法</p><pre><code class="language-java">Class clazz = User.class;        // 获取所有public构造方法Constructor[] constructors1 = clazz.getConstructors();        // 获取所有构造方法(包括private)Constructor[] constructors2 = clazz.getDeclaredConstructors();// 指定有参数构造创建对象//public        Constructor c1 = clazz.getConstructor(String.class,int.class);        User user1 = (User)c1.newInstance(&quot;ming&quot;,21);  // privateConstructor c2 = clazz.getDeclaredConstructor(String.class, int.class);        c2.setAccessible(true); // 设置允许访问        User user2 = (User)c2.newInstance(&quot;ming&quot;,21);</code></pre></li><li><p>获取属性</p><pre><code class="language-java">Class clazz = User.class;// 获取所有public属性Field[] fields1 = clazz.getFields();        // 获取所有属性（包括private）Field[] fields2 = clazz.getDeclaredFields();</code></pre></li><li><p>获取方法</p><pre><code class="language-java">User user = new User(&quot;ming&quot;,21);Class clazz = user.getClass();// public 方法Method[] methods1 = clazz.getMethods();for(Method m:methods1)&#123;    if(m.getName().equals(&quot;toString&quot;))&#123;        m.invoke(user); // 执行 toString()方法    &#125;&#125;// privateMethod[] methods2 = clazz.getDeclaredMethods();for(Method m:methods2)&#123;    if(m.getName().equals(&quot;run&quot;))&#123;        m.setAccessible(true); // 设置允许访问        m.invoke(user); // 执行 private run()方法    &#125;&#125;</code></pre></li></ul><h2 id="代理模式">代理模式</h2><ul><li><p><strong>代理模式</strong>：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p></li><li><p><strong>静态代理</strong>：通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的。</p><ul><li><p>接口</p><pre><code class="language-java">public interface UserService &#123;    public void add();    public void delete();    public void update();    public void query();&#125;</code></pre></li><li><p>真实类</p><pre><code class="language-java">public class UserServiceImpl implements UserService&#123;    @Override    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    @Override    public void update() &#123;        System.out.println(&quot;修改了一个用户&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;</code></pre></li><li><p>代理类</p><pre><code class="language-java">public class UserServiceProxy implements UserService&#123;    // 注入真实类对象    private UserServiceImpl userService;    public void setUserService(UserServiceImpl userService) &#123;        this.userService = userService;    &#125;    @Override    public void add() &#123;        log(&quot;add&quot;);        userService.add();    &#125;    @Override    public void delete() &#123;        log(&quot;delete&quot;);        userService.delete();    &#125;    @Override    public void update() &#123;        log(&quot;update&quot;);        userService.update();    &#125;    @Override    public void query() &#123;        log(&quot;query&quot;);        userService.query();    &#125;    //增加日志打印    public void log(String msg)&#123;        System.out.println(&quot;使用了&quot;+msg+&quot;方法&quot;);    &#125;    //1.改动原有的业务代码,在公司中是大忌!&#125;</code></pre></li><li><p>客户端（测试）</p><pre><code class="language-java">public class Client &#123;    public static void main(String[] args) &#123;        UserServiceImpl userService = new UserServiceImpl();//        userService.add();      //不使用代理        UserServiceProxy userServiceProxy =new UserServiceProxy();        userServiceProxy.setUserService(userService);        userServiceProxy.add();        userServiceProxy.delete();    &#125;&#125;</code></pre></li><li><p>静态代理的缺点：对于每一个真实类对象都要创建一个代理类，开发效率低；</p></li></ul></li><li><p><strong>动态代理</strong>：在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术</p><ul><li><p>接口</p><pre><code class="language-java">public interface UserService &#123;    public void add();    public void delete();    public void update();    public void query();&#125;</code></pre></li><li><p>真实类</p><pre><code class="language-java">public class UserServiceImpl implements UserService &#123;    @Override    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    @Override    public void update() &#123;        System.out.println(&quot;修改了一个用户&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;</code></pre></li><li><p>代理类</p><pre><code class="language-java">public class ProxyInvocationHandler implements InvocationHandler &#123;    // 被代理的对象    private Object target;    public void setTarget(Object target)&#123;        this.target = target;    &#125;    // 生成代理类    public Object getProxy()&#123;        // 三个参数        // 1. 加载动态生成代理类的类加载器        // 2. 目标对象实现的所有接口的Class类型数组        // 3 .设置代理对象实现目标对象方法的过程        return Proxy.newProxyInstance(this.getClass().getClassLoader(),                                      target.getClass().getInterfaces(),this);    &#125;    // 处理代理实例，并返回结果    // 参数1：代理对象    // 参数2：代理对象需要实现的方法    // 参数3：method方法里面的参数    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        // 动态代理的本质，就是使用反射机制实现        log(method.getName());        Object result = method.invoke(target,args);        return result;    &#125;    public void log(String msg)&#123;        System.out.println(&quot;执行了&quot;+msg+&quot;方法&quot;);    &#125;&#125;</code></pre></li><li><p>客户端（测试）</p><pre><code class="language-java">public class Client &#123;    public static void main(String[] args) &#123;        //真实角色        UserServiceImpl userService = new UserServiceImpl();        //代理角色，不存在        ProxyInvocationHandler pih = new ProxyInvocationHandler();        pih.setTarget(userService); //设置要代理的对象        //动态生成代理类        UserService proxy = (UserService) pih.getProxy();        proxy.query();        proxy.add();    &#125;&#125;</code></pre></li><li><p>结果</p><pre><code class="language-bash">执行了query方法查询了一个用户执行了add方法增加了一个用户</code></pre></li></ul></li></ul><h2 id="AOP">AOP</h2><ul><li><p><strong>AOP</strong>：是一种设计思想，通过<strong>预编译</strong>方式和<strong>运行期间动态代理</strong>方式实现，在不修改源码的情况下，给程序动态添加额外功能的一种技术。</p><p>优点：对业务逻辑各部分进行<strong>解耦</strong>，提高程序的可重用性，提高开发效率。</p></li><li><p>动态代理的分类</p><ul><li>JDK动态代理：（有接口的情况）代理对象和目标对象实现同样的接口</li><li>cglib动态代理：（没有接口的情况）继承被代理的目标类</li></ul></li><li><p>相关术语</p><ul><li><strong>连接点</strong>：描述的是程序执行的某个特定位置。如一个类的初始化前、初始化后，或者类的某个方法调用前、调用后、方法抛出异常后等等；</li><li><strong>切入点</strong>：是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件；</li><li><strong>通知</strong>：切面在某个具体的连接点采取的行为或行动，切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。</li></ul></li></ul><h2 id="基于注解实现AOP">基于注解实现AOP</h2><ul><li><p>引入对应的依赖</p><pre><code class="language-xml">    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;        &lt;version&gt;6.0.9&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;        &lt;version&gt;6.0.7&lt;/version&gt;    &lt;/dependency&gt;</code></pre></li><li><p>创建目标资源</p><pre><code class="language-java">public interface UserService &#123;    public void add();    public void delete();    public void update();    public void query();&#125;</code></pre><pre><code class="language-java">@Servicepublic class UserServiceImpl implements UserService &#123;    @Override    public void add() &#123;        System.out.println(&quot;增加了一个用户&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;删除了一个用户&quot;);    &#125;    @Override    public void update() &#123;        System.out.println(&quot;修改了一个用户&quot;);    &#125;    @Override    public void query() &#123;        System.out.println(&quot;查询了一个用户&quot;);    &#125;&#125;</code></pre></li><li><p>创建切面类并进行配置</p><pre><code class="language-java">// 切面类@Component@Aspectpublic class LogAspects &#123;    // 设置切入点和通知类型        // 通知类型    // 前置：@Before()    // 返回：@AfterReturning    // 异常：@AfterThrowing    // 后置：@After()    // 环绕：@Around()    @Before(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)    public void beforeMethod()&#123;        System.out.println(&quot;(注解方式)====方法执行前====&quot;);    &#125;    @After(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)    public void afterMethod()&#123;        System.out.println(&quot;(注解方式)====方法执行后====&quot;);    &#125;    //在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点;    @Around(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)    public void aroundMethod(ProceedingJoinPoint pj) throws Throwable&#123;        System.out.println(&quot;环绕前&quot;);        Signature signature = pj.getSignature(); //获得签名        System.out.println(&quot;signature: &quot;+signature);        Object proceed = pj.proceed();   //执行方法        System.out.println(&quot;环绕后&quot;);    &#125;&#125;</code></pre></li><li><p><strong>编写applicationContext.xml文件</strong></p><pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       http://www.springframework.org/schema/context       https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;    &lt;!--开启组件扫描--&gt;    &lt;context:component-scan base-package=&quot;com.lm&quot;&gt;&lt;/context:component-scan&gt;        &lt;!--开启注解支持!   JDK(默认 proxy-target-class=&quot;false&quot; )   cglib(  proxy-target-class=&quot;true&quot;)--&gt;    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt;</code></pre></li><li><p>测试</p><pre><code class="language-java">public class TestAspects &#123;    public static void main(String[] args) &#123;        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        UserService userService = context.getBean(UserService.class);        userService.add();    &#125;&#125;</code></pre></li><li><p>结果</p><pre><code class="language-shell">环绕前signature: void com.lm.service.UserService.add()(注解方式)====方法执行前====增加了一个用户(注解方式)====方法执行后====环绕后</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>java工作方式</strong>：</p><ul><li><strong>源代码</strong>：demo.java文件</li><li><strong>编译器</strong>：运行源代码检查错误，将demo.java编译为demo.class文件，由字节码组成</li><li><strong>输出</strong>：输出demo.class</li><li><strong>java虚拟机</strong>：运行demo.class文件，将字节码转换为平台能理解的形式</li></ul><p><strong>java程序结构</strong>：</p><ol><li>源文件（source file）<br>2. 类（class file）<br>3. 方法（method）: 函数或过程<br>4. 语句（statement）</li></ol><p>java是面向对象的语言，所有东西都得包含在类里。</p><h2 id="基本概念">基本概念</h2><ul><li>输入输出</li></ul><pre><code class="language-java">import java.util.Scanner;class Input &#123;    public static void main(String[] args) &#123;        Scanner input = new Scanner(System.in);        System.out.print(&quot;输入一个整数: &quot;);        int number = input.nextInt();        System.out.println(&quot;您输入 &quot; + number);                //获取double输入        double myDouble = input.nextDouble();            //获取字符串输入        String myString = input.next(); //以空格结束        input.useDelimiter(&quot;\n&quot;); // 设置为以换行结束        String myString = input.nextline(); // 以回车结束         //关闭scanner对象        input.close();    &#125;&#125;</code></pre><ul><li>数据类型</li></ul><pre><code class="language-java">int x =0string[] str = 'hello world!'println() //输出加换行int len = str.lengthint x = (int) 24.6 //类型转换while(flag)&#123;&#125;//java中integer与boolean两个类型不相容，故flag必须为boolean类型 </code></pre><ul><li>Java数组</li></ul><pre><code class="language-java">int[] myList;         // 数组变量声明，首选的方法int myList[];         //  效果相同，但不是首选方法array = new int[arraySize];     // 创建数组int[] array = new int[arraySize];   // 数组变量声明 + 创建数组int[] array = &#123;0,1,2&#125;;Arrays.sort(array); // 数组排序int[][] a = new int[2][3];// 二维数组创建</code></pre><p>*** 在Java中，<strong>动态数组</strong>是通过ArrayList实现的。可以使用add()方法向ArrayList中添加元素。以下是添加元素的示例代码：</p><pre><code class="language-java">ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();// 向数组末尾添加元素arrayList.add(&quot;元素1&quot;);arrayList.add(&quot;元素2&quot;);arrayList.add(&quot;元素3&quot;);// 在指定位置添加元素arrayList.add(1, &quot;新元素&quot;);System.out.println(arrayList); // 输出 [元素1, 新元素, 元素2, 元素3]arrayList.sort(Comparator.naturalOrder());// 升序排列arrayList.sort(Comparator.reverseOrder()); // 降序arrayList.size()</code></pre><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p><pre><code class="language-java">for(type element: array)&#123;    System.out.println(element);&#125;</code></pre><ul><li><p>可变参数列表：</p><pre><code class="language-java">// 使用数组语法实现可变参数列表public void printArray(Object[] args)&#123;    for(Object obj: args)&#123;    System.out.println(obj + &quot; &quot;);    &#125;&#125;// 使用省略号实现可变参数列表public void printArray(Object... args)&#123;    for(Object obj: args)&#123;    System.out.println(obj + &quot; &quot;);    &#125;&#125;</code></pre></li><li><p>枚举类型：多用在swith语句中；</p><pre><code class="language-java">public enum Color&#123;    RED,BLUE,WHITE,GREEN&#125;Color color = Color.RED;</code></pre></li><li><p>java中的全局变量与全局方法：任何变量只要加上public，static和final，基本上都会变成全局变量取用的常数。这是一种近似全局的事物，他们也必须定义在类中。</p></li><li><p>java是通过<strong>值传递</strong>的，也就是通过拷贝传递；</p><ul><li>传递基本类型参数：方法接收到的是参数的拷贝，会创建副本；</li><li>传递引用类型参数：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本；</li></ul></li><li><p>什么是自动拆装箱？</p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul></li></ul><h2 id="面向对象">面向对象</h2><ul><li><p><strong>面向对象和面向过程</strong></p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。（<strong>面向对象开发的程序一般更易维护、易复用、易扩展。</strong>）</li></ul></li><li><p>对象具有接口</p><ul><li><p>对象能够接受什么请求是由它的<strong>接口</strong>（interface）决定的，而接口由对象所归属的类定义；</p><pre><code class="language-java">// 类型class Light&#123;    public void on()&#123; // 接口            &#125;    public void off()&#123; // 接口            &#125;&#125;Light lt = new Light();  // 创建对象lt.on();// 对象发出请求</code></pre></li></ul></li><li><p>对象和对象引用</p><ul><li>new运算符创建对象，存放在堆内存中；</li><li>对象引用指向对象，存放在栈内存中；</li></ul><pre><code class="language-java">Person person = new Person()\\ person:对象引用</code></pre></li><li><p>对象相等和引用相等</p><ul><li>对象相等：内存中的内容相等；</li><li>引用相等：内存的地址相等；</li></ul></li><li><p>面向对象三大特征</p><ul><li><p><strong>封装</strong></p><ul><li>实例变量标记为<strong>private</strong></li><li>提供公有的getters与setters，标记为<strong>public</strong>，来控制存取动作</li><li><strong>public</strong>：可以被所有人访问；<strong>private</strong>：只能被类的创建者通过自身的方法访问；<strong>protected</strong>：类似于private，但是区别是继承的子类可以访问；</li></ul></li><li><p><strong>继承</strong></p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li><p><strong>多态</strong></p><ul><li>存在的三个必要条件：继承，重写，父类引用指向子类对象 <strong>Parent p = new Child()</strong></li></ul><pre><code class="language-java">class Shape &#123;    void draw() &#123;&#125;&#125; class Circle extends Shape &#123;    void draw() &#123;        System.out.println(&quot;Circle.draw()&quot;);    &#125;&#125;· class Square extends Shape &#123;    void draw() &#123;        System.out.println(&quot;Square.draw()&quot;);    &#125;&#125;</code></pre></li></ul></li><li><p>参数化类型（泛型）</p><ul><li><p>一个被参数化的类型是一个特殊的类，可以让编译器自动适配特定的类型；</p></li><li><p>例如，编译器可以将集合定义为只接受放入shape的对象，因此集合中也只能取出shape对象；</p><pre><code class="language-java">ArrayList&lt;shape&gt; shapes = new ArraytList&lt;&gt;();\\ 创建一个防止shape对象的ArrayList</code></pre></li></ul></li><li><p>对象的创建和生命周期</p><ul><li>创建一个新对象时，可以通过堆内存来创建，因为堆是在运行时动态管理内存的；</li><li>java只允许<strong>动态分配内存</strong>，当创建一个新对象时，都需要通过new操作符创建一个对象的动态实例；</li><li>java底层支持<strong>垃圾收集器</strong>机制，它知道一个对象何时不会再用，并自动释放该对象占用的内存；</li></ul></li><li><p>异常处理</p></li></ul><h2 id="对象">对象</h2><ul><li><p>数据保存的地方</p><ul><li>寄存器：数据直接保存在中央处理器（CPU），存储速度最快；</li><li>栈：数据存储在RAM里，效率仅次于寄存器；</li><li>堆：是一个通用的内存池（也使用RAM），用于存放所有的java对象；</li><li>常量：直接保存在程序代码中；</li></ul></li><li><p>static关键字</p><ul><li>使用static的字段或方法不依赖于对象；</li><li>即便没有为这个类创建对象，也可以调用该类的static方法和static字段；</li></ul><pre><code class="language-java">class test&#123;    static int x = 0;&#125;test t1 = new test();test t2 = new test();// 即便创建了两个对象，test.x只会占用同一块空间// t1.x和t2.x均为0</code></pre></li></ul><h2 id="操作符">操作符</h2><ul><li><p><strong><code>==</code></strong> 和 <strong><code>equals ()</code></strong> 的区别：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li><li><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来<strong>判断两个对象是否相等</strong></li></ul><pre><code class="language-java">String a = new String(&quot;ab&quot;); // a 为一个引用String b = new String(&quot;ab&quot;); // b为另一个引用,对象的内容一样String aa = &quot;ab&quot;; // 放在常量池中String bb = &quot;ab&quot;; // 从常量池中查找System.out.println(aa == bb);// trueSystem.out.println(a == b);// falseSystem.out.println(a.equals(b));// trueSystem.out.println(42 == 42.0);// true</code></pre></li></ul><h2 id="初始化和请理">初始化和请理</h2><ul><li><p>构造器进行初始化</p><ul><li>构造器的名字就是类的名字；</li><li>构造器也可以传入参数来指定如何创建对象；</li></ul><pre><code class="language-java">class Rock&#123;    Rock()&#123; //无参构造器        System.out.print(&quot;Rock&quot;)    &#125;    Rock(int x)&#123; //构造器        System.out.print(&quot;Rock&quot; + x );    &#125;&#125;</code></pre></li><li><p><strong>方法重载</strong></p><ul><li>允许不同参数类型的方法<strong>具有相同的名字</strong>；例如可以创建一个无参构造器和有参数传递的构造器；</li><li>每个重载方法必须有<strong>独一无二的参数列表</strong>；</li></ul></li><li><p><strong>重写</strong></p><ul><li><strong>@override</strong>注解，表示该方法是一个重写（Override）父类中的方法，而不是在子类中定义一个新的方法；</li><li>@Override注解只能应用于重写父类中的方法，而不能应用于接口中的方法或静态方法。</li></ul></li><li><p>无参构造器</p><ul><li>如果你没有创建构造器，系统会自动为这个类创建一个无参构造器；</li><li>但如果你已经创建了构造器，即便没有无参构造器，系统都不会再自动创建了；</li></ul></li><li><p><strong>this</strong>关键字</p><ul><li>this 表示对当前对象的引用；</li><li>只能在非静态方法中使用；</li></ul><pre><code class="language-java">class Person&#123;    private String name;    private int age;        public Person(String name,int age)&#123;        this.name = name;        this.age = age;    &#125;&#125;</code></pre></li><li><p>finalize()方法</p><ul><li>Java中：<ul><li>对于一些特殊的内存，垃圾处理器可能不知道怎么释放；</li><li>垃圾收集不是析构；</li><li>垃圾收集仅与内存有关；</li></ul></li><li>finalize()的使用仅限于一种特殊情况，对象以某种方式分配空间，而不是通过创建对象来分配；</li></ul></li><li><p><strong>垃圾收集器的工作原理</strong></p><ul><li>java中的堆更像一个传送带，“堆指针”只是简单的移动到尚未分配的区域，而垃圾收集器的介入可以使“堆指针”移到靠近传送带的地方，由此构建了一个高速的，有无限空闲空间的堆模型；</li><li><strong>引用计数</strong>：每个对象都有一个引用计数器，每次该对象被引用时，引用计数都会增加；离开作用域或设置为null时计数器减小；</li><li><strong>停止-复制</strong>：该算法将可用内存空间分为两部分，每次只使用其中一部分。当一部分内存用完后，将未被回收的对象复制到另一部分内存中，并清除原来的内存。该算法的优点是简单高效，缺点是需要额外的内存空间。</li><li><strong>标记-清除</strong>：该算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后进行清除。该算法的缺点是会产生内存碎片，容易导致频繁的内存分配和回收。</li></ul></li></ul><h2 id="实现隐藏">实现隐藏</h2><ul><li>控制访问被称为<strong>实现隐藏</strong>；</li><li>将数据和方法包装在类中，并与实现隐藏结合，称为<strong>封装</strong>；</li><li><strong>类不能是private或protected的</strong>；如果想要防止对该类的访问，可以将该类的构造器都设为priate；</li></ul><h2 id="复用">复用</h2><ul><li><p><strong>组合</strong></p><ul><li>组合就是 A类的对象是B类的成员变量。相当于 A类对象是B类对象的一个变量，A类中的所有功能，B类都可以通过A类对象的调用来实现。</li><li>组合体现的是整体与部分、拥有的关系，即 has - a 的关系</li></ul></li><li><p><strong>继承</strong></p><ul><li><p>继承在面向对象语言中必不可少；其实创建一个类时，总是在继承，除非明确指定要继承某个类，否则都会<strong>隐式继承java的标准根类Object</strong>；</p></li><li><p>使用<strong>extends</strong>关键字，可以使用基类中的方法，还可以向子类中添加新方法；</p></li><li><p>创建对象时，构造过程是由基类 “向外” 进行的；即便没有为子类创建构造器，编译器也会自动创建一个可以调用基类的无参构造器；</p></li><li><p>如果基类没有无参构造器，那么就需要用 <strong>Super</strong>关键字来显示的调用构造器；</p><pre><code class="language-java">class Art&#123;    Art(int i)&#123;        ...    &#125;&#125;class Draw extends Art&#123;    Draw(int i)&#123;        super(i); // 调用基类构造器        ...    &#125;&#125;public Cartoon extends Draw&#123;    Cartoon()&#123;        super(11); // 调用基类构造器        ...    &#125;    public static void main()&#123;&#125;&#125;</code></pre></li></ul></li><li><p><strong>向上转型</strong></p><ul><li><p>在Java中，子类继承了父类的所有方法和属性，因此<strong>子类对象可以被当做父类对象来使用</strong>。这种将子类对象转换为父类对象的过程就是向上转型。</p></li><li><p>向上转型总是安全的，因为是从更具体的类型转换为更通用的类型；</p><pre><code class="language-java">class Animal &#123;    public void eat() &#123;        System.out.println(&quot;Animal is eating.&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void bark() &#123;        System.out.println(&quot;Dog is barking.&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Animal animal = new Dog();  // 创建了一个Dog对象，并将其赋值给Animal类型的变量animal,完成向上转型        animal.eat();  // 调用父类方法 // 动态绑定        animal.bark();  // 编译错误，父类不能访问子类特有的方法    &#125;&#125;</code></pre></li></ul></li><li><p><strong>final</strong></p><ul><li>final，static表示是一个常量；</li><li>空白 final：即没有被初始化的final字段；必须在构造器里进行初始化，保证了final字段在使用之前总是被初始化；</li><li>final参数：只能读取，不能修改参数；</li><li>final类：该类不能被继承；</li></ul></li></ul><h2 id="多态">多态</h2><ul><li><p>多态是指同一个方法或者同一个类在不同的情况下表现出不同的行为。Java中的多态性主要通过方法的重载和覆盖以及向上转型实现。</p><pre><code class="language-java">class Animal&#123;    public void eat()&#123;&#125;&#125;public class cat extends Animal&#123;   @override public void eat()&#123;&#125;&#125;public class zoo&#123;    public void manage(Animal i)&#123; //方法接收一个Animal引用，他怎么知道这个引用在这里指的是cat，而不是dog，pig?        i.eat();    &#125;    public static void main()&#123;        cat cat1 = new cat();        manage(cat1); // 向上转型    &#125;&#125;</code></pre></li><li><p><strong>方法调用绑定</strong></p><ul><li><strong>前期绑定</strong>：在程序运行之前执行绑定，面向过程语言中默认是前期绑定；在多态中，困惑的点在于，编译器中只有一个基类引用时，怎么确定哪个才是要调用的正确方法；</li><li><strong>后期绑定</strong>（动态绑定）：是指在运行时根据对象的实际类型来调用相应的方法；java中所有方法都是动态绑定，除非方法是static或final的；</li></ul></li><li><p><strong>构造器和多态</strong></p><ul><li>构造器的调用顺序<ul><li>基类构造器被调用，然后是子类；</li><li>按声明的顺序初始化成员变量；</li><li>最后执行子类构造器的方法体；</li></ul></li><li>构造器内部的多态方法行为<ul><li>构造器负责创建对象，如果在构造器内调用动态绑定方法，则可以调用尚未被初始化的成员的方法——<strong>这将会导致灾难</strong></li></ul></li></ul></li></ul><h2 id="抽象类">抽象类</h2><ul><li><p><strong>抽象方法</strong>只有一个声明，没有方法体；</p><pre><code class="language-java">abstract void f();</code></pre></li><li><p><strong>包含抽象方法的类</strong>称为抽象类，抽象类（Abstract Class）是一种<strong>不能被实例化的类，它只能作为其他类的父类</strong>，用于定义一些抽象方法和非抽象方法；</p><pre><code class="language-java">absrtact class Basic&#123;    abstract void f();    void m();&#125;Basic b = new Basic(); // 错误的，抽象类不能被实例化</code></pre></li><li><p>如果要创建一个可实例化的类，继承抽象类后<strong>要为所有的抽象方法提供定义</strong>；</p><pre><code class="language-java">public class A extends Basic()&#123;    @override void f()&#123;        System.out.print(&quot;hello!&quot;);    &#125;&#125;</code></pre></li></ul><h2 id="接口">接口</h2><ul><li><p>用<strong>interface</strong>关键字创建了一个完全抽象的类，它不代表任何实现；</p><pre><code class="language-java">public interface Instrument&#123;    void f1();    int f2();    public static final int N = 4; //接口中的字段必须被声明为 public static final        default void f3()&#123;        System.out.print(&quot;hello!&quot;); // default关键字允许我们在接口中实现方法    &#125;&#125;</code></pre></li><li><p>使用<strong>implements</strong>关键字创建一个符合特定接口的类，表示要提供它的定义；</p><pre><code class="language-java">public class guitar implements Instrument&#123;     @override public void f1()&#123; // 来自接口的方法必须被定义为public        System.out.print(&quot;hello!&quot;);     &#125;     @override public int f2()&#123;        return 1;     &#125;&#125;</code></pre></li><li><p><strong>多重继承</strong></p><ul><li>Java通过接口来解决多继承问题。一个类可以实现多个接口，从而具有多个不同的行为。</li></ul></li><li><p><strong>抽象类与接口</strong></p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">接口</th><th style="text-align:center">抽象类</th></tr></thead><tbody><tr><td style="text-align:center">组合</td><td style="text-align:center">可在新类中组合多个接口</td><td style="text-align:center">只能继承一个抽象类</td></tr><tr><td style="text-align:center">状态</td><td style="text-align:center">不能包含字段（静态字段除外）</td><td style="text-align:center">可以包含字段，且非抽象方法可以引用这些字段</td></tr><tr><td style="text-align:center">默认方法&amp;抽象方法</td><td style="text-align:center">默认方法不需要在子类中实现，它只能引用子接口中的方法</td><td style="text-align:center">抽象方法必须在子类中实现</td></tr><tr><td style="text-align:center">构造器</td><td style="text-align:center">不能有构造器</td><td style="text-align:center">可以有构造器</td></tr><tr><td style="text-align:center">访问权限</td><td style="text-align:center">隐式的public</td><td style="text-align:center">可以为protected或包访问权限</td></tr></tbody></table></li><li><p><strong>工厂方法</strong>设计模式</p><ul><li><p>产生某个接口的对象时，不是直接调用构造器，而是在工厂对象上直接调用构建方法；</p><pre><code class="language-java">// 动物接口interface Animal &#123;    void speak();&#125;// 工厂接口interface AnimalFactory &#123;    Animal createAnimal();&#125;// 狗类class Dog implements Animal &#123;    public void speak() &#123;        System.out.println(&quot;汪汪汪！&quot;);    &#125;&#125;// 猫类class Cat implements Animal &#123;    public void speak() &#123;        System.out.println(&quot;喵喵喵！&quot;);    &#125;&#125;// 狗工厂类class DogFactory implements AnimalFactory &#123;    @override public Animal createAnimal() &#123;        return new Dog();    &#125;&#125;// 猫工厂类class CatFactory implements AnimalFactory &#123;    @override public Animal createAnimal() &#123;        return new Cat();    &#125;&#125;public class Factories&#123;    public static void animalAct(AnimalFactory fact)&#123;        Animal a = fact.createAnimal();        a.speak();    &#125;    public static void main()&#123;        animalAct(new DogFactory());        animalAct(new CatFactory());    &#125;&#125;</code></pre></li></ul></li><li><p>接口的新特性</p><ul><li><p>接口中可以加入private的方法，这些方法只能被接口内的其他方法调用;</p><pre><code class="language-java">public interface Instrument&#123;    private void f1()&#123;           // 默认是default的        System.out.print(&quot;hello!&quot;);    &#125;       default void f2()&#123;         f1();    &#125;&#125;</code></pre></li></ul></li></ul><h2 id="内部类">内部类</h2><ul><li><p>创建内部类</p><ul><li>内部类即定义在其他类内的类；</li><li>在外部创建非静态内部类的对象的时候，必须将对象的类型指定为 OuterClassName.InnerClassName</li></ul></li><li><p>为何使用内部类</p><ul><li>可以<strong>隐藏细节和内部结构</strong>，封装性更好；</li></ul></li><li><p>内部类可以访问外围类的所有成员（当创建一个内部类时，内部类的对象会隐含一个链接指向创建该对象的外围对象）</p></li><li><p>要使用外部类的名字，可以使用 OuterName.this ;</p><pre><code class="language-java">public class DotThis&#123;    void f()&#123;&#125;;    public class Inner()&#123; // 内部类        public DotThis outer()&#123;            return DoThis.this;    // 如果使用”this“，引用的会是Inner的”This“        &#125;    &#125;&#125;</code></pre></li></ul><h2 id="集合">集合</h2><ul><li><p>利用泛型指定保存在集合中对象的类型</p><pre><code class="language-java">import java.util.*;ArrayList&lt;Apple&gt; apple = new ArrayList&lt;&gt;(); // 编译时将阻止我们将错误的类型的对象放入某个集合中</code></pre></li><li><p>Java 集合类库（可以表示为库的两个基本接口）</p><ul><li><p><strong>Collection</strong>：一个由单独元素组成的序列；</p><ul><li><strong>List</strong> ：必须按元素插入顺序来保存他们；<ul><li><code>ArrayList</code> 和 <code>LinkedList</code>类</li></ul></li><li><strong>Set</strong>：不能存在重复元素；<ul><li><code>HashSet</code>：查找速度最快；</li><li><code>TreeSet</code>：按添加顺序升序保存对象；</li><li><code>LinkedHashSet</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；</li></ul></li><li><strong>Queue</strong>：先进先出</li></ul></li><li><p><strong>Map</strong> ：一组键值对对象，使用键来查找值；</p><ul><li><p>List使用数值来查找某个对象，而<strong>Map使用另一个对象来查找某个对象</strong>，它将对象与对象关联在了一起，因此也被称为关联<strong>数组</strong> or <strong>字典</strong></p></li><li><p>操作</p><pre><code class="language-java">Map.put(key,value);  //添加键值对Map.get(key) // 查值</code></pre></li><li><p>三种风格</p><ul><li><code>HashMap</code>：查找顺序最快；</li><li><code>TreeMap</code>：按添加元素的升序排列；</li><li><code>LinkedHashMap</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；</li></ul></li></ul></li></ul></li><li><p><strong>List</strong></p><ul><li><p>分类</p><ul><li><code>ArrayList</code>：<strong>访问性能好，中间插入或删除元素的速度慢；</strong></li><li><code>LinkedList</code>：<strong>访问性能差，但是中间插入或删除元素的成本低；</strong></li></ul></li><li><p><code>ArrayList</code>常用方法</p><pre><code class="language-java">add();  // 添加元素addAll();   // 添加所有元素contains();  // 确定某个对象是否在列表中remove();  // 移除对象get(i);   // 通过索引获取元素indexOf(value);  // 获得List中的索引编号size(); // 元素数量set(i，v); // 替换指定索引的元素sort(); //排序toString(); // 转换为字符串isEmpty(); // 判空</code></pre></li><li><p>迭代器（<strong>Iterator</strong>）</p><ul><li><code>Iterator</code>是一种用于遍历集合类（如<code>ArrayList</code>、<code>HashSet</code>等）元素的接口。通过使用<code>Iterator</code>接口，可以在不暴露集合内部结构的情况下，逐个访问集合中的元素。</li><li><code>Iterator</code>能够<strong>将序列的遍历操作和底层结构分离</strong>，即迭代器<strong>统一了对集合的访问</strong>；</li><li><code>Iterator</code>接口包含以下常用方法：<ul><li><code>boolean hasNext()</code>：如果迭代器还有下一个元素，则返回<code>true</code>。</li><li><code>E next()</code>：返回迭代器的下一个元素。</li><li><code>void remove()</code>：从迭代器返回的集合中删除迭代器最后一个元素。</li></ul></li></ul></li><li><p><code>LinkedList</code>常用方法</p><pre><code class="language-java">getFirst()  element()  peek() // 均为返回列表的头部     removeFirst()   remove()   // 移除并返回列表头部add()  addLast()  offer()  //在列表尾部插入元素addFirst()  //列表开头插入元素removeLast() // 移除并返回列表的最后一个元素</code></pre></li></ul></li><li><p><strong>Stack</strong></p><ul><li>通过<code>LinkedList</code>提供</li></ul><pre><code class="language-java">Stack&lt;String&gt; s = new Stack&lt;&gt;();s.push(&quot;hello!&quot;);s.pop();s.peek(); // 返回栈顶元素</code></pre></li><li><p><strong>Set</strong></p><ul><li><p>不允许有重复元素出现</p></li><li><p>常用来测试成员身份</p><pre><code class="language-java">Set&lt;String&gt; set1 = new HashSet&lt;&gt;();Collections.addAll(set1,&quot;A B C D E&quot;.split(&quot; &quot;));set1.contains(&quot;D&quot;);// trueset1.containsAll(set2);</code></pre></li></ul></li><li><p><strong>Map</strong></p><ul><li><p>对象映射到对象</p><pre><code class="language-java">Map&lt;String,Pet&gt; petMap = new Map&lt;&gt;();petMap.put(&quot;My cat&quot;,new Cat(&quot;mm&quot;));petMap.put(&quot;My dog&quot;,new Dog(&quot;ww&quot;));Pet dog = petMap.get(&quot;My dog&quot;); // &quot;ww&quot;petMap.getOrDefault(key,&quot;Not Found&quot;) // 获取指定 key 对应对 value，如果找不到则返回设置的默认值。petMap.containsKey(&quot;My cat&quot;); // truepetMap.containsValue(dog); // true</code></pre></li><li><p><code>HashMap</code></p><ul><li><p><code>HashMap</code> 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全的</strong>。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个;</p></li><li></li></ul></li></ul></li><li><p><strong>Queue</strong></p><ul><li><p>典型的先进先出（<strong>FIFO</strong>）的集合。</p></li><li><p><code>LinkedList</code>实现了<code>Queue</code>接口，提供了支持队列行为的方法，因此可以通过将<code>LinkedList</code>向上转型为<code>Queue</code>实现队列；</p><pre><code class="language-java">// 普通队列Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;();q.offer(); // 队列特有的操作，队列尾部插入元素q.peek(); // 返回头部，若队列为空，则返回NULL   q.element();  // 返回头部，若队列为空，则报错q.poll();  // 删除头部元素，若队列为空，则返回NULLq.remove(); // 删除头部元素，若队列为空，则报错// 双端队列Deque&lt;Integer&gt; dq = new LinkedList&lt;&gt;();dq.offerLast();dq.peekFirst();dq.getFirst();dq.pollFirst();dq.removeFirst();</code></pre></li><li><p><code>PriorityQueue</code></p><ul><li><p>优先级最高的元素先出；</p></li><li><p>当一个元素被加入队列，会先进行排序再加入；</p><pre><code class="language-java">PriorityQueue&lt;Integer&gt; priorityQueue = new PriorityQueue&lt;&gt;(); </code></pre></li></ul></li></ul></li></ul><h2 id="函数式编程">函数式编程</h2><ul><li><p>通过整合现有代码来产生新功能，而不是从零开始编写所有内容；</p><p><strong>面向对象编程抽象数据，而函数式编程抽象行为</strong></p></li><li><p><strong>lambda 表达式</strong></p><ul><li><p>基本语法：</p><ul><li>参数；</li><li>后面跟 - &gt;，可以读为产生；</li><li>-&gt; 后面都是方法体。</li></ul><pre><code class="language-java">List&lt;String&gt; strings = Arrays.asList(&quot;hello&quot;, &quot;world&quot;);List&lt;String&gt; upperCaseStrings = strings.stream()    .map(str -&gt; str.toUpperCase()) // map()方法接受一个lambda表达式作为参数，该表达式将字符串转换为大写字母。                                      //由于lambda表达式只有一个参数，因此可以省略参数列表的括号。    .forEach(System.out::println);</code></pre></li><li><p>编写递归的lambda表达式；</p></li></ul></li><li><p><strong>方法引用</strong></p><ul><li>基本语法 ：<code>类名or对象名</code> +  <code>::</code>  + <code>方法名</code></li></ul><pre><code class="language-java">List&lt;String&gt; list = Arrays.asList(&quot;Hello&quot;, &quot;World&quot;);list.stream().map(String::toUpperCase).forEach(System.out::println);</code></pre><ul><li>直接引用已有的方法或构造函数，而不需要像lambda表达式那样创建新的方法体。</li><li><code>Runnable</code></li></ul><pre><code class="language-java">class Go &#123;    static void go() &#123;        System.out.println(&quot;go!&quot;);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        // Thread 对象接受一个Runnable作为其构造器参数，start()方法会调用该引用的方法（run()）        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                System.out.println(&quot;hello&quot;);            &#125;        &#125;).start();                new Thread(Go::go).start();    &#125;&#125;</code></pre></li></ul><h2 id="流">流</h2><ul><li><p>“ 集合优化了对象的存储，而<strong>流</strong>（stream）与对象的成批处理有关 ”</p></li><li><p><strong>声明式编程</strong>，直接说明想要完成<strong>什么</strong>（how），而不是<strong>怎么做</strong>（what）</p><pre><code class="language-java">public class Stream &#123;    public static void main(String[] args)&#123;        new Random(1)            .ints(2, 10)            .limit(5)            .sorted()            .forEach(System.out::print);    &#125; &#125;</code></pre></li></ul><h2 id="异常">异常</h2><ul><li><p><strong>捕获异常</strong></p><pre><code class="language-java">try&#123;    // 可能会产生异常的代码&#125;catch()&#123;    // 异常处理程序&#125;try&#123;    // 可能会产生异常的代码&#125;catch()&#123;    // 异常处理程序&#125;catch()&#123;    &#125;finally&#123;    // 不管怎么样都会执行&#125;</code></pre></li></ul><h2 id="反射">反射</h2><ul><li><p>反射可以在程序运行时发现并使用对象的类型的<strong>所有信息</strong>；反射允许对类的成员变量，成员方法和构造方法进行编程访问；</p></li><li><p><strong>Class 对象</strong></p><ul><li><p>程序中每个类都会有一个Class 对象，它包含了与类相关的信息；</p></li><li><p>获取Class对象的三种方式：</p><ul><li><code>Class.forName(&quot;类名&quot;)</code></li><li><code>类名.class</code></li><li><code>对象.getClass( )</code> （已经创建了对象后才能使用）</li></ul></li><li><p>万物皆对象</p><ul><li>字节码文件：<code>Class</code>类的对象；</li><li>构造方法：<code>Constructor</code>类的对象；</li><li>成员变量：<code>Field</code>类的对象；</li><li>成员方法：<code>Method</code>类的对象；</li></ul></li><li><p>获取Class对象的方式</p><pre><code class="language-java">// 类名.classClass clazz1 = User.class;// 对象.getClass()Class clazz2 = new User().getClass();// Class.forName(&quot;全路径&quot;)Class clazz3 = Class.forName(&quot;com.lm.User&quot;);// 实例化User user =(User)clazz1.getDeclaredConstructor().newInstance();</code></pre></li><li><p>获取构造方法</p><pre><code class="language-java">Class clazz = User.class;        // 获取所有public构造方法Constructor[] constructors1 = clazz.getConstructors();        // 获取所有构造方法(包括private)Constructor[] constructors2 = clazz.getDeclaredConstructors();// 指定有参数构造创建对象//public        Constructor c1 = clazz.getConstructor(String.class,int.class);        User user1 = (User)c1.newInstance(&quot;ming&quot;,21);  // privateConstructor c2 = clazz.getDeclaredConstructor(String.class, int.class);        c2.setAccessible(true); // 设置允许访问        User user2 = (User)c2.newInstance(&quot;ming&quot;,21);</code></pre></li><li><p>获取属性</p><pre><code class="language-java">Class clazz = User.class;// 获取所有public属性Field[] fields1 = clazz.getFields();        // 获取所有属性（包括private）Field[] fields2 = clazz.getDeclaredFields();</code></pre></li><li><p>获取方法</p><pre><code class="language-java">User user = new User(&quot;ming&quot;,21);Class clazz = user.getClass();// public 方法Method[] methods1 = clazz.getMethods();for(Method m:methods1)&#123;    if(m.getName().equals(&quot;toString&quot;))&#123;        m.invoke(user); // 执行 toString()方法    &#125;&#125;// privateMethod[] methods2 = clazz.getDeclaredMethods();for(Method m:methods2)&#123;    if(m.getName().equals(&quot;run&quot;))&#123;        m.setAccessible(true); // 设置允许访问        m.invoke(user); // 执行 private run()方法    &#125;&#125;</code></pre></li></ul></li><li><p>转型前检查</p><ul><li>在java中，可以使用<code>instanceof</code>关键字检查一个对象是否是某个类的实例；</li></ul><pre><code class="language-java">if(x instanceof Dog)&#123;    ((DOg)x).bark();&#125;</code></pre></li><li><p>动态代理（proxy）</p><ul><li>在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术；</li><li><strong>AOP</strong>思想：基于动态代理思想，对原来目标对象创建代理对象，在不修改原对象代码情况下，通过代理对象调用增强功能的代码，从而对原有业务方法进行增强。</li></ul></li></ul><h2 id="泛型">泛型</h2><ul><li><p>让代码只需依赖于 &quot; <strong>某种不具体指定的类型</strong> &quot;，而不是特定的接口或类，那么就可以编写出更为通用的代码；</p></li><li><p>泛型类：</p><pre><code class="language-java">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123;     //key这个成员变量的类型为T,T的类型由外部指定      private T key;    public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定        this.key = key;    &#125;    public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定        return key;    &#125;&#125;</code></pre></li><li><p>泛型接口</p><pre><code class="language-java">//定义一个泛型接口public interface Generator&lt;T&gt; &#123;    public T next();&#125;</code></pre></li><li><p>类型通配符</p><pre><code class="language-java">public void showKeyValue1(Generic&lt;?&gt; obj)&#123;    Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125;// 类型通配符一般是使用？代替具体的类型实参// 此处’？’是类型实参，而不是类型形参!!!// ?和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</code></pre></li><li><p>泛型方法</p><pre><code class="language-java">// 定义一个泛型方法，需要将泛型参数列表(&lt;T&gt;)放在返回值之前(必不可少！)public &lt;T&gt; void f(T x)&#123;    System.out.println(x.getClass().getName());&#125;</code></pre></li></ul><h1>Java多线程</h1><h2 id="多线程的概念">多线程的概念</h2><ul><li><p><strong>进程</strong>：程序的基本执行实体（例如电脑中运行的某个软件）</p></li><li><p><strong>线程</strong>：线程是操作系统能够运算调度的最小单位。它被包含在进程中，是<strong>进程</strong>的实际运作单位。</p></li><li><p><strong>多线程</strong>：程序同时执行多个任务；</p></li><li><p><strong>并发</strong>(<code>concurrent</code>)指在java程序中同时运行多个线程；（同一时刻，多个指令在<strong>单个CPU</strong>上<strong>交替执行；</strong>）</p></li><li><p><strong>并行</strong>：同一时刻，多个指令在<strong>多个CPU</strong>上<strong>同时执行；</strong></p></li></ul><h2 id="多线程的实现方式">多线程的实现方式</h2><ul><li><p>实现方式一：自己定义一个继承自<code>Thread</code>的类，重写<code>run</code>方法；</p><pre><code class="language-java">public class Thread1 extends Thread&#123;    @Override    public void run() &#123;        for(int i=0;i&lt;10;i++)&#123;            System.out.println(getName() +&quot; hello world!&quot;);        &#125;    &#125;&#125;// 测试public class MyThread &#123;    public static void main(String[] args) &#123;        Thread1 t1 = new Thread1();        t1.setName(&quot;线程1&quot;);        Thread1 t2 = new Thread1();        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    &#125;&#125;// 运行结果线程2 hello world!线程1 hello world!线程1 hello world!线程1 hello world!线程1 hello world!线程2 hello world!线程2 hello world!线程2 hello world!线程1 hello world!线程2 hello world!线程1 hello world!线程2 hello world!线程1 hello world!线程2 hello world!线程1 hello world!线程2 hello world!线程1 hello world!线程2 hello world!线程1 hello world!线程2 hello world!</code></pre></li><li><p>实现方式二：</p><ul><li>自己定义一个类实现<code>Runnable</code>接口，重写<code>run</code>方法；</li><li>创建一个自己类的对象，创建Thread类的对象，并开启线程；</li></ul><pre><code class="language-java">public class Thread2 implements Runnable&#123;    @Override    public void run() &#123;        String name = Thread.currentThread().getName();//获取当前线程的name        for(int i=0;i&lt;10;i++)&#123;            System.out.println(name +&quot; hello world!&quot;);        &#125;    &#125;&#125;// 测试public class MyThread &#123;    public static void main(String[] args) &#123;        Thread2 thread = new Thread2();                Thread t1 = new Thread(thread);        Thread t2 = new Thread(thread);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    &#125;&#125;</code></pre></li><li><p>实现方式三：</p><ul><li>创建一个类实现<code>Callable</code>接口，重写<code>call</code>方法（有返回值，表示多线程的运行结果）；</li><li>创建自己类的对象；</li><li>创建<code>FutureTask</code>对象（用于管理多线程处理的结果）；</li><li>创建<code>Thread</code>类的对象，并启动线程；</li></ul><pre><code class="language-java">public class Thread3 implements Callable&lt;Integer&gt; &#123;    @Override    public Integer call() throws Exception &#123;        int sum = 0;        for(int i=0;i&lt;10;i++)&#123;            sum += i;        &#125;        return sum;    &#125;&#125;// 测试public class MyCallable &#123;    public static void main(String[] args) &#123;        Thread3 thread = new Thread3();                FutureTask&lt;Integer&gt; f = new FutureTask&lt;&gt;(thread);                Thread t1 = new Thread(f);        Thread t2 = new Thread(f);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();        int ans = f.get();    &#125;&#125;</code></pre></li></ul><h2 id="多线程的常用方法">多线程的常用方法</h2><pre><code class="language-java">public final void setName(String name); // 更改线程的名字public final String getName(); // 获取线程的名字public void start(); // 启动线程public static Thread currentThead(); // 获取正在执行的线程public final int getPriority(); // 获取当前线程优先级public final void setPriority(int newPriority); //设置线程的优先级（1~10）public static void sleep(long millis); // 睡眠指定时间，暂停运行public final void join(long millis); // 插入线程public static void yield(); //礼让线程</code></pre><h2 id="线程的生命周期">线程的生命周期</h2><p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230421121103828.png" alt="image-20230421121103828"></p><h2 id="线程的安全问题">线程的安全问题</h2><ul><li><p>竞态条件（Race Condition）</p><ul><li>多个线程同时对<strong>共享资源</strong>进行读写操作，导致数据不一致。</li><li>解决：同步机制（synchronized），锁（Lock），使用线程安全的数据结构（如ConcurrentHashMap）</li><li>同步代码块<ul><li><strong>锁对象一定要是唯一的</strong>，如果每个线程拥有一个不同的锁对象，则锁就失去了意义；</li><li>synchronized不要写在循环内，不然一个线程抢到执行权后，直到循环结束之前，其他线程没法进入；</li></ul></li></ul><pre><code class="language-java">//注：这里使用线程的第一种自定义方法public class MyThread extends Thread&#123;        // 加static关键字，表示共享ticket数据    static int ticket = 0;     // 锁对象必须是唯一的    // 加static关键字表示的MyThread创建的所有对象都共享同一个obj    static Object obj = new Object();    @Override    public void run() &#123;        while(true)&#123;            // 同步代码块            synchronized (obj)&#123;                if(ticket&lt;100)&#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        throw new RuntimeException(e);                    &#125;                    ticket++;                    System.out.println(getName()+&quot;正在卖第&quot;+ticket+&quot;张票！&quot;);                &#125;else&#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;</code></pre><ul><li>同步方法<ul><li>将同步代码块抽取出来形成一个方法，为这个方法上锁；</li></ul></li></ul><pre><code class="language-java">//注：这里使用线程的第二种自定义方法public class MyRunnable implements Runnable&#123;    int ticket = 0;// 不需要static关键字，Runnable对象只创建一次    @Override    public void run() &#123;        while(true)&#123;            if(memthod()) break;        &#125;    &#125;    // 同步方法    private synchronized boolean memthod() &#123;        if(ticket&lt;100)&#123;            try &#123;                Thread.sleep(100);            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125;            ticket++;            System.out.println(Thread.currentThread().getName()+&quot;正在卖第&quot;+ticket+&quot;张票！&quot;);        &#125;else&#123;            return true;        &#125;        return false;    &#125;&#125;</code></pre></li><li><p><strong>StringBulider</strong>&amp;<strong>StringBuffer</strong></p><ul><li><p><code>StringBuffer</code>和<code>StringBuilder</code>都是Java中用于处理<strong>可变字符串</strong>的类，它们的主要区别在于线程安全性和性能。</p></li><li><p><code>StringBuffer</code>是<strong>线程安全</strong>的，因此可以在多线程环境下使用。它的<strong>所有公共方法都是同步的</strong>，即在方法内部使用了synchronized关键字来确保线程安全。这种同步机制会带来一定的<strong>性能损失</strong>，因为多个线程需要竞争同一把锁，这会导致线程阻塞和上下文切换。因此，如果不需要在多线程环境下使用可变字符串，建议使用<code>StringBuilder</code>。</p></li><li><p><code>StringBuilder</code>是<strong>非线程安全</strong>的，因此不能在多线程环境下使用。它的所有公共方法都不是同步的，因此在单线程环境下使用<code>StringBuilder</code>比使用<code>StringBuffer</code>更加高效。</p></li></ul></li><li><p><strong>锁（Lock）</strong></p><pre><code class="language-java">public class MyThread extends Thread&#123;    static int ticket = 0;    static Lock lock = new ReentrantLock();    @Override    public void run() &#123;        while (true) &#123;            lock.lock(); // 上锁            try &#123;                if (ticket &lt; 100) &#123;                    Thread.sleep(100);                    ticket++;                    System.out.println(getName() + &quot;正在卖第&quot; + ticket + &quot;张票！&quot;);                &#125; else &#123;                    break;                &#125;            &#125; catch (InterruptedException e) &#123;                throw new RuntimeException(e);            &#125; finally &#123;                lock.unlock(); // 释放锁                                // 使用finally关键字，不管怎样都会被执行，防止线程跳出循环后未释放锁            &#125;        &#125;    &#125;&#125;</code></pre></li><li><p><strong>死锁</strong></p><ul><li>死锁是指两个或多个线程在互相持有对方所需要的资源时，都在等待对方先释放资源，导致程序无法继续执行的情况。</li><li>避免死锁的方法：<ul><li>避免使用多个锁：尽量减少线程需要持有的锁的数量，或使用更高级别的同步机制（如ReentrantLock）来避免死锁；</li><li>避免使用多个锁的嵌套；</li><li>超时等待：线程尝试获取锁时，设置一个超时时间，在等待超过一定时间后，放弃获取锁。</li></ul></li></ul></li><li><p><strong>等待唤醒机制</strong></p><ul><li><p>等待唤醒机制是一种用于线程间通信的机制，它允许一个线程等待另一个线程的通知，以便在特定时间点上恢复执行。</p></li><li><p>常用方法：</p><pre><code class="language-java">void wait();void notify();void notifyAll();</code></pre></li></ul></li></ul><h2 id="线程池">线程池</h2><ul><li>之前写多线程的弊端：线程用完之后就消失，浪费资源；</li><li>线程池是一种用于<strong>管理和重用线程</strong>的机制，它允许在应用程序中创建一组线程，并在需要时执行任务，而不需要频繁地创建和销毁线程。</li><li>线程池核心原理：<ul><li>创建一个池子，初始是空的；</li><li>提交任务时，池子创建一个新的线程对象，任务执行完毕后把线程还给池子，下次创建线程时不需要创建新的线程，直接复用已有的线程；</li><li>但是如果提交任务时线程池中没有空闲线程，也无法创建新的线程，任务就会等待；</li></ul></li></ul><pre><code class="language-java">public class ThreadPoolDemo &#123;    public static void main(String[] args) &#123;        // 创建一个没有上限的线程池对象//        ExecutorService pool = Executors.newCachedThreadPool();        // 创建一个有上限的线程池对象        ExecutorService pool = Executors.newFixedThreadPool(3);        // 提交任务        pool.submit(new MyThread());        pool.submit(new MyThread());        // 销毁线程池        pool.shutdown();    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><ul><li><p><code>Redis</code>（Remote Dictionary Server）是一个<strong>基于内存</strong>的<code>key-value</code>的结构数据库，它可以用作数据库，缓存和消息中间件。</p><ul><li><p>单线程，每个命令具备原子性</p></li><li><p>基于内存存储，读写性能高</p></li><li><p>适合存储热点数据（热点资讯，热点商品）</p></li></ul></li><li><p><code>Redis</code>是一种典型的<code>NoSql</code>数据库（非关系型数据库）；</p></li><li><p><code>Redis</code>所有的数据结构都以唯一的<code>key</code>字符串作为名称，然后通过唯一的<code>key</code>获取相应的<code>value</code>；不同数据结构之间的差异就在于<code>value</code>的数据结构的不同。</p></li></ul><h3 id="常用数据类型">常用数据类型</h3><ul><li>字符串（<code>string</code>）：普通字符串，常用；</li><li>哈希（<code>hash</code>）：适合存储对象；</li><li>列表（<code>list</code>）：按照插入元素顺序排序，可以有重复元素；</li><li>无序集合（<code>set</code>）：无序集合，没有重复元素；</li><li>有序集合（<code>sorted set</code>）：有序集合，没有重复元素；</li></ul><h2 id="常用命令">常用命令</h2><ul><li><p><code>String</code>操作命令</p><ul><li>Redis中的字符串是动态的可以修改的字符串，类似于<code>ArrayList</code>；</li></ul><pre><code class="language-sql">SET key valueGET keySETEX key seconds value  # 设置指定key的值，并将key的过期时间设为secondsSETNX key value  # 只有key不存在时设置key的值</code></pre></li><li><p><code>hash</code>操作命令</p><pre><code class="language-sql">HSET key field valueHGET key fieldHDEL key fieldHKEYS key   # 获取Hash表中所有字段HVALS key   # 获取Hash表中所有值HGETALL key  # 获取Hash表中指定key所有字段和值</code></pre></li><li><p><code>list</code>操作命令</p><pre><code class="language-sql">LPUSH key value1 [value2] # 将一个或多个元素插入列表头部LRANGE key start stop   # 获取指定范围内的元素RPOP key     # 移除并获取列表最后一个元素LLEN key     # 获取列表长度BRPOP key1 [key2] timeout  # 移出并获取列表最后一个元素</code></pre></li><li><p><code>set</code>操作命令</p><pre><code class="language-sql">SADD key memeber1 [memeber2] # 添加一个或多个成员SMEMBERS key         # 返回集合中所有元素SCARD key     # 获取集合中的成员数SREM key memeber1 [memeber2]   #移除一个或多个成员</code></pre></li><li><p><code>sorted set</code></p><p>每个元素都会关联一个 double 类型的分数。<code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><pre><code class="language-sql">ZADD key score member  # 添加成员或更新分数ZRANGE  key start stop [WITHSCORES] # 返回指定范围内的成员ZINCRBY key increment memeber # 对指定成员的分数加上incrementZREM key memeber # 移除成员</code></pre></li><li><p>通用命令</p><pre><code class="language-sql">KEYS pattern    # 查找所有符合的keyEXISTS key   # 检查key是否存在TYPE key  # 查看key对应的类型TTL key  #返回key的剩余生存时间(time to live),以秒为单位         # -1表示存活时间为永久DEL key  #删除key</code></pre></li></ul><h2 id="Java客户端工具">Java客户端工具</h2><h3 id="jedis">jedis</h3><h4 id="jedis配置">jedis配置</h4><p>jedis就是基于java语言的redis客户端，集成了redis的命令操作，提供了连接池管理。（线程不安全）</p><ul><li><p>引入依赖</p><pre><code class="language-xml">        &lt;dependency&gt;            &lt;groupId&gt;redis.clients&lt;/groupId&gt;            &lt;artifactId&gt;jedis&lt;/artifactId&gt;            &lt;version&gt;2.9.0&lt;/version&gt;        &lt;/dependency&gt;</code></pre></li><li><p>连接测试</p><pre><code class="language-java">public class JedisTest &#123;    private Jedis jedis;    // 执行测试文件前执行    @BeforeEach    void setUp()&#123;        // 1. 建立连接        jedis = new Jedis(&quot;127.0.0.1&quot;,6379);        // 2. 设置密码        jedis.auth(&quot;lm12138&quot;);        // 3. 选择库        jedis.select(0);    &#125;    @Test    public void test()&#123;        // 设置数据        String res = jedis.set(&quot;ming&quot;, &quot;22&quot;);        System.out.println(res);        // 读取数据        String value = jedis.get(&quot;ming&quot;);        System.out.println(value);    &#125;    // 释放缓存    @AfterEach    void close()&#123;        if(jedis!=null)&#123;            jedis.close();        &#125;    &#125;&#125;</code></pre></li></ul><h4 id="jedis连接池">jedis连接池</h4><p>jedis线程不安全，频繁的连接和释放连接会有损害性能，推荐用线程池；</p><pre><code class="language-java">public class JedisConnectionFactory &#123;    private static final JedisPool jedisPool;    static &#123;        // 配置连接池        JedisPoolConfig poolConfig = new JedisPoolConfig();        poolConfig.setMaxTotal(8);// 最大连接数        poolConfig.setMaxIdle(4); // 最大空闲连接数        poolConfig.setMinIdle(0); // 最小空闲连接        poolConfig.setMaxWaitMillis(1000); // 最大等待时间        // 创建连接池对象        jedisPool = new JedisPool(poolConfig,&quot;127.0.0.1&quot;,                6379,1000,&quot;lm12138&quot;);    &#125;    // 获取jedis对象    public static Jedis getJedis()&#123;        return jedisPool.getResource();    &#125;&#125;</code></pre><h3 id="spring-data-redis">spring-data-redis</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></p><blockquote><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png" alt="image-20220525140217446"></p><h4 id="基本配置">基本配置</h4><ul><li><p>引入依赖</p><pre><code class="language-xml">        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;            &lt;version&gt;2.11.1&lt;/version&gt;        &lt;/dependency&gt;</code></pre></li><li><p>配置信息</p><pre><code class="language-yaml">spring:  data:    redis:      host: 127.0.0.1      port: 6379      password: lm12138      lettuce:        pool:          max-active: 8          max-idle: 8          min-idle: 0          max-wait: 100ms</code></pre></li><li><p>测试连接</p><pre><code class="language-java">@SpringBootTestclass RedisDemoApplicationTests &#123;    @Autowired    private RedisTemplate redisTemplate;    @Test    void contextLoads() &#123;        redisTemplate.opsForValue().set(&quot;ming&quot;,21);        Object age = redisTemplate.opsForValue().get(&quot;ming&quot;);        System.out.println(age);    &#125;&#125;</code></pre></li></ul><h4 id="RedisSerializer配置">RedisSerializer配置</h4><hr><blockquote><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png" alt="image-20220525170205272"></p><p>**缺点：**可读性差，内存占用较大</p><ul><li><p>编写配置类</p><pre><code class="language-java">@Configurationpublic class RedisConfig &#123;    @Bean    public RedisTemplate&lt;String,Object&gt; redisTemplate(RedisConnectionFactory factory)&#123;        // 1.创建RedisTemplate对象        RedisTemplate&lt;String ,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        // 2.设置连接工厂        redisTemplate.setConnectionFactory(factory);        // 3.创建序列化对象        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();        // 4.设置key和hashKey采用String的序列化方式        redisTemplate.setKeySerializer(stringRedisSerializer);        redisTemplate.setHashKeySerializer(stringRedisSerializer);        // 5.设置value和hashValue采用json的序列化方式        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);        return redisTemplate;    &#125;&#125;</code></pre></li><li><p>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个<strong>对象</strong></p><pre><code class="language-java">@Testvoid testSaveUser() &#123;    redisTemplate.opsForValue().set(&quot;user:100&quot;, new User(&quot;ming&quot;, 21));    User user = (User) redisTemplate.opsForValue().get(&quot;user:100&quot;);    System.out.println(&quot;User = &quot; + user);&#125;</code></pre></li></ul><h4 id="StringRedisTemplate">StringRedisTemplate</h4><blockquote><p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png" alt="image-20220525172001057"></p><blockquote><p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p></blockquote><ul><li><p>我们可以直接编写一个测试类使用<code>StringRedisTemplate</code>来执行以下方法</p><pre><code class="language-java">@SpringBootTestclass RedisStringTemplateTest &#123;@Resourceprivate StringRedisTemplate stringRedisTemplate;@Testvoid testSaveUser() throws JsonProcessingException &#123;// 1.创建一个Json序列化对象ObjectMapper objectMapper = new ObjectMapper();// 2.将要存入的对象通过Json序列化对象转换为字符串String userJson1 = objectMapper.writeValueAsString(new User(&quot;Vz&quot;, 21));// 3.通过StringRedisTemplate将数据存入redisstringRedisTemplate.opsForValue().set(&quot;user:100&quot;,userJson1);// 4.通过key取出valueString userJson2 = stringRedisTemplate.opsForValue().get(&quot;user:100&quot;);// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象User user = objectMapper.readValue(userJson2, User.class);// 6.打印结果System.out.println(&quot;user = &quot; + user);&#125;&#125;</code></pre></li><li><p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li><li>缺点：占用内存空间，需要记录类的字节码</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol></li></ul><h2 id="缓存">缓存</h2><h3 id="简介-v2">简介</h3><p>缓存是数据交换得缓冲区（Cache），用于存储临时数据，一般读写性能较高；</p><ul><li><p>缓存的作用</p><ul><li>降低后端负载</li><li>提高读写速率，降低响应速率</li></ul></li><li><p>缓存的成本</p><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本（集群部署等）</li></ul></li><li><p>通常我们这样使用缓存：</p><ul><li>写请求只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul></li></ul><p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230712110056150.png" alt="image-20230712110056150"></p><p>​这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「<strong>热数据</strong>」，缓存利用率得以最大化。</p><h3 id="缓存更新策略">缓存更新策略</h3><ul><li><p>缓存更新策略</p><ul><li>内存淘汰：利用Redis的内存淘汰机制；</li><li>超时剔除：给缓存数据添加超时时间；</li><li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存；</li></ul></li><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多；</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（<strong>更优</strong>）</li></ul></li><li><p>如何保证缓存和数据库操作的原子性？</p><ul><li>单体系统，将缓存和数据库放在一个事务中；</li><li>分布式系统：利用TCC等分布式事务方案；</li></ul></li><li><p>这里存在<strong>数据一致性问题</strong>，当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。这两个操作并非是原子的，所以有先后顺序；</p><ul><li><p>先删除缓存，再更新数据库：</p><ul><li><p>初始化（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 删除缓存后（数据库：1 ，缓存：null）</p></li><li><p><em>线程2</em> 前来查询缓存未命中，查询数据库，并将查询到的数据写入缓存（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 再更新数据库（数据库：2 ，缓存：1）</p></li><li><p>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率较大</strong>，因为Redis的读写速度比数据库快很多，并发情况下很容易发生这种情况。</p></li></ul></li><li><p>先更新数据库，再删除缓存</p><ul><li>初始化，恰好缓存失效（数据库：1 ，缓存：null）</li><li><em>线程1</em> 查询缓存未命中并查询数据库（1）</li><li><em>线程2</em> 更新数据库（数据库：2 ，缓存：null）</li><li><em>线程2</em>  删除缓存（数据库：2 ，缓存：null）</li><li><em>线程1</em> 写入缓存（数据库：2 ，缓存：1）</li><li>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率很小</strong>（线程1之前缓存恰好失效；Redis写入速度很快，在其之前有线程插入并更新数据库的概率很小）</li></ul></li></ul></li><li><p>因此，缓存更新策略的最佳实践方案为：</p><ul><li>低一致性需求：使用Redis自带的内存淘汰机制；</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案；<ul><li>读操作：<ul><li>缓存命中则直接返回；</li><li>缓存未命中则直接查询数据库，并写入缓存，并设定超时时间；</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存；</li><li>要确保数据库与缓存操作的原子性；</li></ul></li></ul></li></ul></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul><li><p>缓存穿透是指客户端<strong>请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远都不会生效，这些请求都会到数据库。（可能会被无效请求恶意攻击）。</p></li><li><p>解决方案：</p><ul><li><p>缓存空对象：对于无效的请求，缓存一个null对象</p><ul><li><p>优点：实现简单，维护简单</p></li><li><p>缺点：</p><ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>请求与Redis缓存之间设置一布隆过滤器，由布隆过滤器判断请求数据是否存在，存在则放行，不存在则直接返回。</li><li>布隆过滤器并不是存储了所有数据，而是通过某种算法来判断请求数据是否存在。</li></ul></li></ul></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul><li>缓存雪崩是指 <strong>同一时段大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</li><li>解决方案：<ul><li>给不同的key添加随机失效时间；</li><li>利用Redis集群提高服务的可用性；</li><li>给缓存业务添加降级限流策略；</li><li>给业务添加多级缓存；</li></ul></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul><li><p>缓存击穿问题也被称为<strong>热点key</strong>问题，就是一个<strong>被高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求在瞬间给数据库带来巨大的冲击。</p></li><li><p>解决方案：</p><ul><li><p>互斥锁：查询缓存未命中时，先获取互斥锁，获取锁成功后查询数据库并重建缓存，写入缓存后再释放锁；这样，其他线程请求无法在缓存重建期间查询缓存。</p><p>线程需要等待，性能收到影响；可能有死锁风险。</p></li><li><p>逻辑过期：<strong>给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL</strong>。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。</p><ul><li>优点：<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点：<ul><li>不保证一致性(因为会返回过期数据)</li><li>有额外的内存消耗(同时缓存了逻辑过期时间的字段)</li><li>实现复杂</li></ul></li></ul></li></ul></li></ul><h2 id="秒杀">秒杀</h2><h3 id="分布式全局唯一ID">分布式全局唯一ID</h3><ul><li><p>**<em>UUID(通用唯一标识符)**表示一个128位长的唯一值。 它也被普遍称为</em>GUID(全球唯一标识符)。我们可以使用*UUID*类来生成随机文件名，会话或事务ID。 UUID的另一种流行用法是在数据库中生成主键值。<strong>有极小的概率会重复</strong>。</p></li><li><p><strong>雪花算法</strong></p><p>由64位<code>bit</code>字符组成（Long）<br>$$<br>0\quad \quad0000 … 0000\quad\quad\quad 000000 0000 \quad\quad 0000 0000 0000<br>$$<br>​                                                       <strong>符号位   时间戳：41 bit          机器ID：10 bit</strong>      <strong>12 bit 序列号</strong></p><ul><li><p>组成：</p><ul><li>符号位：1 bit，生成ID一般均为正数，因此为0；</li><li>时间戳：41 bit，单位为ms，可以使用约69年；</li><li>机器ID：10 bit，可以支持1024个分布式机器；</li><li>序列号：12 bit，表示每ms可以生成$2^{12}=1024$个不同ID；</li></ul></li><li><p>特点</p><ul><li>按时间递增</li><li>唯一性</li><li>生成效率高</li></ul></li></ul><pre><code class="language-java">/** * 生成全局唯一ID（** 雪花算法 **） */@Componentpublic class UIDWorker &#123;    // 开始时间戳    private static final long BEGIN_TIMESTAMP = 1692213900;    @Resource    private StringRedisTemplate stringRedisTemplate;    public Long nextId(String prefix)&#123;        // 生成时间戳        LocalDateTime now = LocalDateTime.now();        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);        long timestamp = nowSecond - BEGIN_TIMESTAMP;        // 机器ID        long machineId = 1;        // 生成序列号(通过Redis自增生成序列)        String nowDateTime = now.format(DateTimeFormatter.ofPattern(&quot;yyyy:MM:dd&quot;));        long increment = stringRedisTemplate.opsForValue()                         .increment(&quot;icr&quot; + prefix + &quot;:&quot; + nowDateTime);        // 拼接并返回        long id = timestamp &lt;&lt; 22 | machineId &lt;&lt; 12 | increment;        return id;    &#125;&#125;</code></pre></li><li><p>雪花算法的**时钟回拨 **问题</p><ul><li>由于雪花算法对于时钟特别敏感，因此如果时钟出现回拨现象，有可能导致获取的ID重复。</li><li>正常来说只要不是不是有人手贱或者出于泄愤的目的进行干扰，系统的时间漂移是一个在毫秒级别的极短的时间。因此可以在获取 ID 的时候，记录一下当前的时间戳。然后在下一次过来获取的时候，<strong>对比一下当前时间戳和上次记录的时间戳，如果发现当前时间戳小于上次记录的时间戳，所以出现了时钟回拨现象，对外抛出异常，本次 ID 获取失败</strong>。理论上当前时间戳会很快的追赶上上次记录的时间戳。</li></ul></li></ul><h3 id="超卖问题">超卖问题</h3><ul><li><p>高并发场景下，做个线程交叉执行可能会出现超卖问题；</p><ul><li><p><code>初始</code>：库存：1；</p></li><li><p><code>线程1</code>：查询库存为1；</p></li><li><p><code>线程2</code>：查询库存为1；</p></li><li><p><code>线程1</code>：扣减库存，下单成功；</p></li><li><p><code>线程2</code>：扣减库存，下单成功；</p></li><li><p><code>库存</code>：<strong>-1</strong>（出现超买问题）；</p></li></ul></li><li><p>解决方案：加锁</p></li><li><p><strong>悲观锁</strong></p><ul><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li><li>例如<code>Synchronized</code>，<code>Lock</code>都属于悲观锁；</li><li>特点：简单直接，性能差；</li></ul></li><li><p><strong>乐观锁</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，只是<strong>在更新数据时判断是否有其他线程对数据进行了修改</strong>。<ul><li>如果没有，则认为是安全的，更新数据；</li><li>如果有，则重试或者抛出异常；</li></ul></li><li>特点：性能好，但容易出现成功率过低的问题；</li></ul></li><li><p>乐观锁的实现方式</p><ul><li><p><strong>版本号法</strong>：为资源添加一个version版本号，当修改资源后version就加一，修改资源前判断版本号是否被修改；</p><ul><li><p><code>初始</code>：库存：1；（ version = 1 ）</p></li><li><p><code>线程1</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程2</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程1</code>：扣减库存，下单成功；（ version = 2 ）</p></li><li><p><code>线程2</code>：此时发现version与查询时的不同，说明资源被其他线程修改，下单失败；</p></li></ul></li><li><p><strong>CAS</strong>（<code>Compare And Swap</code>）：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。<br>（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。<br>（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p><pre><code class="language-java">// 扣减库存boolean isSuccess = seckillVoucherService.update()        .setSql(&quot;stock = stock - 1&quot;) // set stock = stock - 1        .eq(&quot;voucher_id&quot;, voucherId) // where ...        .eq(&quot;stock&quot;,voucher.getStock())        .update();</code></pre><p>该方法能够解决超卖问题，但是高并发场景下成功率过低，影响业务；</p></li></ul></li></ul><h3 id="一人一单">一人一单</h3><ul><li><p>业务场景下，同一个用户对同一优惠券只能下一次单。（抵制黄牛！）</p></li><li><p>加<code>sycronized</code>锁实现</p><pre><code class="language-java">@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    // 获取用户Id    Long userId = UserHolder.getUser().getId();    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串    synchronized (userId.toString().intern())&#123;        // 一人一单        Long count = query().eq(&quot;user_id&quot;, userId).eq(&quot;voucher_id&quot;, voucherId).count();        if(count&gt;0)&#123;            return Result.fail(&quot;用户已经抢购过该优惠券！&quot;);        &#125;    &#125;&#125;</code></pre></li><li><p>以上代码可能会导致线程安全问题</p><pre><code class="language-java">@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    ...    synchronized (userId.toString().intern())&#123;        // 一人一单        ...    &#125;    // 锁释放，此时其他线程可以进来    // 而事务尚未提交，线程不安全！&#125;</code></pre></li><li><p>优化</p><pre><code class="language-java">@Overridepublic Result seckillVoucher(Long voucherId) &#123;    Long userId = UserHolder.getUser().getId();    // toString()底层每次调用都会重新创建一个String对象，导致synchronized失效    // 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串    synchronized (userId.toString().intern()) &#123;        return this.createVoucherOrder(voucherId); // **事务失效** 问题        // 事务已提交    &#125; // 释放锁&#125;@Transactionalpublic Result createVoucherOrder(Long voucherId) &#123;    ...&#125;</code></pre></li><li><p>以上有可能导致<strong>事务失效</strong>问题，解决方案如下：</p><pre><code class="language-java">Long userId = UserHolder.getUser().getId();synchronized (userId.toString().intern()) &#123;    // 拿到当前对象的代理对象    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();    return proxy.createVoucherOrder(voucherId);&#125;</code></pre></li></ul><h2 id="分布式锁">分布式锁</h2><h3 id="简介-v3">简介</h3><ul><li><p><code>sycronized</code>只能在一个<code>JVM</code>内部实现不同线程之间的互斥，集群下可能出现线程安全问题</p></li><li><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见的互斥锁。</p></li><li><p>特点：</p><ul><li>多进程可见</li><li>互斥</li><li>高性能</li><li>高可用</li><li>安全性</li></ul></li><li><p>实现方式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身的互斥锁机制</td><td style="text-align:center">利用setnx命令</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超时时间，到期释放</td></tr></tbody></table></li></ul><h3 id="基于Redis实现分布式锁">基于Redis实现分布式锁</h3><ul><li><p>获取锁</p><pre><code class="language-sql"># 利用setnx的互斥特性SETNX lock thread1# 添加锁过期时间，避免服务宕机引起的死锁EXPIRE lock 30</code></pre><p>以上两条命令不具备原子性，可以使用以下命令：</p><pre><code class="language-sql">SET lock thread NX EX 30</code></pre></li><li><p>释放锁</p><p>手动释放或超时释放</p><pre><code class="language-sql"># 删除即可DEL lock</code></pre></li><li><p>实现Redis分布式锁</p><pre><code class="language-java">public interface ILock &#123;    /**     * 尝试获取锁     * @param timeoutSec 锁持有的超时时间，过期后自动释放     * @return true代表获取锁成功; false代表获取锁失败     */    boolean tryLock(long timeoutSec);    /**     * 释放锁     */    void unlock();&#125;</code></pre><pre><code class="language-java">public class SimpleRedisLock implements ILock &#123;    private StringRedisTemplate stringRedisTemplate;    private String lockName;    private static final String ID_PREFIX = UUID.randomUUID(true) + &quot;-&quot;;    private static final String LOCK_PREFIX = &quot;lock_&quot;;    public SimpleRedisLock(StringRedisTemplate stringRedisTemplate, String lockName) &#123;        this.lockName = lockName;        this.stringRedisTemplate = stringRedisTemplate;    &#125;    @Override    public boolean tryLock(long timeoutSec) &#123;         /*          获取锁时存入线程标识          解决分布式锁 **误删** 问题         */                // 获取线程标示        String threadId = ID_PREFIX + Thread.currentThread().getId();        // 获取锁        Boolean isSuccess = stringRedisTemplate.opsForValue()                .setIfAbsent(LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.MINUTES);//        return isSuccess;  // 可能会在自动拆箱过程中出现空指针        return Boolean.TRUE.equals(isSuccess);    &#125;    @Override    public void unlock() &#123;        /*         释放锁时先获取锁中的线程标识，判断是否与当前标识相同         如果一致则释放锁，不一致则不释放锁；         */        String threadId = ID_PREFIX + Thread.currentThread().getId();        String id = stringRedisTemplate.opsForValue().get(LOCK_PREFIX + lockName);        if (threadId.equals(id)) &#123;            stringRedisTemplate.delete(LOCK_PREFIX + lockName);        &#125;    &#125;&#125;</code></pre></li><li><p>解决分布式锁 <strong>误删</strong> 问题</p><ul><li><p><code>线程1</code>：获取锁成功（<code>lock1</code>），执行任务；（任务时间较久或宕机）</p></li><li><p>超过超时时间，锁自动释放；</p></li><li><p><code>线程2</code>：获取锁成功（<code>lock1</code>），执行任务；</p></li><li><p><code>线程1</code>：任务执行成功，释放锁；</p></li><li><p>此时<code>线程2</code>还未执行完毕，<code>线程 1 </code>误删了<code>线程 2 </code>的锁；</p></li></ul><p>解决方案：</p></li><li><p>获取锁时存入线程标识（可以使用<code>UUID</code>）；</p><ul><li>释放锁时先获取锁中的线程标识，判断是否与当前标识相同，如果一致则释放锁，不一致则不释放锁；</li></ul></li><li><p>分布式锁的<strong>原子性</strong></p><ul><li><p>由于上述判断线程标识与释放锁的操作不具备原子性，因此可能会有线程安全问题；</p></li><li><p>Redis提供了lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性；</p><pre><code class="language-lua">EVAL script key [key ...]  # 执行脚本</code></pre></li></ul></li><li><p>实现思路总结</p><ul><li>利用<code>SETNX</code>命令获取锁，设置过期时间，并存入线程标识；</li><li>释放锁时先判断标识是否一致，一致则删除锁；</li></ul></li><li><p>基于<code>SETNX</code>实现分布式锁的问题：</p><ul><li>不可重入：同一个线程无法多次获取同一把锁；</li><li>不可重试：获取锁失败时返回false，没有重试机制；</li><li>超时释放：超时释放虽然可以避免死锁；设置超时时间过短，若业务执行时间过长，也会导致锁释放，存在安全隐患；设置超时时间过长，导致业务停滞；</li><li>主从一致性</li></ul></li></ul><h3 id="Redisson">Redisson</h3><ul><li><p><strong>Redisson使用</strong></p><ul><li><p>引入依赖</p><pre><code class="language-xml">        &lt;dependency&gt;            &lt;groupId&gt;org.redisson&lt;/groupId&gt;            &lt;artifactId&gt;redisson&lt;/artifactId&gt;            &lt;version&gt;3.13.6&lt;/version&gt;        &lt;/dependency&gt;</code></pre></li><li><p>配置文件</p><pre><code class="language-java">// Reddision 配置@Configurationpublic class RedissonConfig &#123;    @Bean    public RedissonClient redissonClient() &#123;        // 配置        Config config = new Config();        // 单节点        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;).setPassword(&quot;lm12138&quot;);        // 创建RedissonClient对象        return Redisson.create(config);    &#125;&#125;</code></pre></li><li><p>使用 <code>Redisson</code></p><pre><code class="language-java">@Resourceprivate RedissonClient redissonClient;@Testprivate void testRedisson() &#123;    // 获取锁，指定锁名称    RLock lock = redissonClient.getLock(&quot;anyLock&quot;);    boolean isLock = lock.tryLock();    // 判断是否获取锁成功    if(!isLock)&#123;        try &#123;           // 业务逻辑        &#125; finally &#123;          // 释放锁          lock.unlock();        &#125;    &#125;&#125;</code></pre></li></ul></li></ul><h3 id="秒杀优化">秒杀优化</h3><ul><li><p>秒杀流程回顾：</p><ul><li>查询优惠券（数据库）</li><li>判断秒杀库存</li><li>查询订单（数据库）</li><li>校验一人一单</li><li>减库存（数据库）</li><li>创建订单（数据库）</li></ul></li><li><p><strong>异步秒杀</strong>：</p><ul><li>新增秒杀优惠券的同时，将秒杀库存保存到Redis中；</li><li>基于lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2023/06/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础">MySQL基础</h2><ul><li><p>数据库：保存有组织的数据库的容器；</p><p>数据库管理系统（DBMS）：数据库软件，通过DBMS来创建和操纵数据库；</p></li><li><p>关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）；常见的关系型数据库有<strong>MySQL</strong>、PostgreSQL、Oracle、SQL Server、SQLite；</p></li><li><p><strong>连接器</strong>：与数据库建立连接；</p></li><li><p><strong>连接池</strong></p><ul><li><p>背景：传统的数据库连接方式是，用户每次请求都要向数据库获取连接，而数据库连接的创建和关闭需要一定的开销。<strong>频繁的建立、关闭数据库，会极大的降低系统的性能，增大系统的开销</strong>，甚至成为系统的瓶颈。</p></li><li><p>MySQL连接池是一个数据库连接管理器，它允许应用程序在需要时从预定义的一组连接中获取数据库连接，而不是为每个请求创建一个新的连接。这有助于<strong>减少应用程序的资源占用，提高数据库性能和可伸缩性</strong>。</p></li><li><p>连接池管理连接的生命周期，并确保连接在不再需要时被正确回收，主要包括以下组件：</p><ul><li>连接池管理器：负责连接的创建，回收和管理。</li><li>连接池配置：<ol><li><strong>最大连接数</strong>：连接池中允许的最大连接数；</li><li><strong>连接等待超时时间</strong>：连接池中连接请求的等待时间；</li><li>**连接验证：**连接池可以通过连接验证来确保连接池中的连接仍然有效。</li></ol></li></ul></li></ul></li><li><p><strong>InnoDB</strong>存储引擎</p><p><img src="/images/mysql01.png" alt=""></p></li><li><p>MySQL语句</p><pre><code class="language-mysql">use database; // 选择数据库# 检索select distinct username from users; # 检索不同的行select distinct username from users limit 5; # 返回不多于5行select distinct username from users limit 5,3; # 返回从行5开始的3行# 排序select username from users order by username; # 按username的字母顺序升序排序select username from users order by username desc; # 降序select id,username,email from users order by id,username; # 对id相同的行使用username排序# 过滤数据select username from users where userid &lt; 5 or userid &gt; 10;select username from users where userid between 3 and 5;select username from users where username is null # 空值检查select username from users where userid &lt; 5 and username = 'xxx';select username from users where id in(10,12);# 使用通配符过滤# 百分号( % )通配符：表示任意字符出现任意次数select id,uername from users where username like 'li%'; #检索以li起头的词# 下划线( _ )通配符：表示任意字符出现一次，即只匹配一个字符select id,uername from users where username like '_i ming'; #检索Xi ming 格式的词# 使用正则表达式搜索select id from users where regexp '.000'; # .表示任意字符select id from users where regexp '1000 | 2000';# 拼接字段select Concat(information,'(',age,')') from users; # 输出实例：ming(20)# 使用别名select username as customer_name from users;# 汇总数据# AVG() COUNT() MAX() MIN() SUM()select AVG(price) as avg_price from products;select COUNT(*) as num_pro from products; # 对表中的所有行的数目计数（包括NULL）                                         # COUNT(COLUMN)：对特定的列中具有值的行进行计数，忽略NULL                                         # SUM(COLUMN)：返回指定列值的和# 插入数据insert into users(username,email) values('mike','mike@test.com'); insert into users(username,email) values('mike','mike@test.com'), values('jack','jack@test.com'); # 列名和次序相同时，可以同时插入多行# 更新数据update usersset username = 'xxx',email = 'xx@xxx.com'where id = 1000;# 删除数据delete from userswhere id = 1000;# !!! 如果不带where字句，则会删除或更新所有行</code></pre></li><li><p><strong>创建和操纵表</strong></p><pre><code class="language-mysql"># 创建表create table users(    id            int        not NULL auto_increment, # 自动增量    username      char(50)   not NULL,    age           int        not NULL default 18, #使用默认值    email         char(50)   NULL,    passward      char(50)   NULL,    primary key(id) # 定义主键)engine=InnoDB;# 更新表alter table usersadd phone_number char(20); # 表中插入新的列，常用来添加外键alter table usersdrop column phone_number;# 删除表中的列# 删除表drop table users;</code></pre></li><li><p><strong>子查询</strong></p><ul><li><p><strong>查询</strong>：任何sql语句都是查询，但术语一般指select；</p></li><li><p>子查询：即嵌套在其他查询中的查询；</p><pre><code class="language-mysql">select username from users where id in( select id from users            where username like 'li%'); # 由内向外执行</code></pre></li></ul></li><li><p>联结表</p><ul><li><strong>外键</strong>（foreign key）：外键为某个表中的一列，它包含了另一个表的主键值；</li><li>如果数据从存储在多个表中，使用<strong>联结</strong>检索数据</li></ul><pre><code class="language-mysql"># users 和 products两个表select username,prod_name,prod_pricefrom users,productswhere users.prod_id = products.prod_id  # 为避免歧义，使用完全限定列名order by username,prod_name;</code></pre></li><li><p>视图</p><ul><li><p>视图是一种虚拟的表格，它<strong>并不真实存在于数据库中</strong>，但可以像真实的表格一样被查询、更新和操作。</p></li><li><p>特点：</p><ul><li><p>视图是虚拟的，不实际存在于数据库中；</p></li><li><p>隐藏底层数据表中的某些列或行，从而简化复杂的SQL操作；</p></li><li><p>加强数据的安全性，防止用户对敏感数据进行误操作；</p></li></ul></li></ul></li><li><p>使用存储过程</p><ul><li>存储过程：为以后使用而保存的一条或多条MySQL语句的集合。</li><li>特点：<ul><li>可重复使用；</li><li>提高性能；</li><li>安全性高；</li><li>支持事务；</li></ul></li><li>简单来讲，就是数据库 SQL 语言层面的代码封装与重用；</li></ul></li><li><p>使用游标</p><ul><li>游标（Cursor）是一种数据库对象，用于在SQL语句执行过程中，对结果集进行逐行处理。游标可以看作是一个指向结果集中某一行的指针，程序可以使用游标来逐行读取或更新结果集中的数据。</li><li>MySQL游标<strong>只能用于存储过程</strong>；</li></ul><pre><code class="language-mysql">-- 定义存储过程CREATE PROCEDURE count_product_sales()BEGIN    -- 定义游标    DECLARE cur CURSOR FOR SELECT product_id FROM product;    -- 定义变量    DECLARE product_id INT;    DECLARE sales_count INT;    -- 打开游标    OPEN cur;    -- 循环读取数据    WHILE TRUE DO        -- 读取数据        FETCH cur INTO product_id;        -- 判断是否读取完毕        IF (SQLSTATE = '02000') THEN            LEAVE WHILE;        END IF;        -- 计算销售数量        SELECT COUNT(*) INTO sales_count FROM order WHERE product_id = cur_product_id;        -- 更新产品表格        UPDATE product SET sales_count = sales_count + sales_count WHERE id = cur_product_id;    END WHILE;    -- 关闭游标    CLOSE cur;    -- 销毁游标    DEALLOCATE cur;END</code></pre></li><li><p>管理事务处理</p><ul><li><p><strong>事务处理</strong>：是一种机制，用来维护数据的完整性，它保证成段的MySQL操作要么完全执行，要么完全不执行。（要么成功，要么不成功）</p></li><li><p>关键词：</p><ul><li>事务（transaction）：指一组SQL语句；</li><li>回退（rollback）：撤销指定SQL语句的过程；</li><li>提交（commit）：指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）：事务处理中设置的临时占位符；</li></ul></li><li><p>使用<code>rollback</code></p><pre><code class="language-mysql">start transaction;delete from users;rollback; # 回退 start transaction 之后的所有语句</code></pre><p>显然，<code>rollback</code>只能在一个事务内使用；</p><p>可以回退<code>insert</code>，<code>update</code>, <code>delete</code>语句，不能回退<code>select</code> 语句（也没意义）。</p></li><li><p>使用<code>commit</code></p><ul><li>一般的MySQL语句都是针对数据库表执行和操作的，提交操作是自动的，即<strong>隐含提交</strong>；</li><li>事务处理块中必须进行明确的提交，使用<code>commit</code></li></ul><pre><code class="language-mysql">start transaction;delete from users where id = 1;delete from articles where id = 1;commit; # 如果以上某条语句失败，则commit语句失效</code></pre></li><li><p><strong>隐含事务关闭</strong>：当<code>rollback</code> 和<code>commit</code>执行后，事务会自动关闭（将来的操作变为隐含提交）</p></li><li><p>使用<code>savepoint</code></p><pre><code class="language-mysql">start transaction;delete from users where id = 1;savepoint delete1;delete from articles where id = 1;rollback to delete1;</code></pre></li></ul></li></ul><h2 id="MySQL存储引擎">MySQL存储引擎</h2><ul><li><p><strong>InnoDB存储引擎</strong>简介：</p><ul><li>特点：<strong>支持事务，行锁设计，支持外键，支持非锁定读；</strong></li><li>将数据存放在一个逻辑的表空间中，由InnoDB自身管理；将InnoDB存储引擎的表单独存放到一个独立的 <code>ibd </code>文件中。</li><li>InnoDB通过使用多版本并发控制（<strong>MVCC</strong>）来获得高并发性；</li><li>实现了SQL标准的四种隔离级别，默认为<code>REPEATABLE</code>级别;</li><li>使用一种被称为<code>next-key locking</code> 的策略来避免幻读（<code>phantom</code>）现象的产生。</li><li>提供了插入缓存（<code>insert buffer</code>），二次写（<code>double write</code>），自适应哈希索引（<code>adaptive hash index</code>），预读（<code>read ahead</code>）等高性能和高可用的功能。</li></ul></li><li><p><strong>InnoDB体系架构</strong></p><p><img src="/images/mysql02.png" alt=""></p><ul><li><p><strong>内存池</strong>：</p><ul><li>维护进程和线程需要访问的多个内部数据结构；</li><li>缓存磁盘上的数据，在磁盘文件被修改之前进行缓存；</li><li>重做日志（<code>redo log</code>）缓存；</li></ul></li><li><p><strong>后台线程：<strong>InnoDB是</strong>多线程</strong>的模型，因此有多个不同的后台进程，负责处理不同任务。</p><ul><li>主要作用：负责刷新内存池中的数据；将已修改的文件刷新到磁盘文件；保证在数据库发生异常的情况下InnoDB能恢复到正常的状态。</li><li><code>Master Thread</code>：负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，包括脏页的刷新，合并插入缓存，UNDO页回收；</li><li><code>IO Thread</code>：负责IO请求的回调处理；</li><li><code>Purge Thread</code>：回收已经使用并分配的UNDO页；设置purge Thread可以减轻Master Thread的工作；</li><li><code>Page Cleaner Thread</code>：脏页的刷新操作；</li></ul></li><li><p>内存</p><ul><li><p><strong>缓冲池</strong>：一块内存区域，磁盘读取较慢，因此数据库进行读取页操作时，如果该页在缓冲池中，则称该页被命中，直接读取该页；否则，读取磁盘上的页；<strong>InnoDB存储引擎中，缓冲池中页的大小默认为16KB</strong>；</p><p><strong>缓冲池的设计目的是为了协调CPU速度与磁盘速度之间的鸿沟</strong>。</p></li><li><p>缓冲池的管理：<strong>LRU</strong>（Latest Recently Used）即最频繁使用的页在LRU列表的前端，而最少使用的在尾端；</p></li><li><p>LRU列表中的页被修改之后，称该页为<strong>脏页</strong>（dirty page），即此时<strong>缓冲池中的页和磁盘上的页的数据产生不一致</strong>。</p><p>此时数据库会<strong>通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘</strong>；</p></li><li><p><strong>重做日志缓冲</strong>：将重做日志信息按一定频率刷新到重做日志文件中；</p></li></ul></li><li><p><code>CheckPoint</code>技术</p><ul><li>为了避免数据丢失的情况发生，当前事务数据库系统普遍采用了<strong>Write Ahead Log</strong>的策略，即<strong>当前事务提交时，先写重做日志，再修改页。</strong> 当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。</li></ul></li></ul></li><li><p><strong>索引</strong></p><ul><li><p>索引是一种用于快速查询和检索数据的<strong>数据结构</strong>，其本质可以看成是一种排序好的数据结构。</p></li><li><p>分类</p><ul><li>按数据结构：哈希索引，B+树索引，B树索引；</li><li>按底层存储方式：聚集索引，非聚集索引；</li><li>按应用维度：主键索引，二级索引；</li></ul></li><li><p>索引优缺点：</p><ul><li>优点：加快数据检索速度；创建唯一索引可以保证数据唯一性；</li><li>缺点：数据更新时，索引也需要更新；耗费一定空间；</li></ul></li><li><p><strong>哈希索引</strong></p><ul><li><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，时间复杂度接近O(1)。</p><pre><code class="language-java">hash = hashfunc(key)index = hash % array_size</code></pre><p>哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。</p></li><li><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“<strong>均匀地</strong>”将数据分布在整个可能的哈希值集合中。</p></li><li><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？<strong>主要是因为 Hash 索引</strong>不支持顺序和范围查询</strong>。</p></li></ul></li><li><p><strong>B树&amp;B+树</strong></p><ul><li><strong>B 树&amp; B+树两者有何异同呢？</strong><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树<strong>只有叶子节点存放 key 和 data</strong>，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的<strong>顺序检索</strong>很明显。</li></ul></li></ul></li><li><p><strong>主键索引（primary key）</strong></p><ul><li>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</li><li>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</li></ul></li><li><p>二级索引（辅助索引）</p><ul><li>二级索引的叶子节点存储的数据是主键，也就是说通过<strong>二级索引可以定位主键的位置</strong>。</li><li>分类：<ul><li><strong>唯一索引</strong>(Unique Key)：唯一索引的属性列<strong>不能出现重复的数据</strong>，但是<strong>允许数据为 NULL</strong>，一张表<strong>允许创建多个</strong>唯一索引。 建立唯一索引的目的是为了该属性列的<strong>数据的唯一性</strong>。</li><li>普通索引(Index)：普通索引的唯一作用就是为了<strong>快速查询数据</strong>，一张表<strong>允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li>前缀索引(Prefix)：只适用于字符串类型的数据。</li><li>全文索引(Full Text)：为了检索大文本数据中的关键字的信息。</li></ul></li></ul></li><li><p>聚集索引</p><ul><li>聚集索引即<strong>索引结构和数据一起存放的索引</strong>，并不是一种单独的索引类型。InnoDB 中的<strong>主键索引</strong>就属于聚簇索引。</li><li>优缺点<ul><li>优点：查询速度快；对于主键的排序查找和范围查找速度非常快；叶子节点的数据即用户所需数据；</li><li>缺点：如果索引数据不是有序的，需要在插入时进行排序；</li></ul></li></ul></li><li><p>非聚集索引</p><ul><li>非聚集索引即<strong>索引结构和数据分开存放</strong>的索引，并不是一种单独的索引类型。<strong>二级索引</strong>就属于非聚簇索引。</li><li>优缺点<ul><li>优点：由于叶子节点不存放数据，<strong>更新代价比聚集索引要小</strong> ；</li><li>缺点：<strong>需要二次查询</strong>，先找到主键，再根据主键找到数据；</li></ul></li></ul></li><li><p><strong>自适应哈希索引</strong></p><ul><li>数据库本身创建并使用的；</li><li><strong>适合用于等值查询，对于范围查询无能为力；</strong></li></ul></li><li><p>使用索引的一些tips：</p><ul><li>选择合适的字段作为索引：<ul><li>尽量不为Null；</li><li>被频繁查询的字段；</li><li>频繁需要排序的字段，可以利用索引的排序，加快排序速度；</li><li>避免使用频繁更新的字段，因为维护索引的成本也不小；</li></ul></li></ul></li></ul></li><li><p><strong>锁(Lock)</strong></p><ul><li><p>锁机制为了支持<strong>对共享资源进行并发访问，提供数据的一致性和完整性</strong>；</p></li><li><p>lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock的对象仅在事务<code>commit</code>或<code>rollback</code>后进行释放。</p></li><li><p><strong>行级锁</strong></p><ul><li><p><strong>共享锁</strong>（S Lock）：允许事务<strong>读</strong>一行数据；</p></li><li><p><strong>排他锁</strong>（X Lock）：允许事务<strong>删除或更新</strong>一行事务；</p></li><li><p>当一个事务锁定一个行时，其他事务也可以在该行上进行读取操作（<strong>锁兼容</strong>），但是不能进行修改操作（<strong>锁不兼容</strong>），直到持有锁的事务提交或回滚。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">X</th><th style="text-align:center">S</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">不兼容</td><td style="text-align:center">不兼容</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">不兼容</td><td style="text-align:center">兼容</td></tr></tbody></table></li></ul></li><li><p><strong>意向锁</strong></p><ul><li>数据库的层次结构：数据库 $\rightarrow$ 表 $\rightarrow$ 页 $\rightarrow$ 记录(Row)      (粒度：粗 $\rightarrow$ 细)</li><li>意向锁意味着事务希望在更细粒度上进行上锁；</li><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁；（多行）</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁；（多行）</li><li><strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong></li></ul></li><li><p><strong>一致性非锁定读</strong></p><ul><li>如果读取的行正在执行删除或更新操作，这时<strong>不需要等待行上X锁的释放</strong>，而是读取行的一个<strong>快照数据</strong>（即存储在undo log 中的该行的历史数据）</li><li>一个行记录可能有不止一个快照数据，一般称之为行多版本技术；由此带来的并发控制，称为<strong>多版本并发控制(Multi Version Concurrency Control, MVCC)</strong></li></ul></li><li><p><strong>事务隔离级别</strong></p><ul><li><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong>(默认配置) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">READ-UNCOMMITTED</th><th style="text-align:center">READ-COMMITTED</th><th style="text-align:center">REPEATABLE-READ</th><th style="text-align:center">SERIALIZABLE</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center"></td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">解决</td></tr></tbody></table><p>！！！<strong>从左到右，隔离级别越高，并发性能越差</strong>；</p></li><li><p>InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以<strong>解决幻读</strong>问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong> ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul></li></ul></li><li><p><strong>死锁</strong>：</p><ul><li><strong>多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象</strong>；</li><li>解决死锁最简单的方式：<strong>设置超时</strong>；</li></ul></li><li><p><strong>乐观锁和悲观锁</strong></p><ul><li>乐观锁和悲观锁都是并发控制的技术，用于在多个线程或进程同时访问共享资源时保证数据的一致性和完整性。</li><li><strong>悲观锁</strong>认为在并发访问情况下，数据很可能会被其他线程修改，所以在<strong>访问共享资源之前先获取锁，防止其他线程同时修改，从而保证数据的一致性</strong>。悲观锁的实现方式包括数据库中的行级锁、表级锁、读写锁等。</li><li><strong>乐观锁</strong>则认为在并发访问情况下，数据很少被其他线程修改，所以<strong>不需要在访问共享资源之前获取锁，而是在更新数据时检查数据是否被其他线程修改过</strong>，如果没有则更新，否则放弃更新。乐观锁的实现方式包括版本号控制、时间戳控制等。</li><li><strong>悲观锁在高并发场景下会导致性能瓶颈，因为获取锁需要等待其他线程释放锁</strong>，而乐观锁则可以避免这种等待，但是<strong>在数据竞争激烈的情况下，乐观锁的重试机制会导致性能下降。</strong></li></ul></li></ul></li><li><p><strong>事务</strong></p><ul><li><strong>四大特性（ACID）</strong><ul><li><strong>原子性（Atomicity）</strong><ul><li>事务中的所有操作需要像原子一样不可分割，要么全部执行成功，要么全部失败；</li><li>实现：<strong>undo log</strong> 机制；</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>数据库从一种状态转变为另一种一致的状态；</li><li>如果某个操作失败了，系统可以自动撤销事务；</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>多个事务执行时彼此隔离，不可以互相干扰；</li><li>写+写隔离：<strong>锁机制</strong>；</li><li>写+读隔离：<strong>MVCC</strong>；</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>事务一旦提交，其结果的就是永久性的；</li></ul></li></ul></li><li><strong>三大问题</strong><ul><li><strong>脏读</strong>：事务A读取(<code>SELECT</code>)到了事务B未提交的数据；</li><li><strong>不可重复读</strong>：事务A执行过程中，对同一个数据进行了两次读取(<code>SELECT</code>)，在这两次读取之间，事务B对该数据进行了更新(<code>UPDATE</code>)并完整提交，导致事务A两次读取到的数据不一致；</li><li><strong>幻读</strong>：事务A执行过程中，对同一个集合数据进行两次读取(<code>COUNT</code>)，在这两次读取之间，事务B在该集合中增加(<code>INSERT</code>)或删除(<code>DELETE</code>)了部分数据，导致事务A两次读取到的行数据不一致；</li></ul></li><li><strong>事务的实现</strong><ul><li><strong>Redo Log</strong><ul><li><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</li><li>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的<strong>持久性</strong>与完整性。</li></ul></li><li><strong>Undo Log</strong><ul><li>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过**回滚日志（undo log）**实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li><li>简单来说，有两个作用：<ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读；</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo搭建个人博客</title>
      <link href="/2023/06/28/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/06/28/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备">环境准备</h2><ul><li><p>安装<code>node.js</code></p><pre><code class="language-shell">sudo apt updatesudo apt install nodejs npm</code></pre></li><li><p>查看版本</p><pre><code class="language-shell">node -vnpm -v</code></pre></li></ul><h2 id="搭建博客">搭建博客</h2><ul><li><p>安装<code>hexo</code>框架</p><pre><code class="language-shell">npm install -g hexo-clihexo -v # 查看版本</code></pre></li><li><p>创建博客的根目录</p><pre><code class="language-shell">mkdir blogcd blog</code></pre></li><li><p>搭建<code>hexo</code>博客</p><pre><code class="language-shell">sudo hexo init</code></pre></li><li><p>本地端口启动博客！</p><pre><code class="language-shell">hexo s</code></pre></li><li><p>创建博客</p><pre><code class="language-shell">hexo new &quot;My first Post&quot; # 创建新博客hexo clean # 清理hexo generate # 生成</code></pre></li></ul><h2 id="部署到远端">部署到远端</h2><ul><li><p>部署到gitee/github</p><p>创建一个新的仓库，<a href="http://YourGithubName.github.io">YourGithubName.github.io</a>（必须一致！）</p><pre><code class="language-shell">npm install --save hexo-deployer-git #在blog目录下安装git部署插件</code></pre></li><li><p>配置<code>_config.yml</code></p><pre><code class="language-shell"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git repo: https://gitee.com/YourGiteeName/YourGiteeName.gitee.io.git  branch: master</code></pre></li><li><p>部署到仓库</p><pre><code class="language-shell">hexo d# 部署到Github仓库里</code></pre></li><li><p>然后就可以通过 <a href="https://YourGithubName.github.io">https://YourGithubName.github.io</a> 地址访问博客啦！</p></li></ul><h2 id="更换主题">更换主题</h2><ul><li><p>下载博客主题</p><pre><code class="language-shell">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地# 修改hexo根目录下的 _config.yml 文件 ： theme: yilia</code></pre></li><li><p>更新</p><pre><code class="language-shell">hexo clean# 清理一下hexo generate # 生成hexo d# 部署到远程Github仓库</code></pre></li></ul><h2 id="搭建个人公网博客">搭建个人公网博客</h2><ul><li><p>本地Linux：</p><pre><code class="language-bash">apt install gitssh-keygen -t rsa # 选择 rsa 保存位置为/root/.ssh/id_rsacat /root/.ssh/id_rsa.pub # 查看公钥内容(后续添加到远程Linux信任的key里面)</code></pre></li><li><p>远程Linux：</p><ul><li><p>创建Git裸仓</p><pre><code class="language-bash">apt install gitadduser ming # 创建新用户mingsu ming # 切换用户为minggit init --bare /home/ming/ming.git # 创建裸git仓库ls -l /home/home #查看生成的文件total 4drwxrwxr-x 7 ming ming 4096 Jun 28 00:37 ming.git</code></pre><p>可见 <code>ming.git</code> 的所属用户和用户组都是 <code>ming</code>。 如果创建<code>ming.git</code> 时是root 身份，可用 <code>chown -R ming:ming /home/ming/ming.git </code>更改<code>ming.git</code> 的所属用户和用户组为<code>ming</code>。</p></li><li><p>配置 Git 工作目录:</p><p>该目录用于存放 &quot;本地Linux &quot; 提交上来 (给 远程 Linux) 的 html 等文件，后续安装 Nginx 将该目录下的 html 呈现在公网。</p><pre><code class="language-bash">mkdir -p /var/www/minghexochmod -R 777 /var/www/minghexovim /home/ming/ming.git/hooks/post-update # 配置Git hooks</code></pre><p>往<code>post-update </code>种写入 <code>git --work-tree=/var/www/huaehexo --git-dir=/home/huae/huae.git checkout -f </code></p></li><li><p>添加SSH信任</p><p>创建<code>authorized_keys</code>文件，把本地Linux的<code> id_rsa.pub</code> 添加到此 <code>authorized_keys</code>，该<code>id_rsa.pub</code> 对应的（本地Linux）帐户就能提交 git 内容到本远程主机</p><pre><code class="language-bash">mkdir -p  /home/ming/.sshvim /home/ming/.ssh/authorized_keys</code></pre><p>此时可以通过<code>ssh &lt;用户名&gt;@&lt;服务器公网IP&gt;</code>测试，如果不需要输入密码并连接成功，则没有问题。</p></li></ul></li><li><p>本地Linux：</p><ul><li><p>配置 <code>hexo</code> 博客使其能自动推送到远程Linux的git仓库</p><pre><code class="language-bash">~/blog$ vim _config.yml</code></pre><p>写入内容：</p><pre><code class="language-bash"># Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  # repo: &lt;git仓库主人&gt;@&lt;远程Linux ip &gt; : &lt;到达 git仓库的路径&gt;  repo: ming@47.110.137.82:/home/ming/ming.git  branch: master</code></pre></li><li><p><code>hexo</code> 博客文件夹中安装 部署工具</p><pre><code class="language-bash">cd blognpm install hexo-deployer-git --save</code></pre></li><li><p>执行部署，部署到远程</p><pre><code class="language-bash">hexo -d</code></pre></li></ul></li><li><p>远程Linux配置Nginx：</p><ul><li><p>安装nginx</p><pre><code class="language-bash">apt install nginx</code></pre></li><li><p>配置nginx</p><pre><code class="language-bash">vim /etc/nginx/sites-enabled/default</code></pre><p>在<code>default</code>文件的<code>server&#123;&#125;</code>中添加</p><pre><code class="language-bash">root /var/www/minghexo;</code></pre></li><li><p>注意 <code>/etc/nginx/nginx.conf</code> 文件中 <code>http &#123; &#125; </code>花括号里要填入<code>include /etc/nginx/sites-enabled/*;</code></p></li><li><p>启动nginx</p><pre><code class="language-bash">service nginx restart</code></pre></li></ul></li></ul><p>​此时用浏览器访问服务器远程IP，就可以访问到博客页面啦！</p><ul><li>参考链接：<a href="https://www.cnblogs.com/Huae/p/16155927.html">Ubuntu 20.4 + Hexo + Nginx 搭建公网博客 - 星云体 - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> nginx </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 风格</title>
      <link href="/2023/06/20/Restful%20%E9%A3%8E%E6%A0%BC/"/>
      <url>/2023/06/20/Restful%20%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful">RESTful</h2><ul><li><p>REST（Representational State Transfer）：资源以某种表现形式在HTTP方法的作用下发生变化；</p></li><li><p><code>RESTful</code>实践</p><ul><li><p>获取数据</p><pre><code class="language-http">GET &quot;http://localhost:8080/rest/user/1&quot; </code></pre><p>定位id为1的用户（资源），用GET方法获取，查询资源；</p></li><li><p>新增数据</p><pre><code class="language-http">POST &quot;http://localhost:8080/rest/user&quot;Content-Type:application/json &#123;&quot;name&quot;:&quot;ming&quot;,&quot;age&quot;:3,&quot;email&quot;:&quot;ming@test.com&quot;&#125;</code></pre><p>POST方法的参数通常会被放在请求体中，以Content-Type中的格式（JSON）提交到服务端；</p></li><li><p>更新数据</p><pre><code class="language-http">PUT &quot;http://localhost:8080/rest/user&quot;Content-Type:application/json &#123;&quot;id&quot;:1,&quot;name&quot;:&quot;ming&quot;,&quot;age&quot;:21,&quot;email&quot;:&quot;ming@test.com&quot;&#125;</code></pre><p>与POST的区别在于请求参数还要指定一个唯一字段（如id）；</p></li><li><p>删除数据</p><pre><code class="language-http">DELETE &quot;http://localhost:8080/rest/user/1&quot; </code></pre></li></ul></li><li><p>RESTful风格由<code>URI</code>定位资源</p><ul><li><code>URI</code>：Uniform Resource Identifier</li><li><code>URL</code>：Uniform Resource Locator</li><li><code>URN</code>：Uniform Resource Name</li></ul><p>所有的<code>URL</code>和<code>URN</code>都可以称为<code>URI</code>；</p><p><code>URL</code>可以定位资源，而<code>URN</code>不行；</p></li></ul><h2 id="spring-中的Restful应用">spring 中的Restful应用</h2><ul><li><p>接口</p><pre><code class="language-java">@RestController@Slf4j@RequestMapping(&quot;/user&quot;)public class UserController &#123;    @GetMapping    public String hello()&#123;        return &quot;hello&quot;;    &#125;    @PostMapping    public void userInfo1(@RequestBody User user)&#123;        log.info(user.toString());    &#125;    @PostMapping(&quot;/&#123;age&#125;&quot;)    public void userInfo2(@PathVariable Integer age)&#123;        System.out.println(age);    &#125;    @PostMapping(&quot;/info&quot;)    public void userInfo3(String name,Integer age)&#123;        System.out.println(name+&quot; &quot;+age);    &#125;&#125;</code></pre></li><li><p>请求方式</p><pre><code class="language-http">GET localhost:8888/user</code></pre><pre><code class="language-http">POST localhost:8888/userContent-Type:application/json &#123;    &quot;name&quot;:&quot;ming&quot;,    &quot;age&quot;:&quot;20&quot;&#125;</code></pre></li><li><p>请求路径传参</p><pre><code class="language-http">POST localhost:8888/user/20</code></pre></li><li><p>普通路径传参</p><pre><code class="language-http">POST localhost:8888/user/info?name=ming&amp;age=20</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
