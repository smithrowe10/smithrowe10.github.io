<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>To 麻薯同学</title>
      <link href="/2024/04/26/To-%E9%BA%BB%E8%96%AF%E5%90%8C%E5%AD%A6/"/>
      <url>/2024/04/26/To-%E9%BA%BB%E8%96%AF%E5%90%8C%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/202404261057192.jpg" alt=""><br><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/202404261057194.jpg" alt=""><br><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/202404261057193.jpg" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>基于暗通道的图像去雾</title>
      <link href="/2023/12/05/%E5%9F%BA%E4%BA%8E%E6%9A%97%E9%80%9A%E9%81%93%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/"/>
      <url>/2023/12/05/%E5%9F%BA%E4%BA%8E%E6%9A%97%E9%80%9A%E9%81%93%E7%9A%84%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="绪论">绪论</h2><p>​室外场景的图像质量通常因大气中的混浊介质（例如颗粒和水液滴）而降低，例如雾霾、雾和烟雾等现象。摄像机从场景点接收到的辐照度沿视线衰减。此外，入射光与空气光混合——大气粒子反射到视线中的环境光。退化的图像失去了对比度和颜色保真度，由于散射量取决于场景点到相机的距离，因此雾霾引起的退化是空间变化的。</p><p>​在计算摄影和计算机视觉应用中，去雾是非常需要的。首先，去雾可以显著提高场景的可见性，纠正空气光引起的颜色偏移。其次，大多数计算机视觉算法，从低级图像分析到高级目标识别，通常假设输入图像(经过辐射校准后)是场景亮度，许多视觉算法的性能（例如特征检测、过滤和光度分析）不可避免地会受到有偏和低对比度的场景辐射的影响。最后，雾霾去除可以提供深度信息，有利于许多视觉算法和先进的图像编辑，雾霾或雾可以成为场景理解的有用深度线索。[1]</p><h2 id="相关研究综述">相关研究综述</h2><p>​雾霾去除是一个具有挑战性的问题，因为雾霾依赖于未知的深度。如果输入只是一个模糊图像，则该问题受到约束。因此，先前的研究工作已经提出了许多使用多个图像或附加信息的方法。例如基于偏振的方法 [2]、[3]，通过两个或多个不同偏振度拍摄的图像去除雾霾效应。在[4]、[5]、[6]中，从不同天气条件下从同一场景的多幅图像中获得更多的约束。基于深度的方法[8]、[9]需要用户输入或已知的3D模型的一些深度信息。</p><p>​近年来，单幅图像去雾已经取得了显著的进展[7]，[8]。这些方法的成功在于使用更强的先验或假设。Tan[8]观察到，与输入的模糊图像相比，无雾图像必须具有更高的对比度，并且他通过最大化恢复图像的局部对比度来去除雾霾。结果在视觉上令人信服，但可能不是物理上有效的。Fattal[7]在传输和表面阴影局部不相关的前提下，估计场景的反射率和介质传输。这种方法在物理上是可行的，可以产生令人印象深刻的结果。然而，它不能很好地处理严重的模糊图像，并且在假设被破坏的情况下可能会失败。</p><h2 id="主要工作">主要工作</h2><p>​本次实验用于单幅图像去雾，基于一种新的先验——暗通道先验。暗通道先验是基于室外无雾图像的统计数据，研究发现在大多数不覆盖天空的局部区域中，一些像素通常在至少一个颜色(RGB)通道中具有非常低的强度，被称为暗像素。在模糊图像中，该通道中这些暗像素的强度主要由空气光贡献。因此，这些暗像素可以直接提供对雾霾传输的准确估计。结合雾霾成像模型和软抠图插值方法，可以恢复高质量的无雾图像，产生良好的深度图。</p><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/image-20231204181711838.png" alt="image-20231204181711838"></p><center>图1 暗通道的计算过程<ul><li><p>暗通道的计算方法：</p><ul><li>对于一张图片(图1a)，我们计算每个像素的（r, g, b）中的最小值，如图1b；</li><li>再通过一个最小化过滤器求解小块区域内的最小值，如图1c；</li></ul><p>$$<br>J<sup>{dark}(x)=\min_{y\in\Omega(x)}(\min_{c\in{r,g,b}}J</sup>c(y))<br>$$</p><p>其中 $J^c$ 是 $J$ 的颜色通道，$\Omega(x)$是以 x 为中心的像素区域（本实验中patch为15x15）。</p></li><li><p>基于暗通道的概念我们可以知道，如果 J 是一个室外无雾图像，除了天空区域，J 的暗通道的强度很低，并且趋于零：<br>$$<br>J^{dark}(x)\to0<br>$$<br>以上假设称为暗通道先验。</p></li><li><p>室外部分场景的暗通道强度都很低主要是因为：</p><ul><li>阴影</li><li>彩色物体或者表面</li><li>黑色物体或者表面</li></ul></li></ul><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/image-20231204223148295.png" alt="image-20231204223148295"></p><center>图2 随机选取的场景图像<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/image-20231204223323598.png" alt="image-20231204223323598"></p><center>图3 对应场景的暗通道<p>可以看出，对于室外的无雾图像，其暗通道的轻度基本都很低，符合我们的暗通道先验。</p><h2 id="整体思路">整体思路</h2><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/image-20231204212912986.png" alt="image-20231204212912986"></p><center> 图4 图像去雾的整体思路<ul><li><p>描述雾图像的等式：<br>$$<br>I(x) = J(x)t(x)+A(1-t(x))<br>$$<br>其中$I(x)$表示有雾图像，$J(x)$表示清晰图像，$t(x)$表示透射率，$A$表示大气光照。</p></li><li><p>两边同时除以A<br>$$<br>\frac{I<sup>c(x)}{A</sup>c} = t(x)\frac{J<sup>c(x)}{A</sup>c}+1-t(x)<br>$$</p></li><li><p>左右两边同时做暗通道运算<br>$$<br>\min_{y\in\Omega(x)}(\min_{c}\frac{I<sup>c(y)}{A</sup>c}) = t(x)\min_{y\in\Omega(x)}(\min_{c}\frac{J<sup>c(y)}{A</sup>c})+1-t(x)<br>$$</p></li><li><p>基于先验假设$J^{dark}(x)\to0$，等式右边第一项为0，则可以得出透射率<br>$$<br>t(x)=\min_{y\in\Omega(x)}(\min_{c}\frac{I<sup>c(y)}{A</sup>c})<br>$$</p></li><li><p>已知透射率，将图像的亮度最大的点的灰度值作为全局大气光值A，即可得到去雾后的图片<br>$$<br>I(x) = J(x)t(x)+A(1-t(x))\<br>J(x)=\frac{I(x)}{t(x)}+A(1-t(x)^{-1})<br>$$</p></li></ul><h2 id="实验结果">实验结果</h2><p>论文中提供的测试图片：</p><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output2.png" alt="output2"></p><center> 实验结果1<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output3.png" alt="output3"></p><center> 实验结果2<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output1.png" alt="output1"></p><center> 实验结果3<p>个人测试图片：</p><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output4.png" alt="output4"></p><center> 实验结果4<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output5.png" alt="output5"></p><center> 实验结果5<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/output6.png" alt="output6"></p><center>实验结果6</center><p>​从实验结果可以看出，无论是论文中提供的测试图片，还是个人选取的测试图片，都能很好的实现去雾效果。但是基于该算法的去雾图片都会有一个共同的问题——白平衡失效。可以看出某些图片偏冷色调/暖色调，以及图像过暗等问题。</p><p>​为了解决这个问题，我使用基于LAB颜色空间的均值shifted算法来进行输出结果的白平衡矫正，具体方法是：</p><ul><li>将图像从BGR色彩空间转换到LAB色彩空间。LAB空间将颜色分离为亮度通道L和色度通道AB。</li><li>从LAB图像中提取亮度通道L。这通道反应了像素的亮暗程度,不包含颜色信息。</li><li>对亮度通道L进行CLAHE增强,即对图像做局部对比度增强。CLAHE作用是增强亮度细节,弥补全局处理的不足。</li><li>将处理后的亮度通道L与原来的色度通道AB合成为新的LAB图像。将新的LAB图像转换回BGR色彩空间，输出转换后的BGR图像即完成了白平衡校正。</li></ul><p>白平衡矫正后的实验结果如下所示：</p><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/balanced1.png" alt="balanced1"></p><center> 图5 实验结果白平衡前后对比 <p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/balanced2.png" alt="balanced2"></p><center>图6 实验结果白平衡前后对比<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/balanced3.png" alt="balanced3"></p><center>图7 实验结果白平衡前后对比<p>​最终，在暗通道去雾的基础上，我加入了白平衡矫正来优化输出结果，达到了很好的输出结果。</p><h2 id="总结与展望">总结与展望</h2><p>​本实验中我们基于暗通道先验，用于单幅图像去雾。暗通道先验基于室外无雾图像的统计数据，将先验与雾霾成像模型相结合，单幅图像雾霾去除更简单、更有效。</p><p>​然而，暗通道先验是一种统计数据，它可能不适用于某些特定图像。当场景对象本质上类似于大气光并且在其上没有阴影时，暗通道先验无效，这些场景亮度的暗通道在这些物体附近有明亮的值。因此，该方法将会出现错误估计，无法良好的去除雾霾。目前，结合深度卷积神经网络以及生成式模型，可以学习图像中的深度信息，更好的实现去雾效果。</p><h2 id="参考文献">参考文献</h2><p>[1] Kaiming He, et al. “Single Image Haze Removal Using Dark Channel Prior.” <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, Dec. 2011, pp. 2341–53.</p><p>[2] Y.Y. Schechner, S.G. Narasimhan, and S.K. Nayar, “Instant Dehazing of Images Using Polarization,” Proc. IEEE Conf. Computer Vision and Pattern Recognition, vol. 1, pp. 325-332, 2001.</p><p>[3] S. Shwartz, E. Namer, and Y.Y. Schechner, “Blind Haze Separation,” Proc. IEEE Conf. Computer Vision and Pattern Recognition,vol. 2, pp. 1984-1991, 2006.</p><p>[4] S.G. Narasimhan and S.K. Nayar, “Chromatic Framework for Vision in Bad Weather,” Proc. IEEE Conf. Computer Vision and Pattern Recognition, vol. 1, pp. 598-605, June 2000.</p><p>[5] S.K. Nayar and S.G. Narasimhan, “Vision in Bad Weather,” Proc. Seventh IEEE Int’l Conf. Computer Vision, vol. 2, pp. 820-827, 1999.</p><p>[6] S.G. Narasimhan and S.K. Nayar, “Contrast Restoration of Weather Degraded Images,” IEEE Trans. Pattern Analysis and Machine Intelligence, vol. 25, no. 6 pp. 713-724, June 2003.</p><p>[7] R. Fattal, “Single Image Dehazing,” Proc. ACM SIGGRAPH '08,2008.</p><p>[8] R. Tan, “Visibility in Bad Weather from a Single Image,” Proc. IEEE Conf. Computer Vision and Pattern Recognition, June 2008.</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生日快乐</title>
      <link href="/2023/11/03/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2023/11/03/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<p>23岁生日啦🎂</p><p>刚好在今天The Beatles发布了新专辑《Now And Then》，这无疑是我今年收到的最好的生日礼物。1994年，保罗联系到小野洋子，从她那里拿到了列侬生前的一张磁带，一首列侬未完成的遗作，召集乔治，林戈一起，计划完成这首歌曲。但是磁带中列侬的声音并不清晰且歌曲中钢琴难以分辨，三人只得放弃。保罗对着纪录片镜头说道：“要是多一些列侬的声音就好了” “要是列侬还在就好了”</p><p>2001年乐队又失去了小乔，而随后二十多年后剩下的两位老顽童借助AI的力量修复并恢复了列侬的声音，并且加入了乔治风格的吉他solo，林戈还是来打鼓，保罗还是弹贝斯，完成了这首作品。38岁的列侬，52岁的乔治，81岁的保罗和83岁的林戈，跨越四十多年、跨越生与死的合奏，在《Now And Then》这首单曲中重聚。</p><p>有时候自己很喜欢一个乐队或者一位歌手，时常会感叹自己为什么没有出生在那个时代，为什么自己只能在纪录片中回顾他们的历史，会很想经历他们成长的历程。而今天自己有幸见证了这一刻，在第一时间看到自己最喜欢的乐队发布了新专辑，我爱这一天！</p><center>     now and then</center><center>I want you to be there for me</center><br><p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/now%20and%20then.jpg" alt="now and then"></p>]]></content>
      
      
      <categories>
          
          <category> 碎碎念 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>测试图床</title>
      <link href="/2023/11/02/%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/11/02/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p><img src="https://ming12138-images.oss-cn-shanghai.aliyuncs.com/VCG211396235351.jpg" alt="VCG211396235351"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2023/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="创建型模式">创建型模式</h2><h3 id="单例模式">单例模式</h3><ul><li><p><strong>单例模式</strong>：确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。</p></li><li><p><strong>要求</strong>：</p><ul><li><strong>确保一个类只有一个实例</strong>：构造方法只能是<code>private</code>的；并且拥有一个当前类的静态成员变量；</li><li><strong>向整个系统提供这个实例</strong>：提供一个静态成员方法；</li></ul></li><li><p>实现方式：</p><ul><li><p><strong>饿汉式</strong>：类加载的时候就进行实例化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 单例模式（饿汉式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton1</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton1</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>懒汉式</strong>：在类被第一次使用的时候进行实例化；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 单例模式（懒汉式）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 singleton ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁，确保在多线程下，只被实例化一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton2 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> <span class="title class_">Singleton2</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以优化，在类第一次被使用之后进行实例化，之后就不需要加锁，因此另外一种方式是 <strong>双重检查锁</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 单例模式（懒汉式）- 多重检查锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton3 singleton ;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton3</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 加锁，确保在多线程下，只被实例化一次</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton3.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton==<span class="literal">null</span>)&#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> <span class="title class_">Singleton3</span>();</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 这一步包括</span></span><br><span class="line"><span class="comment">                     * 1. 分配内存</span></span><br><span class="line"><span class="comment">                     * 2. 初始化对象</span></span><br><span class="line"><span class="comment">                     * 3. 地址指向分配的内存</span></span><br><span class="line"><span class="comment">                     * 为防止发生重排序，用volatile修饰singleton静态变量</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>应用场景</strong>：单例模式的最佳实践就是无状态的，例如工具类（网站计数器，应用程序的日志等）；</p></li></ul><h3 id="简单工厂模式">简单工厂模式</h3><ul><li><p><strong>简单工厂模式</strong>：又称为静态工厂方法模式，属于类的创建模式。在简单工厂模式中，可以根据具参数的不同返回不同的实例；简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实力通常具有相同的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 简单工厂模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">a</span> <span class="operator">=</span> createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        a.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;ProductB&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>缺点</strong>：不够灵活，如果新增一个类，那么就要修改工厂类。</p></li></ul><h3 id="工厂模式">工厂模式</h3><ul><li><p><strong>工厂模式</strong>：定义一个用于创建类的对象，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 工厂模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 动物接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalAct</span><span class="params">(AnimalFactory fact)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> fact.createAnimal();</span><br><span class="line">        a.speak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        animalAct(<span class="keyword">new</span> <span class="title class_">DogFactory</span>());</span><br><span class="line">        animalAct(<span class="keyword">new</span> <span class="title class_">CatFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>局限性</strong>：工厂模式要求需要被创建的类都属于同一个大类；</p></li></ul><h3 id="抽象工厂模式">抽象工厂模式</h3><ul><li><p><strong>抽象工厂模式</strong>：抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，而无需指定具体实现类。通过使用抽象工厂模式，可以将客户端与具体产品的创建过程解耦，使得客户端可以通过工厂接口来创建一族产品。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.25</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 抽象工厂模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Food <span class="title function_">createFood</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">noodles</span> <span class="keyword">implements</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperFacory</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Food <span class="title function_">createFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">noodles</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="结构型模式">结构型模式</h2><h3 id="装饰器模式">装饰器模式</h3><ul><li><p><strong>装饰器模式</strong>：动态的给一个对象添加一些新的功能。就增加功能来说，装饰器模式比生成子类更加灵活。</p></li><li><p>装饰器模式是在不改变核心功能的基础上去新增一些新的功能，和代理模式非常地相似；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 装饰器模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorPattern</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象接口，代表那些需要被装饰的对象</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一代机器人</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot1</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对话&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;唱歌&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RobotDecorator</span> <span class="keyword">implements</span> <span class="title class_">Robot</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Robot robot;</span><br><span class="line"></span><br><span class="line">    RobotDecorator(Robot robot) &#123;</span><br><span class="line">        <span class="built_in">this</span>.robot = robot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        robot.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doMoreThing</span><span class="params">()</span> &#123;</span><br><span class="line">        robot.doSomething();  <span class="comment">// 原有功能</span></span><br><span class="line">        System.out.println(<span class="string">&quot;跳舞&quot;</span>);  <span class="comment">// 新的功能</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>装饰器模式和静态代理的区别</strong></p><ul><li>装饰器模式就是为了增强目标类；静态代理设计模式是为了保护和隐藏目标对象。</li><li>装饰器模式和代理模式都是对原有对象的功能进行增强，但是装饰器模式可以进行多次扩展。</li></ul></li></ul><h3 id="适配器模式">适配器模式</h3><ul><li><p><strong>适配器模式</strong>：将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> ming</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023.09.26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@about</span> 适配器模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdapterPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Adapter</span>(<span class="keyword">new</span> <span class="title class_">Speaker</span>()).translate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Speaker</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">speaker</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;你好！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Translator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">translate</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">implements</span> <span class="title class_">Translator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Speaker speaker;</span><br><span class="line"></span><br><span class="line">    Adapter(Speaker speaker) &#123;</span><br><span class="line">        <span class="built_in">this</span>.speaker = speaker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">translate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> speaker.speaker();</span><br><span class="line">        <span class="comment">// 翻译，转达等业务</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="观察者模式">观察者模式</h3><ul><li><strong>观察者模式</strong>：定义了对象间的一种一对多的依赖关系，使得每当一个对象状态发生改变时，其相关依赖关系皆得到通知并被自动更新。观察者模式也被称为 “发布-订阅模式”。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机</title>
      <link href="/2023/09/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>/2023/09/13/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>JVM</h1><h2 id="简介">简介</h2><ul><li><strong>JVM</strong>：是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li><li>优点：<ul><li>一次编写，到处运行；</li><li>自动内存管理，垃圾回收机制；</li><li>数组下标越界检查；</li></ul></li></ul><h2 id="运行数据时区域">运行数据时区域</h2><ul><li>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</li><li><strong>线程共享</strong>：堆（包括字符串常量池），方法区（包括运行时方法常量池），直接内存 (非运行时数据区的一部分)</li><li><strong>线程私有</strong>：虚拟机栈，本地方法栈，程序计数器</li></ul><h3 id="程序计数器">程序计数器</h3><ul><li>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</li><li>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为 <strong>线程私有</strong> 的内存。</li><li>作用：<ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而<strong>实现代码的流程控制</strong>，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于<strong>记录当前线程执行的位置</strong>，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul></li><li>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</li></ul><h3 id="Java虚拟机栈">Java虚拟机栈</h3><ul><li><p>虚拟机栈为虚拟机执行方法而服务，描述的是Java方法执行的线程内存模型。</p></li><li><p>虚拟机栈由一个个<strong>栈帧</strong>组成，而每个栈帧中都拥有：</p><ul><li>局部变量表：主要存放了编译期可知的各种数据类型（<code>int,char,...</code>）和对象引用；</li><li>操作数栈：主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果；还有计算过程中产生的临时变量；</li><li>动态链接：主要服务一个方法需要调用其他方法的场景。</li><li>方法返回地址：存储方法的返回地址。</li></ul></li><li><p>每一次方法调用时都会有对应的栈帧被压入栈中，方法调用结束后，对应的栈帧会被弹出。</p></li><li><p>Java 虚拟机栈也是<strong>线程私有</strong>的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p></li><li><p><strong>如果线程请求的栈深度大于虚拟机允许的深度，会抛出<code>StackOverFlowError</code>异常；如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>。</strong></p></li></ul><h3 id="本地方法栈">本地方法栈</h3><ul><li><p><strong>Native Method</strong>：就是一个 Java 调用非 Java 代码的接口，即该方法并非由java实现。</p></li><li><p>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 <strong>Native</strong> 方法服务。</p></li><li><p>本地方法栈在方法执行时与虚拟机栈相同。</p></li><li><p>与虚拟机栈一样，<strong>本地方法栈在栈深度溢出或无法申请到足够空间的时候抛出<code>StackOverFlowError</code> 或 <code>OutOfMemoryError</code>。</strong></p></li></ul><h3 id="堆">堆</h3><ul><li>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有 <strong>线程共享</strong> 的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></li><li>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</li><li><strong>如果Java堆中没有没有内存完成实例分配，并且堆也无法再扩展时，虚拟机将会抛出<code>OutOfMemoryError</code>。</strong></li></ul><h3 id="方法区">方法区</h3><ul><li><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个<strong>线程共享</strong>的内存区域。</p></li><li><p>方法区存储的是和类相关的信息，例如类的成员变量，方法参数，成员方法和构造器，以及运行时常量池。</p></li><li><p>方法区常用参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N <span class="comment">//设置 Metaspace 的初始（和最小大小）</span></span><br><span class="line">-XX:MaxMetaspaceSize=N <span class="comment">//设置 Metaspace 的最大大小</span></span><br></pre></td></tr></table></figure></li><li><p><strong>如果方法区无法满足新的内存分配需求时，将会抛出<code>OutOfMemoryError</code>异常。</strong></p></li></ul><h3 id="运行时常量池">运行时常量池</h3><ul><li>运行时常量池是方法区的一部分。</li><li>Class文件中的常量池表（用于存放编译器生成的各种字面变量与符号引用），将在类加载后存放到方法区的运行时常量池中。</li><li><strong>当常量池无法申请到内存时会抛出<code>OutOfMemoryError</code>异常。</strong></li></ul><h3 id="直接内存">直接内存</h3><ul><li>直接内存并不是虚拟机运行时数据区的一部分，而是属于操作系统的内存。</li><li>直接内存分配不会受到java堆大小的控制，如果各个内存之和超过了本机总物理内存限制，也会导致<code>OutOfMemoryError</code>异常。</li></ul><h2 id="垃圾回收机制">垃圾回收机制</h2><h3 id="堆空间结构">堆空间结构</h3><p><img src="C:%5CUsers%5CMistletoe%5CDesktop%5Cwork%5Cimages%5Chotspot-heap-structure.png" alt=""></p><ul><li><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(<em>Young Generation</em>)：<code>Eden</code>，<code>S0</code>，<code>S1</code></li><li>老生代(<em>Old Generation</em>)：<code>Tenured</code></li><li>永久代(<em>Permanent Generation</em>)：<code>PermGen</code></li></ol></li><li><p>JDK 8 版本之后为：</p><ol><li>新生代内存(<em>Young Generation</em>)</li><li>老生代(<em>Old Generation</em>)</li><li>元空间（<em>Metaspace</em>）</li></ol></li></ul><h3 id="内存分配和回收原则">内存分配和回收原则</h3><ul><li><p>堆内存分配：</p><ul><li>年轻代（1/3）<ul><li>伊甸园区（8/10）</li><li>S0（1/10）</li><li>S1（1/10）</li></ul></li><li>老年代（2/3）</li></ul></li><li><p>新创建的对象优先在Eden区分配；</p></li><li><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p></li><li><p>如果对象在经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)。</p></li><li><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。</p></li><li><p>针对 HotSpot VM 的实现，GC方式分为两大类：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p></li></ul><h3 id="判断哪些对象需要回收">判断哪些对象需要回收</h3><ul><li><p><strong>引用计数法</strong>：每个对象都有一个引用计数器，每次该对象被引用时，引用计数都会 +1；离开作用域或引用失效时计数器 -1；</p><p>对象之间<strong>循环引用</strong>的情况下两个对象的计数器都不为 0，会导致都无法被回收，可能会出现内存泄漏问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象objA和objB互相引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReferenceCountingGc</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        <span class="type">ReferenceCountingGc</span> <span class="variable">objB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceCountingGc</span>();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line">        objA = <span class="literal">null</span>;</span><br><span class="line">        objB = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>可达性算法分析</strong></p><ul><li>将 <code>GC roots </code>对象作为起点，从这些结点开始乡下搜索引用的对象，找到的对象都标记为非垃圾对象，找不到的为垃圾对象。</li><li>哪些对象可以作为<code>GC roots </code>？<ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象；</li><li>本地方法栈(Native 方法)中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>所有被同步锁持有的对象；</li><li>JNI（Java Native Interface）引用的对象；</li></ul></li></ul></li><li><p><strong>引用类型</strong></p><ul><li><strong>强引用</strong>（<code>StrongReference</code>）：我们使用的绝大部分都是强引用，如果一个对象具有强引用，那么绝对不会被垃圾回收器回收，即使是内存空间不足（会直接抛出OOM）。</li><li><strong>软引用</strong>（<code>SoftReference</code>）：如果一个对象只具有软引用，那就类似于<strong>可有可无的</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</li><li><strong>弱引用</strong>（<code>WeakReference</code>）：如果一个对象只具有弱引用，在垃圾回收器线程扫描它所管辖的内存区域的过程中，<strong>一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</strong></li><li><strong>虚引用</strong>（<code>PhantomReference</code>）：顾名思义，就是形同虚设。虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong></li></ul></li></ul><h3 id="垃圾回收算法">垃圾回收算法</h3><ul><li><p><strong>标记-清除</strong>：该算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后进行清除。（也可以反过来，先标记处所有存活的对象，统一回收未被标记的对象）</p><p>该算法的缺点是：</p><ul><li><p><strong>执行效率不稳定</strong>：如果java堆中大部分对象都是需要被回收的，那么就需要大量的标记和清除动作。</p></li><li><p><strong>会产生内存碎片</strong>（标记清除后未整理空间），可能在之后分配大对象时无法找到合适的连续空间，容易导致频繁的内存分配和回收。</p></li></ul></li><li><p><strong>复制收集</strong>：该算法将可用内存空间分为两部分，每次只使用其中一部分。当一部分内存用完后，将未被回收的对象复制到另一部分内存中，并清除原来的内存。该算法的优点是简单高效，<strong>缺点是需要额外的内存空间</strong>。如果存活对象的数量较大的话，复制性能会变得很差。</p></li><li><p><strong>标记-整理</strong>：根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。但是整理<strong>需要线程同步，因此效率偏低</strong>。（整理的时候要停止丢垃圾）</p></li></ul><h3 id="分代收集">分代收集</h3><ul><li>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为 <strong>新生代</strong> 和 <strong>老年代</strong>，根据各个年代的特点选择合适的垃圾收集算法。</li><li>比如在 **新生代 **中，每次收集都会有大量对象死去，所以可以选择 ”<strong>标记-复制</strong>“ 算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</li><li>而<strong>老年代</strong>的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 **“标记-清除” ** 或 **“标记-整理” **算法进行垃圾收集。</li></ul><h3 id="垃圾收集器">垃圾收集器</h3><ul><li><p><strong>垃圾回收算法是内存回收的方法论，垃圾收集器是内存回收的具体实现。</strong></p></li><li><p><strong>Serial</strong>（串行收集器）：单线程GC，进行垃圾收集工作时必须要暂停其他所有的线程（STW），直到收集工作结束。新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p><strong>ParNew 收集器</strong>：其实就是 Serial 多线程版本，使用多线程进行垃圾回收。新生代采用标记-复制算法，老年代采用标记-整理算法。</p></li><li><p><strong>Parallel Scavenge 收集器</strong>：Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量。新生代采用标记-复制算法，老年代采用标记-整理算法。<strong>这是 JDK1.8 默认收集器</strong></p></li><li><p><strong>Serial Old</strong>：Serial 收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用途：一种用途是在 JDK1.5 以及以前的版本中与 Parallel Scavenge 收集器搭配使用，另一种用途是作为 CMS 收集器的后备方案。</p></li><li><p><strong>Parallel Old</strong>：Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。</p></li><li><p><strong>CMS收集器（Concurrent Mark  Swap）</strong>：CMS收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>。CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让<strong>垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p><img src="https://oss.javaguide.cn/github/javaguide/java/jvm/cms-garbage-collector.png" alt=""></p><p>CMS算法基于 <strong>“标记-清除”</strong> 算法，整个过程分为四个部分：</p><ul><li><strong>初始标记</strong>：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；</li><li><strong>并发标记</strong>：同时开启 GC 和用户线程，记录引用可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记</strong>：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。</li><li><strong>并发清除</strong>：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p>CMS的缺点：</p><ul><li>无法处理浮动垃圾（影响不大，浮动垃圾在下一次垃圾收集时会被清理掉）；</li><li>使用 <strong>“标记-清除”</strong> 算法会产生大量空间碎片。</li></ul></li><li><p><strong>G1收集器（Garbage-First）</strong>：是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。</p><p>G1收集器的运作过程大致分为四个部分：</p><ul><li><strong>初始标记</strong>：标记 GC Roots 能够直接关联到的对象，时间很短。</li><li><strong>并发标记</strong>：从GC Roots开始对堆中的对象进行可达性分析，递归扫描整个堆里的对象图，找出所有要回收的对象。这个阶段时间较长，但是可以与用户程序并发执行。对象图扫描完成后，可能还会有一些并发时期引用改动的对象。</li><li><strong>最终标记</strong>：对用户线程做一个短暂的暂停，用于处理并发阶段遗留的少量的引用变动的对象。</li><li><strong>筛选回归</strong>：G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region。</li></ul></li><li><p><strong>ZGC收集器</strong>：与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。在 ZGC 中出现 Stop The World 的情况会更少！</p></li></ul><h2 id="类文件结构">类文件结构</h2><ul><li>JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。不同的语言被编译成字节码，最终运行在Java虚拟机上。</li></ul><h2 id="类加载过程">类加载过程</h2><h3 id="类的生命周期">类的生命周期</h3><ul><li>类从被加载到虚拟机内存中开始到卸载出内存为止，它的整个生命周期可以简单概括为 7 个阶段：：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）。其中，验证、准备和解析这三个阶段可以统称为连接（Linking）。</li></ul><p><img src="%5Cimages%5Clifecycle-of-a-class.png" alt=""></p><h3 id="类加载过程-v2">类加载过程</h3><ul><li><p>系统加载Class类型文件主要是三步：<strong>加载 -&gt; 连接 -&gt;初始化</strong>。连接过程包括验证，准备，解析。</p></li><li><p><strong>加载</strong>：这一步通过<strong>类加载器</strong>完成，主要完成以下事情。</p><ul><li>通过全类名获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构。</li><li>在内存中生成一个代表该类的 <code>Class</code> 对象，作为方法区这些数据的访问入口。</li></ul><p>当我们要加载一个类时，具体要使用哪个类加载器由<strong>双亲委派模型</strong>决定。</p></li><li><p><strong>验证</strong>：确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。</p><p>验证阶段分为以下四步：</p><ul><li>文件格式验证（Class 文件格式检查）</li><li>元数据验证（字节码语义检查）</li><li>字节码验证（程序语义检查）</li><li>符号引用验证（类的正确性检查）</li></ul></li><li><p><strong>准备</strong>：准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。</p><p>tip：</p><ul><li>这个阶段内存分配仅包括类变量（不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中）。</li><li>类变量所使用的内存都应当在 <strong>方法区</strong> 中进行分配。</li><li>这里的初始值都是设置的数据类型默认的零值。比如我们定义了<code>public static int value=111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是 111（初始化阶段才会赋值）。特殊情况：比如给 value 变量加上了 final 关键字<code>public static final int value=111</code> ，那么准备阶段 value 的值就被赋值为 111。</li></ul></li><li><p><strong>解析</strong>：解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。也就是得到类或者字段、方法在内存中的指针或者偏移量，后续可以直接调用相应方法。</p></li><li><p><strong>初始化</strong>：初始化阶段是执行初始化方法 <code>&lt;clinit&gt; ()</code>的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。</p></li><li><p><strong>类卸载</strong>：卸载类即该类的 Class 对象被 GC。</p><p>卸载类需要满足 3 个要求:</p><ol><li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。</li><li>该类没有在其他任何地方被引用</li><li>该类的类加载器的实例已被 GC</li></ol></li></ul><h2 id="类加载器">类加载器</h2><h3 id="简介-v2">简介</h3><ul><li><p><strong>类加载器的主要作用就是加载 Java 类的字节码（ <code>.class</code> 文件）到 JVM 中（在内存中生成一个代表该类的 <code>Class</code> 对象）。</strong></p></li><li><p><strong>类加载器是一个负责加载类的对象。</strong><code>ClassLoader</code> 是一个抽象类。给定类的二进制名称，类加载器应尝试定位或生成构成类定义的数据。典型的策略是将名称转换为文件名，然后从文件系统中读取该名称的“类文件”。</p></li><li><p><strong>每个 Java 类都有一个引用指向加载它的 <code>ClassLoader</code></strong>。不过，<strong>数组类不是通过 <code>ClassLoader</code> 创建的，而是 JVM 在需要的时候自动创建的</strong>，数组类通过<code>getClassLoader()</code>方法获取 <code>ClassLoader</code> 的时候和该数组的元素类型的 <code>ClassLoader</code> 是一致的。</p></li></ul><h3 id="类加载器加载规则">类加载器加载规则</h3><ul><li>JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。</li><li>对于已经加载的类会被放在 <code>ClassLoader</code> 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。</li><li><strong>每一个类加载器，都拥有一个独立的类名称空间。</strong> 即两个不同的类加载器加载同一个Class文件，得到两个类必定不相等。</li></ul><h3 id="ClassLoader">ClassLoader</h3><ul><li><p>JVM 中内置了三个重要的 <code>ClassLoader</code>：</p><ol><li><strong><code>BootstrapClassLoader</code>(启动类加载器)</strong>：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，<strong>主要用来加载 JDK 内部的核心类库</strong>（ <code>%JAVA_HOME%/lib</code>目录下的 <code>rt.jar</code>、<code>resources.jar</code>、<code>charsets.jar</code>等 jar 包和类）以及被 <code>-Xbootclasspath</code>参数指定的路径下的所有类。</li><li><strong><code>ExtensionClassLoader</code>(扩展类加载器)</strong>：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类以及被 <code>java.ext.dirs</code> 系统变量所指定的路径下的所有类。</li><li><strong><code>AppClassLoader</code>(应用程序类加载器)</strong>：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。如果应用程序没有自定义过自己的类加载器，那么一般情况下这个就是默认加载器。</li></ol><p>除了这三种类加载器之外，用户还可以加入自定义的类加载器来进行拓展，以满足自己的特殊需求。</p><h3 id="双亲委派模型">双亲委派模型</h3><p><img src="%5Cimages%5Cclass-loader-parents-delegation-model.png" alt=""></p></li><li><p>各个类加载器之间的层次关系被称为 <strong>双亲委派模型</strong>。双亲委派模型要求除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。</p></li><li><p><strong>双亲委派模型的工作流程</strong>：</p><ul><li><strong>如果一个类加载器接收到了类加载的请求，他会先把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的类加载请求都应该传送到顶层的启动类加载器中，只有当父亲加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去完成加载。</strong></li></ul></li><li><p><strong>双亲委派模型的好处</strong>：</p><ul><li>**Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。**例如<code>java.lang.Object</code>，它存放在<code>rt.jar</code>里，无论哪一个类加载器要加载这个类，最终都是委派给最顶端的启动类加载器进行加载，因此<code>Object</code>类在各种类加载环境中都能保证是同一个类。</li><li>双亲委派模型保证了 Java 程序的稳定运行，可以<strong>避免类的重复加载，也保证了 Java 的核心 API 不被篡改。</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2023/09/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2023/09/05/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="多线程的概念">多线程的概念</h2><ul><li><strong>进程</strong>：程序的基本执行实体（例如电脑中运行的某个软件）</li><li><strong>线程</strong>：线程是操作系统能够运算调度的最小单位。它被包含在进程中，是<strong>进程</strong>的实际运作单位。一个进程中有多个线程。</li><li><strong>进程和线程的关系</strong>：一个进程可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>，但是每个线程有自己的<strong>程序计数器</strong>，<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>。</li><li><strong>多线程</strong>：程序同时执行多个任务；</li><li><strong>并发</strong>(<code>concurrent</code>)指在java程序中同时运行多个线程；（同一时刻，多个指令在<strong>单个CPU</strong>上<strong>交替执行；</strong>）</li><li><strong>并行</strong>：同一时刻，多个指令在<strong>多个CPU</strong>上<strong>同时执行；</strong></li><li><strong>线程安全性</strong><ul><li>线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的<strong>正确性</strong>和<strong>一致性</strong>。</li><li>线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。</li></ul></li></ul><h2 id="多线程的实现方式">多线程的实现方式</h2><ul><li><p>实现方式一：自己定义一个继承自<code>Thread</code>的类，重写<code>run</code>方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(getName() +<span class="string">&quot; hello world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        <span class="type">Thread1</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread1</span>();</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br><span class="line">线程<span class="number">1</span> hello world!</span><br><span class="line">线程<span class="number">2</span> hello world!</span><br></pre></td></tr></table></figure></li><li><p>实现方式二：</p><ul><li>自己定义一个类实现<code>Runnable</code>接口，重写<code>run</code>方法；</li><li>创建一个自己类的对象，创建Thread类的对象，并开启线程；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName();<span class="comment">//获取当前线程的name</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(name +<span class="string">&quot; hello world!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread2</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread2</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现方式三：</p><ul><li>创建一个类实现<code>Callable</code>接口，重写<code>call</code>方法（有返回值，表示多线程的运行结果）；</li><li>创建自己类的对象；</li><li>创建<code>FutureTask</code>对象（用于管理多线程处理的结果）；</li><li>创建<code>Thread</code>类的对象，并启动线程；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread3</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread3</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread3</span>();</span><br><span class="line">        </span><br><span class="line">        FutureTask&lt;Integer&gt; f = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(thread);</span><br><span class="line">        </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f);</span><br><span class="line">        t1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="多线程的常用方法">多线程的常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>; <span class="comment">// 更改线程的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">getName</span><span class="params">()</span>; <span class="comment">// 获取线程的名字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>; <span class="comment">// 启动线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title function_">currentThead</span><span class="params">()</span>; <span class="comment">// 获取正在执行的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getPriority</span><span class="params">()</span>; <span class="comment">// 获取当前线程优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">setPriority</span><span class="params">(<span class="type">int</span> newPriority)</span>; <span class="comment">//设置线程的优先级（1~10）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">// 睡眠指定时间，暂停运行</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span>; <span class="comment">// 插入线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">yield</span><span class="params">()</span>; <span class="comment">//礼让线程</span></span><br></pre></td></tr></table></figure><h2 id="线程的生命周期">线程的生命周期</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li><code>New</code>：线程被创建，但是还未调用<code>start()</code>方法；</li><li><code>Runnable</code>：可运行状态，线程被调用了<code>start()</code>方法，等待运行的状态；</li><li><code>Blocked</code>：线程阻塞状态，需要等待锁释放；</li><li><code>Waiting</code>：等待状态，该线程需要等待其他线程做出特定动作（通知或终止）；</li><li><code>time_waiting</code>：超时等待状态，可以在指定时间后自行返回，不用一直等待；</li><li><code>terminated</code>：终止状态，表示该线程已经执行完毕。</li></ul><p><img src="%5Cimages%5C640.png" alt="thread_life1"></p><ul><li>常用方法：<ul><li><code>sleep(long)</code>：暂停执行线程，但是未释放锁；</li><li><code>wait()</code>：暂停执行线程并释放锁；<code>wait()</code>方法是Object类的本地方法，因为释放对象锁需要操作对应的对象（Object）。</li><li><code>notify()</code>：唤醒线程；</li><li><code>notifyAll()</code></li></ul></li><li><strong>可以直接调用<code>run()</code>方法吗?</strong><ul><li><code>new</code>一个<code>Thread</code>对象，然后调用<code>start()</code>方法，进入就绪状态，分配到时间片后就可以运行了；<code>start()</code>将线程相应的准备工作都做好了，然后自动执行<code>run()</code>方法中的内容。</li><li>如果直接调用<code>run()</code>方法，则会把<code>run()</code>当成main线程下的普通方法，并不会在某个线程中去执行，这不是多线程的工作。</li></ul></li></ul><p><img src="%5Cimages%5Cthread_life.jpg" alt="thread_life2"></p><h2 id="线程的安全问题">线程的安全问题</h2><ul><li><p>竞态条件（Race Condition）</p><ul><li>多个线程同时对<strong>共享资源</strong>进行读写操作，导致数据不一致。</li><li>解决：同步机制（synchronized），锁（Lock），使用线程安全的数据结构（如ConcurrentHashMap）</li><li>同步代码块<ul><li><strong>锁对象一定要是唯一的</strong>，如果每个线程拥有一个不同的锁对象，则锁就失去了意义；</li><li>synchronized不要写在循环内，不然一个线程抢到执行权后，直到循环结束之前，其他线程没法进入；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注：这里使用线程的第一种自定义方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加static关键字，表示共享ticket数据</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 锁对象必须是唯一的</span></span><br><span class="line">    <span class="comment">// 加static关键字表示的MyThread创建的所有对象都共享同一个obj</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 同步代码块</span></span><br><span class="line">            <span class="keyword">synchronized</span> (obj)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ticket&lt;<span class="number">100</span>)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(getName()+<span class="string">&quot;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票！&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同步方法<ul><li>将同步代码块抽取出来形成一个方法，为这个方法上锁；</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注：这里使用线程的第二种自定义方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 不需要static关键字，Runnable对象只创建一次</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(memthod()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">memthod</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ticket&lt;<span class="number">100</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125;</span><br><span class="line">            ticket++;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">&quot;正在卖第&quot;</span>+ticket+<span class="string">&quot;张票！&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>StringBulider</strong>&amp;<strong>StringBuffer</strong></p><ul><li><p><code>StringBuffer</code>和<code>StringBuilder</code>都是Java中用于处理<strong>可变字符串</strong>的类，它们的主要区别在于线程安全性和性能。</p></li><li><p><code>StringBuffer</code>是<strong>线程安全</strong>的，因此可以在多线程环境下使用。它的<strong>所有公共方法都是同步的</strong>，即在方法内部使用了synchronized关键字来确保线程安全。这种同步机制会带来一定的<strong>性能损失</strong>，因为多个线程需要竞争同一把锁，这会导致线程阻塞和上下文切换。因此，如果不需要在多线程环境下使用可变字符串，建议使用<code>StringBuilder</code>。</p></li><li><p><code>StringBuilder</code>是<strong>非线程安全</strong>的，因此不能在多线程环境下使用。它的所有公共方法都不是同步的，因此在单线程环境下使用<code>StringBuilder</code>比使用<code>StringBuffer</code>更加高效。</p></li></ul></li><li><p><strong>锁（Lock）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ticket</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            lock.lock(); <span class="comment">// 上锁</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticket &lt; <span class="number">100</span>) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    ticket++;</span><br><span class="line">                    System.out.println(getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票！&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock(); <span class="comment">// 释放锁 </span></span><br><span class="line">                               <span class="comment">// 使用finally关键字，不管怎样都会被执行，防止线程跳出循环后未释放锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>死锁</strong></p><ul><li><p>死锁是指两个或多个线程在互相持有对方所需要的资源时，都在等待对方先释放资源，导致程序无法继续执行的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadLockDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 资源1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">resource2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 资源2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了资源：resource1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;准备获取资源：resource2&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了资源：resource2&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resource2) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了资源：resource2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;准备获取资源：resource1&quot;</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resource1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;获取到了资源：resource1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">线程<span class="number">1</span>获取到了资源：resource1</span><br><span class="line">线程<span class="number">2</span>获取到了资源：resource2</span><br><span class="line">线程<span class="number">1</span>准备获取资源：resource2</span><br><span class="line">线程<span class="number">2</span>准备获取资源：resource1</span><br></pre></td></tr></table></figure></li><li><p>避免死锁的方法：</p><ul><li>避免使用多个锁：尽量减少线程需要持有的锁的数量，或使用更高级别的同步机制（如ReentrantLock）来避免死锁；</li><li>避免使用多个锁的嵌套；</li><li>超时等待：线程尝试获取锁时，设置一个超时时间，在等待超过一定时间后，放弃获取锁。</li></ul></li></ul></li><li><p><strong>等待唤醒机制</strong></p><ul><li><p>等待唤醒机制是一种用于线程间通信的机制，它允许一个线程等待另一个线程的通知，以便在特定时间点上恢复执行。</p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span>; <span class="comment">// 释放锁，进入等待状态</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>; <span class="comment">// 暂停执行，但是未释放锁</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;  <span class="comment">// 唤醒</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="线程池">线程池</h2><ul><li><p>之前写多线程的弊端：线程用完之后就消失，浪费资源；</p></li><li><p>线程池是一种用于<strong>管理和重用线程</strong>的机制，它允许在应用程序中创建一组线程，并在需要时执行任务，而不需要频繁地创建和销毁线程。</p></li><li><p>使用线程池的优点：</p><ul><li><strong>降低资源消耗</strong></li><li><strong>提高响应速度</strong></li><li><strong>提高线程的可管理性</strong></li></ul></li><li><p>线程池核心原理：</p><ul><li>创建一个池子，初始是空的；</li><li>提交任务时，池子创建一个新的线程对象，任务执行完毕后把线程还给池子，下次创建线程时不需要创建新的线程，直接复用已有的线程；</li><li>但是如果提交任务时线程池中没有空闲线程，也无法创建新的线程，任务就会等待；</li></ul></li><li><p>创建线程池的方式：</p><ul><li><strong>通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></li><li><strong>通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong><ul><li><code>FixedThreadPool</code>：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。</li><li><code>CachedThreadPool</code>： 该方法返回一个可根据实际情况调整线程数量的线程池。初始大小为0。当有新任务提交时，如果当前线程池中没有线程可用，它会创建一个新的线程来处理该任务。如果在一段时间内（默认为60秒）没有新任务提交，核心线程会超时并被销毁，从而缩小线程池的大小。</li><li><code>SingleThreadExecutor</code>： 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><code>ScheduledThreadPool</code>：该方法返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个没有上限的线程池对象</span></span><br><span class="line"><span class="comment">//        ExecutorService pool = Executors.newCachedThreadPool();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个有上限的线程池对象</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        pool.submit(<span class="keyword">new</span> <span class="title class_">MyThread</span>());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 销毁线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>线程池常见参数</strong>：</p><ul><li><code>corePoolSize</code>：核心线程数（一直存活的线程，即便当前没有任务执行）</li><li><code>maximumPoolSize</code>：最大线程数，如果<code>maximumPoolSize</code> &gt; 当前线程 &gt; <code>corePoolSize</code>，且队列任务已满，线程池会创建新线程来执行任务。</li><li><code>keepAliveTime</code>：线程保持空闲时间，当线程空闲时间达到<code>keepAliveTime</code>时，线程会自动退出，直到线程数等于核心线程数。</li><li><code>workQueue</code>：新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, // 核心线程数</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize, // 最大线程数</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>ThreadPoolExecutor</code>执行过程</strong></p><ul><li>提交任务；</li><li><strong>判断是否达到核心线程数</strong>，如果没有，创建新线程执行任务；</li><li>如果达到核心线程数，<strong>判断工作队列是否已满</strong>，如果没有，则将任务添加到队列；</li><li>如果工作队列是否已满，<strong>判断是否达到最大线程数</strong>，如果没有，则创建新线程来执行任务；</li><li>如果已经达到最大线程数，则根据<strong>饱和策略</strong>处理（例如抛出异常）；</li></ul></li></ul><h2 id="ThreadLocal">ThreadLocal</h2><ul><li><p><code>ThreadLocal</code> 叫做本地线程变量，意思是说，<code>ThreadLocal</code> 中填充的的是当前线程的变量，该变量对其他线程而言是封闭且隔离的，<code>ThreadLocal</code> 为变量在每个线程中创建了一个副本，这样每个线程都可以访问自己内部的副本变量。</p></li><li><p>常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span>; <span class="comment">// 存储数据</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>;  <span class="comment">// 获取数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span>;  <span class="comment">// 删除数据</span></span><br></pre></td></tr></table></figure></li><li><p><code>ThreadLocal</code>原理：最终的变量是放在了当前线程的 <strong><code>ThreadLocalMap</code></strong> （底层是<code>HashMap</code>）中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</p><p><code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//取出 Thread 类内部的 threadLocals 变量(哈希表结构)</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 将需要存储的值放入到这个哈希表中</span></span><br><span class="line">        map.set(<span class="built_in">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</p></li></ul><h2 id="Java线程内存模型">Java线程内存模型</h2><h3 id="并发编程中的三个概念">并发编程中的三个概念</h3><ul><li><p><strong>原子性</strong>：在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>;  <span class="comment">// 原子性操作</span></span><br><span class="line">x++;    <span class="comment">// 非原子性操作</span></span><br><span class="line">y = x;  <span class="comment">// 非原子性操作</span></span><br></pre></td></tr></table></figure></li><li><p><strong>有序性</strong>： 在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p></li><li><p><strong>可见性</strong>：</p><ul><li>当一个<strong>共享变量</strong>被<code>volatile</code>修饰时，它会保证修改的值会<strong>立即更新</strong>到主存，当有其他线程需要读取时，它会去内存中读取新值。</li><li>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</li><li>通过<code>synchronized</code>和<code>Lock</code>也能够保证可见性，<code>synchronized</code>和<code>Lock</code>能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li></ul></li></ul><h3 id="volatile关键字">volatile关键字</h3><ul><li><p><code>volatile</code>关键字可以保证变量的可见性，一旦一个共享变量（类的成员变量、类的静态成员变量）被<code>volatile</code>修饰之后，那么就具备了两层语义：</p><p>1）保证了不同线程对这个变量进行操作时的<strong>可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>2）<strong>禁止进行指令重排序。</strong></p></li><li><p><code>volatile</code>关键字不能保证数据的原子性。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 线程池 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL主从复制</title>
      <link href="/2023/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
      <url>/2023/08/30/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="简介">简介</h3><ul><li><p><strong>使用MySQL主从复制，进行读写分离</strong>：随着访问量的增大，数据的吞吐量面临瓶颈，对于同一时刻有大量的读操作，但是写操作较少的场景，可以将数据库拆分为主库和从库，<strong>主库负责数据库的增删改操作</strong>，<strong>从库负责读查询操作</strong>，能够有效的避免由数据更新导致的行锁，使系统的查询性能得到很大的提升。</p></li><li><p>MySQL 是一个异步的复制过程，底层是基于mysql数据库自带的<code>binlog</code>功能，就是一台或多台数据库（slave，即从库）从另一台MySQL数据库（master，即主库）进行日志的复制应用到自身，最终实现从库的数据和主库的数据保持一致。</p></li><li><p>MySQL主从复制是其自带功能，无需借助第三方工具。</p></li><li><p>MySQL 复制过程分为三步：</p><ul><li>master 将改变记录到<code>binlog</code>；</li><li>slave 将master的<code>binlog</code>拷贝到它的中继日志（<code>relay log</code>）；</li><li>slave 重做（<code>replay</code>）中继日志中的事件，将改变应用到自己的数据库中；</li></ul></li></ul><h3 id="配置">配置</h3><ul><li><p>配置主库（Master）：master 会将改变记录到二进制日志<code>binary log</code>。</p><ul><li><p>修改主库的配置文件 <strong>vim /etc/my.cnf</strong>，[mysqld]下添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=mysql-bin  <span class="comment">#启用二进制日志</span></span><br><span class="line">server-id=100  <span class="comment">#id作为服务器唯一标识，不一定要100，只要不重复即可</span></span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure></li><li><p>登录到mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li><li><p>创建一个用户叫<code>xiaoming</code>，密码是<code>Root@123456</code>，并给该用户授予<code>REPLICATION SLAVE</code>权限</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> xiaoming identified <span class="keyword">by</span> <span class="string">&#x27;Root@123456&#x27;</span>;</span><br><span class="line"><span class="keyword">grant</span> replication slave <span class="keyword">on</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">to</span> xiaoming;</span><br></pre></td></tr></table></figure></li><li><p>查看主库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      697 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line"> <span class="comment"># 日志名称           # 记录位置</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置从库（slave）：slave 将master的<code>binary log</code>拷贝到它的中继日志<code>relay log</code>。</p><ul><li><p>修改从库的配置文件 <strong>vim /etc/my.cnf</strong>，[mysqld]下添加如下代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server-id=101 <span class="comment">#必须是唯一的id，不能重复</span></span><br></pre></td></tr></table></figure></li><li><p>重启mysql服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart mysql</span><br></pre></td></tr></table></figure></li><li><p>登录mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li><li><p>执行语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> change master <span class="keyword">to</span> master_host<span class="operator">=</span><span class="string">&#x27;10.180.189.25&#x27;</span>,master_user<span class="operator">=</span><span class="string">&#x27;xiaoming&#x27;</span>,master_password<span class="operator">=</span><span class="string">&#x27;Root@123456&#x27;</span>,master_log_file<span class="operator">=</span><span class="string">&#x27;mysql-bin.000001&#x27;</span>,master_log_pos<span class="operator">=</span><span class="number">697</span>,get_master_public_key<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">start</span> slave;</span><br></pre></td></tr></table></figure></li><li><p>查看从库状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status\G</span><br></pre></td></tr></table></figure></li><li><p>若如下两个线程显示<code>Yes</code>则正常</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Slave_IO_Running:</span> <span class="literal">Yes</span></span><br><span class="line"><span class="attr">Slave_SQL_Running:</span> <span class="literal">Yes</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置成功，此时如果master发生改变，slave会重做中继日志中的事件，将改变也应用到自身的数据库中；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot实现登录拦截器</title>
      <link href="/2023/08/25/%20SpringBoot%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/"/>
      <url>/2023/08/25/%20SpringBoot%20%E5%AE%9E%E7%8E%B0%E7%99%BB%E5%BD%95%E6%8B%A6%E6%88%AA/</url>
      
        <content type="html"><![CDATA[<h2 id="登录拦截器">登录拦截器</h2><p>在 SpringBoot 开发的项目中，通过实现拦截器来实现用户登录拦截并验证。</p><p>所有的用户请求先经过拦截器，由拦截器判断是否放行，再送往<code>Controller</code>层。</p><h2 id="SpringBoot-实现登录拦截的原理">SpringBoot 实现登录拦截的原理</h2><ul><li><p>SpringBoot 通过实现<code>HandlerInterceptor</code>接口实现拦截器，通过实现<code>WebMvcConfigurer</code>接口实现一个配置类，在配置类中注入拦截器，最后再通过 <code>@Configuration </code>注解注入配置。</p></li><li><p>实现<code>HandlerInterceptor</code>接口，可以实现 3 个方法：<code>preHandle</code>、<code>postHandle</code>、<code>afterCompletion</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserLoginInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 在请求处理之前进行调用(Controller方法调用之前)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                             HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的preHandle方法&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line">            <span class="comment">//统一拦截（查询当前session是否存在user）(这里user会在每次登录成功后，写入session)</span></span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) session.getAttribute(USER_LOGIN_STATE);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//重定向登录页面</span></span><br><span class="line">            response.sendRedirect(request.getContextPath() + <span class="string">&quot;/user/login&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果设置为false时，被请求时，拦截器执行到此处将不会继续操作</span></span><br><span class="line">        <span class="comment">//如果设置为true时，请求将会继续执行后面的操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 请求处理之后进行调用，但是在视图被渲染之前（Controller方法调用之后）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, </span></span><br><span class="line"><span class="params">                           HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的postHandle方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">     * 整个请求结束之后被调用，也就是在DispatchServlet渲染了对应的视图之后执行（主要用于进行资源清理工作）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了拦截器的afterCompletion方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个拦截器，使得 <strong>Controller 在执行之前，都需要执行一遍<code>preHandle</code>。</strong></p></li><li><p>实现<code>WebMvcConfigurer</code>接口，注册拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//注册TestInterceptor拦截器</span></span><br><span class="line">        <span class="type">InterceptorRegistration</span> <span class="variable">registration</span> <span class="operator">=</span> registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">UserLoginInterceptor</span>());</span><br><span class="line">        <span class="comment">//所有路径都被拦截</span></span><br><span class="line">        registration.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">        <span class="comment">//添加不拦截路径</span></span><br><span class="line">        registration.excludePathPatterns(</span><br><span class="line">                <span class="string">&quot;/user/login&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/user/register&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/**/*.html&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/**/*.js&quot;</span>,</span><br><span class="line">                <span class="string">&quot;/**/*.css&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将拦截器注册到了拦截器列表中，并且指明了拦截哪些访问路径，不拦截哪些访问路径，不拦截哪些资源文件；最后再以 <code>@Configuration </code>注解将配置注入。</p></li><li><p>保持登录状态</p><p>在第一次正确登录之后，就将<code>user</code>保存到<code>session</code>中，再次访问页面的时候，登录拦截器就可以找到这个<code>user</code>对象，就不需要再次拦截到登录界面了。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 安装 Redis</title>
      <link href="/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/"/>
      <url>/2023/07/20/Ubuntu%20%E5%AE%89%E8%A3%85%20Redis/</url>
      
        <content type="html"><![CDATA[<ul><li><p>下载稳定版本Redis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/redis-stable.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzvf redis-stable.tar.gz -C /usr/local</span><br></pre></td></tr></table></figure></li><li><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis-stable</span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure></li><li><p>可能出现的报错：</p><ul><li><p>没有找到 make</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make</span><br></pre></td></tr></table></figure></li><li><p><code>/bin/sh: 1: pkg-config: not found</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install pkg-config</span><br></pre></td></tr></table></figure></li><li><p><code>/bin/sh: 1: cc: not found</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gcc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动Redis服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis-stable/src$ ./redis-server</span><br><span class="line"><span class="comment"># 注意这种方式启动 redis 使用的是默认配置。</span></span><br><span class="line"><span class="comment"># 也可以通过启动参数告诉 redis 使用指定配置文件使用下面命令启动。</span></span><br><span class="line"><span class="comment"># ./redis-server ../redis.conf</span></span><br></pre></td></tr></table></figure></li><li><p>连接Redis服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis-stable/src$ ./redis-cli</span><br></pre></td></tr></table></figure></li><li><p>常用配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim </span><br><span class="line">daemonize <span class="built_in">yes</span>  <span class="comment"># 守护进程，后台运行</span></span><br><span class="line">requeirepass xxx   <span class="comment"># 设置密码</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题总结</title>
      <link href="/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/18/Leetcode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="栈和队列">栈和队列</h2><ul><li><p><a href="https://leetcode.cn/problems/min-stack-lcci">最小栈</a>：请设计一个栈，除了常规栈支持的pop与push函数以外，还支持min函数，该函数返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackData; <span class="comment">// 栈数据</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackMin; <span class="comment">// 栈的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackData = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.stackMin = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackData.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> <span class="built_in">this</span>.stackData.pop();</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="built_in">this</span>.getMin()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackData.push(x);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.stackMin.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.peek() &gt;= x) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stackMin.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.stackMin.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackMin.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackMin.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line"></span><br><span class="line">    MyQueue1() &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackPush = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.stackPop = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stackPush.push(x);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackPop.isEmpty()) &#123;</span><br><span class="line">            pushToPop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// push栈元素压到pop栈，pop栈顶永远是优先级最高的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushToPop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackPop.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!<span class="built_in">this</span>.stackPush.isEmpty()) &#123;</span><br><span class="line">                <span class="built_in">this</span>.stackPop.push(<span class="built_in">this</span>.stackPush.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.stackPush.isEmpty() &amp;&amp; <span class="built_in">this</span>.stackPop.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        pushToPop();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackPop.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>汉诺塔问题</strong>：求有N层塔时，打印最优移动过程和最优移动总步数；注：移动时不能跳步，即必须经过中间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 小压大原则</span></span><br><span class="line"><span class="comment">// 2. 不可逆原则：若要求最小步数，则相邻操作之间不可逆</span></span><br><span class="line"><span class="comment">//     如果上一步是 L-&gt;M，则下一步绝对不是 M-&gt;L</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HanoiProblem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">        No, LToM, MToR, RToM, MToL</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minStep</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; left = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; mid = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; right = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        left.push(Integer.MAX_VALUE);</span><br><span class="line">        mid.push(Integer.MAX_VALUE);</span><br><span class="line">        right.push(Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            left.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        State[] record = &#123;State.No&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (right.size() != n + <span class="number">1</span>) &#123;</span><br><span class="line">            step += process(record, State.MToL, State.LToM, left, mid, <span class="string">&quot;left&quot;</span>, <span class="string">&quot;mid&quot;</span>);</span><br><span class="line">            step += process(record, State.RToM, State.MToR, mid, right, <span class="string">&quot;mid&quot;</span>, <span class="string">&quot;right&quot;</span>);</span><br><span class="line">            step += process(record, State.MToR, State.RToM, right, mid, <span class="string">&quot;right&quot;</span>, <span class="string">&quot;mid&quot;</span>);</span><br><span class="line">            step += process(record, State.LToM, State.MToL, mid, left, <span class="string">&quot;mid&quot;</span>, <span class="string">&quot;left&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process</span><span class="params">(State[] record, State preNoAct, State nowAct, Stack&lt;Integer&gt; s1, Stack&lt;Integer&gt; s2, String from, String to)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (record[<span class="number">0</span>] != preNoAct &amp;&amp; s1.peek() &lt; s2.peek()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> s1.pop();</span><br><span class="line">            s2.push(val);</span><br><span class="line">            System.out.println(<span class="string">&quot;move &quot;</span> + val + <span class="string">&quot; from &quot;</span> + from + <span class="string">&quot; to &quot;</span> + to);</span><br><span class="line">            record[<span class="number">0</span>] = nowAct;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(minStep(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>用一个栈实现另一个栈的排序</strong>：将一个整数类型的栈从顶到底按从大到小的顺序排序，只能申请一个栈。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortStack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; help = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); <span class="comment">// 辅助栈</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="keyword">while</span> (!help.isEmpty() &amp;&amp; help.peek() &lt; cur) &#123;</span><br><span class="line">                stack.push(help.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            help.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!help.isEmpty()) &#123;</span><br><span class="line">            stack.push(help.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">滑动窗口的最大值</a></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], 和 w = <span class="number">3</span></span><br><span class="line">输出: [<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>] </span><br><span class="line">解释: </span><br><span class="line">  滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[<span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>] -<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span> [<span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>] <span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">3</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span> [-<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span>] <span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span> [-<span class="number">3</span>  <span class="number">5</span>  <span class="number">3</span>] <span class="number">6</span>  <span class="number">7</span>       <span class="number">5</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span> [<span class="number">5</span>  <span class="number">3</span>  <span class="number">6</span>] <span class="number">7</span>       <span class="number">6</span></span><br><span class="line"> <span class="number">1</span>  <span class="number">3</span>  -<span class="number">1</span>  -<span class="number">3</span>  <span class="number">5</span> [<span class="number">3</span>  <span class="number">6</span>  <span class="number">7</span>]      <span class="number">7</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxWindow</span> &#123;</span><br><span class="line">    <span class="comment">// 方法一，暴力枚举，但是会超时</span></span><br><span class="line">    <span class="comment">// O(N x w)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getMaxWindow1(<span class="type">int</span>[] arr, <span class="type">int</span> w) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> w;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">maxVal</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; right; i++) &#123;</span><br><span class="line">                maxVal = Math.max(maxVal, arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            res[left] = maxVal;</span><br><span class="line">            left++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法二：双端队列实现，复杂度O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] getMaxWindow2(<span class="type">int</span>[] arr, <span class="type">int</span> w) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - w + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); <span class="comment">// 双端队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!dq.isEmpty() &amp;&amp; arr[dq.peekLast()] &lt;= arr[i]) &#123;</span><br><span class="line">                dq.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            dq.addLast(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 队头下标已过期</span></span><br><span class="line">            <span class="keyword">if</span> (dq.peekFirst() == i - w) &#123;</span><br><span class="line">                dq.pollFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= w - <span class="number">1</span>) &#123;</span><br><span class="line">                res[index++] = arr[dq.peekFirst()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="链表">链表</h2><p>重要技巧：</p><p>（1）特殊数据结构，如数组，哈希表等；</p><p>（2）快慢指针；</p><ul><li><p><a href="https://leetcode.cn/problems/reverse-linked-list/">反转单向链表</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">reverseNode</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            next = head.next; <span class="comment">// 记录后继节点</span></span><br><span class="line">            head.next = pre; <span class="comment">// 当前节点指向前继节点</span></span><br><span class="line">            pre = head;  <span class="comment">// 更新前继节点</span></span><br><span class="line">            head = next; <span class="comment">// 更新当前节点为后继节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">删除单链表中倒数第k个节点</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveLastNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">removeNode</span><span class="params">(Node head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || k &lt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">0</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 删除头节点</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span>) &#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/linked-list-cycle-lcci/">环路检测</a>：给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。若环不存在，请返回 <code>null</code>。</p><p>思路：</p><p>（1）设置快慢指针<code>slow</code>和<code>fast</code>进行遍历，若fast遇到终点（null）则链表无环；</p><p>（2）若链表有环，则快慢指针一定在某个环内位置相遇，此时<code>fast</code>指针回到<code>head</code>的位置，每次走一步，<code>slow</code>指针不变，继续遍历，则两指针一定在环的入口相遇；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DetectCycle</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">detectCycle</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                fast = head;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">判断两个链表是否相交</a>：给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IntersectionNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getIntersectionNode</span><span class="params">(Node headA, Node headB)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n1</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">n2</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span> (n1 != n2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n1 == <span class="literal">null</span>) n1 = headA;</span><br><span class="line">            <span class="keyword">else</span> n1 = n1.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n2 == <span class="literal">null</span>) n2 = headB;</span><br><span class="line">            <span class="keyword">else</span> n2 = n2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="字符串">字符串</h2><ul><li><p><a href="https://leetcode.cn/problems/reverse-string/"> 反转字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/reverse-string-ii/">反转字符串 II</a>：给定一个字符串 <code>s</code> 和一个整数 <code>k</code>，从字符串开头算起，每计数至 <code>2k</code> 个字符，就反转这 <code>2k</code> 字符中的前 <code>k</code> 个字符。</p><ul><li>如果剩余字符少于 <code>k</code> 个，则将剩余字符全部反转。</li><li>如果剩余字符小于 <code>2k</code> 但大于或等于 <code>k</code> 个，则反转前 <code>k</code> 个字符，其余字符保持原样。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseStr</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i += <span class="number">2</span> * k) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剩余字符小于 2k 但大于或等于 k 个，反转前 k 个字符</span></span><br><span class="line">            <span class="keyword">if</span> (str.length &gt;= i + k) &#123;</span><br><span class="line">                reverse(str, i, i + k - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 剩余字符少于 k 个，将剩余字符全部反转</span></span><br><span class="line">            reverse(str, i, str.length - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> String.copyValueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = tmp;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">替换空格</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span>  <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==<span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">反转字符串中的单词</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseWords</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s</span><br><span class="line">                .trim() <span class="comment">// 去除头尾空白符</span></span><br><span class="line">                .split(<span class="string">&quot; &quot;</span>); <span class="comment">// 以空格来分隔字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">reverseString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (strs[i] == <span class="string">&quot;&quot;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            reverseString.append(strs[i]);</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                reverseString.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverseString.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">剑指 Offer 58 - II. 左旋转字符串</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseLeftWords</span> &#123;</span><br><span class="line">    <span class="comment">// 1.反转区间为前n的子串</span></span><br><span class="line">    <span class="comment">// 2.反转区间为n到末尾的子串</span></span><br><span class="line">    <span class="comment">// 3.反转整个字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        reverse(str, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(str, n, s.length() - <span class="number">1</span>);</span><br><span class="line">        reverse(str, <span class="number">0</span>, s.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> String.copyValueOf(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反转字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> str[start];</span><br><span class="line">            str[start] = str[end];</span><br><span class="line">            str[end] = tmp;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">找出字符串中第一个匹配项的下标</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrStr</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length()) &#123;</span><br><span class="line">            temp = i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 逐个匹配</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; haystack.length() &amp;&amp; j &lt; needle.length() </span><br><span class="line">                                         &amp;&amp; haystack.charAt(i) == needle.charAt(j)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 匹配成功</span></span><br><span class="line">            <span class="keyword">if</span> (j == needle.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - needle.length();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下个位置继续匹配</span></span><br><span class="line">            i = temp + <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串</a></p><p>判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，<strong>要刨除 s + s 的首字符和尾字符</strong>，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatedSubstringPattern</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ss</span> <span class="operator">=</span> s + s;</span><br><span class="line">        <span class="type">String</span> <span class="variable">substring</span> <span class="operator">=</span> ss.substring(<span class="number">1</span>, ss.length() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> substring.contains(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(repeatedSubstringPattern(<span class="string">&quot;abaaba&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二叉树">二叉树</h2><ul><li><p>二叉树前序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreOrderTraverse</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        preOrderRecur(root.left);</span><br><span class="line">        preOrderRecur(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树中序遍历</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InOrderTraverse</span> &#123;</span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrderRecur(root.left);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        inOrderRecur(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 非递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderUnRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() || cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 先依次将左边界入栈</span></span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = s.pop();</span><br><span class="line">                System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二叉树后序遍历</p><p>后续遍历关键在于，当节点的 <strong>右子树存在且被访问后</strong> 或者是 <strong>右子树为空</strong> 才能访问自身。</p><p>在遍历过程中，先将节点从的左孩子到最左节点压栈， 设置标志变量 flag 来判断是否访问过左孩子， pre指针来指向先前访问过的节点。所有左孩子压栈后， 最后一个节点的左孩子为空（已被访问） ， 令flag=1；</p><p>当左孩子被访问时，进入循环，取栈顶节点：</p><ol><li><p>当栈顶节点的右孩子 等于 <strong>空</strong> 或 <strong>前一个被访问的节点</strong> 时， 访问该节点， 令pre 等于当前节点， 当前节点出栈。</p></li><li><p>当栈顶节点的右孩子**不为空 **时， 继续遍历以右孩子为根节点的右子树。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PostOrderTraverse</span> &#123;</span><br><span class="line">    <span class="comment">// 递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        postOrderRecur(root.left);</span><br><span class="line">        postOrderRecur(root.right);</span><br><span class="line">        System.out.print(root.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非递归遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">postOrderUnRecur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 前一个被访问的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 所有左节点入栈</span></span><br><span class="line">            <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; flag == <span class="number">1</span>) &#123;</span><br><span class="line">                cur = s.peek();</span><br><span class="line">                <span class="comment">// 若当前节点的右节点是【上一个被访问的节点】 或为【空】，则访问该节点</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right == <span class="literal">null</span> || cur.right == pre) &#123;</span><br><span class="line">                    s.pop();</span><br><span class="line">                    System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                    pre = cur;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//继续遍历右子树</span></span><br><span class="line">                    cur = cur.right;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!s.isEmpty());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一种思路</strong>：由于前序遍历的顺序是 ”中左右“，后序遍历的顺序是”左右中“，因此更改前序遍历中的入栈顺序，然后将遍历结果反转，便能得到后序遍历的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/"> 二叉树的最大深度</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left) + <span class="number">1</span>, maxDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">二叉树的最小深度</a>：最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果左子树为空，右子树不为空，最小深度是 1 + 右子树的最小深度。</span></span><br><span class="line"><span class="comment">// 反之，右子树为空，左子树不为空，最小深度是 1 + 左子树的最小深度。 </span></span><br><span class="line"><span class="comment">// 如果左右子树都不为空，返回 1 + 左右子树深度最小值。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right != <span class="literal">null</span>) <span class="keyword">return</span> minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(minDepth(root.left) + <span class="number">1</span>, minDepth(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/invert-binary-tree/">翻转二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 交换左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/symmetric-tree/">对称二叉树</a>：判断二叉树是否为轴对称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSame(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode t1,TreeNode t2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">null</span> &amp;&amp; t2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">null</span> || t2==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(t1.val != t2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isSame(t1.left,t2.right) &amp;&amp; isSame(t1.right,t2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/balanced-binary-tree/">平衡二叉树</a>：平衡二叉树的<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BalanceTree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h1</span> <span class="operator">=</span> getHeight(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">h2</span> <span class="operator">=</span> getHeight(root.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(h1 - h2) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求某个节点的最大高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> Math.max(getHeight(root.left) + <span class="number">1</span>, getHeight(root.right) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/binary-tree-paths/">二叉树的所有路径</a>：给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreePaths</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; paths = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        dfs(root, paths, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, List&lt;String&gt; paths, String path)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        path += root.val;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            paths.add(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(root.left, paths, path + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        dfs(root.right, paths, path + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/sum-of-left-leaves/">左叶子之和</a>：给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftLeaves</span> &#123;</span><br><span class="line">    <span class="comment">// 递归法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            res += root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res + sumOfLeftLeaves1(root.left) + sumOfLeftLeaves1(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        s.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> s.pop();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.left == <span class="literal">null</span> &amp;&amp; node.left.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                res += node.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) s.push(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) s.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">找树左下角的值</a>：给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层最左边</strong> 节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用层序遍历，最后一层的第一个值即为左下角的值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) res = node.val; <span class="comment">// 记录最后一层第一个值</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) q.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) q.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/path-sum/">路径总和</a>：给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> 。判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathSum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        targetSum -= root.val;</span><br><span class="line">        <span class="comment">// 找到一条路径</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> hasPathSum(root.left, targetSum);</span><br><span class="line">            <span class="keyword">if</span> (left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> hasPathSum(root.right, targetSum);</span><br><span class="line">            <span class="keyword">if</span> (right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">从中序与后序遍历序列构造二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildTree1</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i); <span class="comment">// 保存中序序列值得对应位置，方便查询</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(inorder, <span class="number">0</span>, n, postorder, <span class="number">0</span>, n); <span class="comment">// 左闭右开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || postBegin &gt;= postEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到后序遍历的最后一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(postorder[postEnd - <span class="number">1</span>]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = helper(inorder, inBegin, rootIndex, </span><br><span class="line">                           postorder, postBegin, postBegin + lenOfLeft);</span><br><span class="line">        root.right = helper(inorder, rootIndex + <span class="number">1</span>, inEnd, </span><br><span class="line">                           postorder, postBegin + lenOfLeft, postEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">从前序和中序遍历序列构造二叉树</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildTree2</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> inorder.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i); <span class="comment">// 保存中序序列值得对应位置，方便查询</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> helper(preorder, <span class="number">0</span>, n, inorder, <span class="number">0</span>, n); <span class="comment">// 左闭右开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd,</span></span><br><span class="line"><span class="params">                           <span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd)</span> &#123;</span><br><span class="line">        <span class="comment">// 不满足左闭右开，说明没有元素，返回空树</span></span><br><span class="line">        <span class="keyword">if</span> (inBegin &gt;= inEnd || preBegin &gt;= preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到前序遍历的第一个元素在中序遍历中的位置</span></span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(preorder[preBegin]);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(inorder[rootIndex]);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">lenOfLeft</span> <span class="operator">=</span> rootIndex - inBegin;  <span class="comment">// 保存中序左子树个数，用来确定后序数列的个数</span></span><br><span class="line">        root.left = helper(preorder, preBegin + <span class="number">1</span>, preBegin + lenOfLeft + <span class="number">1</span>,</span><br><span class="line">                           inorder, inBegin, rootIndex);</span><br><span class="line">        root.right = helper(preorder, preBegin + lenOfLeft + <span class="number">1</span>, preEnd,</span><br><span class="line">                           inorder, rootIndex + <span class="number">1</span>, inEnd);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/validate-binary-search-tree/"> 验证二叉搜索树</a>：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对于一个合法的二叉搜索树，节点的左子树只包含 小于 当前节点的数，节点的右子树只包含 大于 当前节点的数。</span></span><br><span class="line"><span class="comment"> * 因此，它的中序遍历是升序的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">pre</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 访问左子树</span></span><br><span class="line">        <span class="keyword">if</span> (!isValidBST(root.left)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root.val;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 访问右子树</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/"> 二叉树的最近公共祖先</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历,自底向上</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 未找到节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">null</span>) <span class="keyword">return</span> right; <span class="comment">// 目标节点在右边找到</span></span><br><span class="line">        <span class="keyword">if</span> (right == <span class="literal">null</span>) <span class="keyword">return</span> left; <span class="comment">// 目标节点在左边找到</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果left和right都不为空，则最近公共祖先就是root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/"> 二叉搜索树的最近公共祖先</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 利用二叉搜索树的性质：</span></span><br><span class="line"><span class="comment">         * 1. 若p和q节点的值都比当前节点的值小，则目标节点在左子树</span></span><br><span class="line"><span class="comment">         * 2. 若p和q节点的值都比当前节点的值大，则目标节点在右子树</span></span><br><span class="line"><span class="comment">         * 3. 若p和q节点的值在当前节点值得两边，则目标节点为当前节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="回溯">回溯</h2><ul><li><p>回溯算法模板</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * --&gt;循环体，树的宽度--&gt;                    </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归，树的深度 </span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/combinations/">组合</a>：给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Combine</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    LinkedList&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        process(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path)); <span class="comment">// 存放结果</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= n-(k-path.size())+<span class="number">1</span>; i++) &#123; <span class="comment">// jian&#x27;zhi</span></span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            process(n, k, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.removeLast(); <span class="comment">// 回溯，撤销处理结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/combination-sum-iii/">组合总和 III</a>：找出所有相加之和为 <code>n</code> 的 <code>k</code> 个数的组合，且满足下列条件：</p><ul><li>只使用数字1到9</li><li>每个数字 <strong>最多使用一次</strong></li></ul><p>返回<em>所有可能的有效组合的列表</em> 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationSum3</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    LinkedList&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        process(n, k, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span> k, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (path.size() == k &amp;&amp; target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.add(i);</span><br><span class="line">            target -= i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            process(target, k, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            target += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/combination-sum/">组合总和</a>：给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的所有 不同组合 ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。<code>candidates</code> 中的 同一个 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CombinationSum</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    LinkedList&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        process(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            process(candidates, target, i); <span class="comment">// 关键：不用递归 i+1, 表示元素可以被重复取到</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            target += candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">电话号码的字母组合</a>：给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LetterCombinations</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[][] map = &#123;&#123;&#125;, &#123;&#125;, &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;, &#123;<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;, &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>&#125;, &#123;<span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>&#125;,</span><br><span class="line">                   &#123;<span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;, &#123;<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>&#125;, &#123;<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>&#125;, &#123;<span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        process(digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String digits, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 终止条件</span></span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">char</span>[] str = map[digit];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            sb.append(str[i]);</span><br><span class="line">            process(digits, index + <span class="number">1</span>); <span class="comment">// 由于是不同数字之间组合，所以是 index与 index+1 ...之间组合</span></span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>); <span class="comment">// 回溯，重新尝试</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/combination-sum-ii/">组合总和 II</a>：给定一个候选人编号的集合 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。<code>candidates</code> 中的每个数字在每个组合中只能使用 <strong>一次</strong> 。注意：**解集不能包含重复的组合。 **</p><p>由于<code>candidates</code>中存在重复元素，因此本题的关键在于如何去重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    LinkedList&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates); <span class="comment">// 排序，使相同元素在一起</span></span><br><span class="line">        process(candidates, target, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="comment">// 剪枝</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path);</span><br><span class="line"><span class="comment">//            // 简单判断去重，但是会超时</span></span><br><span class="line"><span class="comment">//            if (!res.contains(tmp)) &#123;</span></span><br><span class="line"><span class="comment">//                res.add(tmp);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            res.add(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 去重</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 处理节点</span></span><br><span class="line">            path.add(candidates[i]);</span><br><span class="line">            target -= candidates[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归</span></span><br><span class="line">            process(candidates, target, i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            target += candidates[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">分割回文串</a>：给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是 <strong>回文串</strong> 。返回 <code>s</code> 所有可能的分割方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PalindromePartition</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        process(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String s, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= s.length()) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isPalindrome(s, index, i)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(index, i + <span class="number">1</span>);</span><br><span class="line">                path.add(tmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            process(s, i + <span class="number">1</span>); <span class="comment">// 递归</span></span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>); <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断回文</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/subsets/">子集</a>：给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Subsets</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()); <span class="comment">// 空集</span></span><br><span class="line">        process(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!res.contains(path)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) <span class="keyword">return</span>; <span class="comment">// 说明找完了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            process(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/subsets-ii/">子集 II</a>：给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Subsets2</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res;</span><br><span class="line">    List&lt;Integer&gt; path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;()); <span class="comment">// 空集</span></span><br><span class="line">        process(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!res.contains(path)) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) <span class="keyword">return</span>; <span class="comment">// 说明找完了</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; index &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            process(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/">递增子序列</a>：给你一个整数数组 <code>nums</code> ，找出并返回所有该数组中不同的递增子序列，递增子序列中 <strong>至少有两个元素</strong> 。你可以按 <strong>任意顺序</strong> 返回答案。数组中可能含有重复元素，如出现<strong>两个整数相等，也可以视作递增序列的一种特殊情况</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        process(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashSet 去重</span></span><br><span class="line">        HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>) || hs.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            hs.add(nums[i]);</span><br><span class="line">            process(nums, i + <span class="number">1</span>);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/permutations/">全排列</a>：给定一个不含重复数字的数组 <code>nums</code> ，返回其<em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permute</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        process(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 全排列问题，每次都需要从头开始搜索,因此不用参数index</span></span><br><span class="line"><span class="comment">     * used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            process(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/permutations-ii/"> 全排列 II</a>：给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有<strong>不重复</strong>的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermuteUnique</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        process(nums, used);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">boolean</span>[] used)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == nums.length) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// HashSet 去重</span></span><br><span class="line">        HashSet&lt;Integer&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (used[i] || hs.contains(nums[i])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            hs.add(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            process(nums, used);</span><br><span class="line">            <span class="comment">// 回溯</span></span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/n-queens/">N 皇后</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                matrix[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        process(matrix,n,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(<span class="type">char</span>[][] matrix, <span class="type">int</span> n, <span class="type">int</span> row)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">            List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (k &lt; n) &#123;</span><br><span class="line">                    sb.append(matrix[i][k++]);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isValid(matrix, row, col, n)) &#123;</span><br><span class="line">                matrix[row][col] = <span class="string">&#x27;Q&#x27;</span>; <span class="comment">// 放置皇后</span></span><br><span class="line">                process(matrix, n, row + <span class="number">1</span>);</span><br><span class="line">                matrix[row][col] = <span class="string">&#x27;.&#x27;</span>; <span class="comment">// 回溯，撤销</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否合法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] matrix, <span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 检查列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][col] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="贪心算法">贪心算法</h2><ul><li><p><a href="https://leetcode.cn/problems/assign-cookies/">分发饼干</a>：对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiscuitDistribution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> g.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (child &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能分配</span></span><br><span class="line">            <span class="keyword">while</span> (child &gt; <span class="number">0</span> &amp;&amp; s[i] &lt; g[child]) &#123;</span><br><span class="line">                child--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 可以分配</span></span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= g[child]) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                child--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/wiggle-subsequence/">摆动序列</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WiggleSubsequence</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((cur &gt; <span class="number">0</span> &amp;&amp; pre &lt;= <span class="number">0</span>) || (cur &lt; <span class="number">0</span> &amp;&amp; pre &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                pre = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/maximum-subarray/">最大子数组和</a>：给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSubArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            count += nums[i];</span><br><span class="line">            res = Math.max(res, count);</span><br><span class="line">            <span class="comment">// 重置，因为遇到负数一定会使res减小</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                count = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a>：给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。</span></span><br><span class="line"><span class="comment"> * 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。</span></span><br><span class="line"><span class="comment"> * 就是把利润分解为每天为单位的维度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans += Math.max(<span class="number">0</span>, prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a>：给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxProfit</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans = Math.max(prices[i] - prices[i - <span class="number">1</span>], ans);</span><br><span class="line">            prices[i] = Math.min(prices[i], prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/jump-game/">跳跃游戏</a>：给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</span></span><br><span class="line"><span class="comment"> * 贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">coverRange</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= coverRange; i++) &#123;</span><br><span class="line">            coverRange = Math.max(coverRange, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (coverRange &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/jump-game-ii/">跳跃游戏 II</a>：给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向前跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code></li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            next = Math.max(next, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (next &gt;= nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">                step++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == cur) &#123;</span><br><span class="line">                cur = next;</span><br><span class="line">                step++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/gas-station/">加油站</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 暴力模拟 O(n^2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> gas[i] - cost[i]; <span class="comment">// 剩余油量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> (i+<span class="number">1</span>) % gas.length; <span class="comment">// 模拟出发的位置</span></span><br><span class="line">            <span class="keyword">while</span>(rest&gt;<span class="number">0</span> &amp;&amp; pos!=i)&#123;</span><br><span class="line">                rest += gas[pos] - cost[pos];</span><br><span class="line">                pos = (pos + <span class="number">1</span>) % gas.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(rest&gt;=<span class="number">0</span> &amp;&amp; pos==i)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 贪心 O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;gas.length;i++)&#123;</span><br><span class="line">            rest += gas[i] - cost[i]; </span><br><span class="line">            total += gas[i] - cost[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果之前累加剩余油量为负值，则肯定无法从i之前的位置到达</span></span><br><span class="line">            <span class="keyword">if</span>(rest&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                pos = i + <span class="number">1</span>;</span><br><span class="line">                rest = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(total&lt;<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/candy/">分发糖果</a>：<code>n</code> 个孩子站成一排。给你一个整数数组 <code>ratings</code> 表示每个孩子的评分。你需要按照以下要求，给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 <code>1</code> 个糖果。</li><li>相邻两个孩子评分更高的孩子会获得更多的糖果。</li></ul><p>请你给每个孩子分发糖果，计算并返回需要准备的 <strong>最少糖果数目</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本题采用了两次贪心的策略。</span></span><br><span class="line"><span class="comment"> * 一次是从左到右遍历，只比较右边孩子评分比左边大的情况。</span></span><br><span class="line"><span class="comment"> * 一次是从右到左遍历，只比较左边孩子评分比右边大的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Candy</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">candy</span><span class="params">(<span class="type">int</span>[] ratings)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] candys = <span class="keyword">new</span> <span class="title class_">int</span>[ratings.length];</span><br><span class="line">        candys[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前往后，右边比左边大的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; ratings.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candys[i] = candys[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                candys[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从前往后，左边比右边大的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ratings.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                candys[i] = Math.max(candys[i + <span class="number">1</span>] + <span class="number">1</span>, candys[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> candy : candys) &#123;</span><br><span class="line">            res += candy;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h2 id="动态规划">动态规划</h2><ul><li><p><a href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">使用最小花费爬楼梯</a>：给你一个整数数组 <code>cost</code> ，其中 <code>cost[i]</code> 是从楼梯第 <code>i</code> 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 <code>0</code> 或下标为 <code>1</code> 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>]; <span class="comment">// dp[i]表示爬前i个楼梯所需的最小花费</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i - <span class="number">2</span>] + cost[i - <span class="number">2</span>];</span><br><span class="line">            dp[i] = Math.min(p1, p2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/house-robber/">打家劫舍</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; nums.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(nums[index] + helper(nums, index + <span class="number">2</span>), helper(nums, index + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] money = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 偷盗前i个房屋，能获得的最大价值</span></span><br><span class="line">        money[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        money[<span class="number">1</span>] = Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            money[i] = Math.max(nums[i] + money[i - <span class="number">2</span>], money[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两种情况：取首或取尾</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(helper(nums, <span class="number">0</span>, n - <span class="number">2</span>), helper(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">helper</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] money = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length]; <span class="comment">// 偷盗前i个房屋，能获得的最大价值</span></span><br><span class="line">        money[start] = nums[start];</span><br><span class="line">        money[start + <span class="number">1</span>] = Math.max(nums[start], nums[start + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start + <span class="number">2</span>; i &lt;= end; i++) &#123;</span><br><span class="line">            money[i] = Math.max(nums[i] + money[i - <span class="number">2</span>], money[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/house-robber-iii/">打家劫舍 III</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            val1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            val1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 优化</span></span><br><span class="line">    <span class="comment">// 通过map记录计算过的节点，降低时间复杂度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经计算过，则直接返回结果</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val1</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="comment">// 偷父节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            val1 += rob(root.left.left) + rob(root.left.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            val1 += rob(root.right.left) + rob(root.right.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不偷父节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val2</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        map.put(root, Math.max(val1, val2)); <span class="comment">// 记录中间结果</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(val1, val2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a>：一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotPath</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] matrix = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        dfs(matrix, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; matrix.length - <span class="number">1</span> ||</span><br><span class="line">                y &gt; matrix[<span class="number">0</span>].length - <span class="number">1</span> || matrix[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到一条路径</span></span><br><span class="line">        <span class="keyword">if</span> (x == matrix.length - <span class="number">1</span> &amp;&amp; y == matrix[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        matrix[x][y] = <span class="number">1</span>; <span class="comment">// 标记，已经过的位置</span></span><br><span class="line">        dfs(matrix, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(matrix, x, y + <span class="number">1</span>);</span><br><span class="line">        matrix[x][y] = <span class="number">0</span>; <span class="comment">// 回溯，撤回结果</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths2</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n]; <span class="comment">// dp[i][j]表示到达(i,j)的路径数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/unique-paths-ii/">不同路径 II</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotPathII</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles1</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        dfs(obstacleGrid, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] ob, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; ob.length - <span class="number">1</span> || y &gt; ob[<span class="number">0</span>].length - <span class="number">1</span> || ob[x][y] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == ob.length - <span class="number">1</span> &amp;&amp; y == ob[<span class="number">0</span>].length - <span class="number">1</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        ob[x][y] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        dfs(ob, x + <span class="number">1</span>, y);</span><br><span class="line">        dfs(ob, x, y + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        ob[x][y] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles2</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];  <span class="comment">// dp[i][j]:到达(i,j)的路径数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/unique-paths-iii/">不同路径 III</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotPathIII</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePathsIII</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">rest</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 起点到终点需要一步（无障碍）</span></span><br><span class="line">        <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    start[<span class="number">0</span>] = i;</span><br><span class="line">                    start[<span class="number">1</span>] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    rest++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dfs(grid, start[<span class="number">0</span>], start[<span class="number">1</span>], rest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span> || x &gt; grid.length - <span class="number">1</span> || y &gt; grid[<span class="number">0</span>].length - <span class="number">1</span> || grid[x][y] == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> rest == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        grid[x][y] = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        sum += dfs(grid, x + <span class="number">1</span>, y, rest - <span class="number">1</span>);</span><br><span class="line">        sum += dfs(grid, x, y + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">        sum += dfs(grid, x - <span class="number">1</span>, y, rest - <span class="number">1</span>);</span><br><span class="line">        sum += dfs(grid, x, y - <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        grid[x][y] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web开发相关</title>
      <link href="/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/"/>
      <url>/2023/07/16/Web%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="Web访问流程">Web访问流程</h2><ul><li>1、输入地址</li><li>2、浏览器查找域名的 IP 地址</li><li>3、浏览器向 <code>web</code> 服务器发送一个 <code>HTTP</code> 请求</li><li>4、服务器的永久重定向响应</li><li>5、浏览器跟踪重定向地址</li><li>6、服务器处理请求</li><li>7、服务器返回一个 <code>HTTP</code> 响应</li><li>8、浏览器显示 <code>HTML</code></li><li>9、浏览器发送请求获取嵌入在 <code>HTML</code> 中的资源（如图片、音频、视频、CSS、JS等等）</li></ul><h2 id="TCP-IP协议">TCP/IP协议</h2><ul><li><p>四个概念层</p><ul><li><strong>应用层</strong>：为用户提供所需要的各种服务；应用层协议包括HTTP（万维网服务）、FTP（文件传输）、SMTP（电子邮件）、SSH（安全远程登陆）、DNS（域名解析）以及许多其他协议。</li><li><strong>传输层</strong>：为应用层实体提供端到端的通信功能，保证了数据包的传输顺序和数据的的完整性；<strong>TCP</strong>传输控制协议和<strong>UDP</strong>用户数据报协议。<ul><li><strong>TCP</strong>协议是一个<strong>面向连接的、可靠的</strong>传输协议，它提供一种可靠的字节流，能保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。</li><li><strong>UDP</strong>协议是一个<strong>面向无连接</strong>的数据报协议，是一个**“尽力传递”和“不可靠”**协议，不会对数据包是否已经到达目的地进行检查，并且不保证数据包按顺序到达。</li><li>总体来说，TCP协议传输效率低，但可靠性强；UDP协议传输效率高，但可靠性略低，适用于传输可靠性要求不高、体量小的数据（比如QQ聊天数据）。</li></ul></li><li><strong>网络层</strong>：主要解决主机到主机之间的通信问题；网络层协议的代表包括：ICMP、IP、IGMP等。</li><li><strong>链路层</strong>：其主要协议有ARP、RARP等。</li></ul></li><li><p><strong>IP协议</strong></p><ul><li>互联网上每个计算机的<strong>唯一标识</strong>就是IP地址；</li><li><strong>分组传输</strong>：IP协议将数据分成若干个数据包进行传输，每个数据包包含了目标地址等信息。</li><li><strong>不可靠传输</strong>：IP协议不保证数据包的可靠传输，数据包在传输过程中可能会丢失、重复或乱序。</li><li><strong>简单路由</strong>：IP协议使用简单的路由算法，每个路由器只根据目标地址来选择下一个路由器，而不考虑其他因素。</li><li><strong>网络层协议</strong>：IP协议位于网络层，它与上层协议（如TCP、UDP）和下层协议（如数据链路层）进行交互。</li></ul></li><li><p><strong>IPV4</strong></p><ul><li>共四组，每组8个<code>bit</code>；如<code>192.168.1.10</code>；</li><li>共$2^{32}$ 个IP地址，目前已经分配完了；</li></ul></li><li><p><strong>IPV6</strong></p><ul><li>共八组，每组16个<code>bit</code>；</li><li>共$2^{128}$个IP地址；</li></ul></li><li><p><strong>特殊IP</strong></p><ul><li><code>127.0.0.1</code>也称<code>localhost:</code>，本地IP，永远只会寻找本地IP；</li></ul></li><li><p><strong>TCP协议</strong></p><ul><li><p>建立在IP协议之上，负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。</p></li><li><p><strong>TCP三次握手</strong></p><ul><li><p>客户端向服务器发送SYN（同步）数据包，表示客户端想要建立连接，并告诉服务器自己的初始序号（seq=x）。</p></li><li><p>服务器接收到客户端的SYN数据包后，向客户端发送SYN+ACK（同步和确认）数据包，表示服务器已经收到了客户端的请求，并告诉客户端自己的初始序号（seq=y）和确认序号（ack=x+1）。</p></li><li><p>客户端接收到服务器的SYN+ACK数据包后，向服务器发送ACK（确认）数据包，告诉服务器已经收到了服务器的确认，并确认自己的序列号（seq=x+1），服务器的初始序号（ack = y+1）。此时，TCP连接建立，客户端进入<strong>ESTABLISHED已建立连接状态</strong> 触发三次握手。</p></li><li><p>TCP三次握手的目的是为了确保客户端和服务器之间的通信能够正常进行，防止因为网络延迟等因素导致的连接失败。同时，它也可以防止网络中的恶意攻击，比如TCP SYN攻击等。</p></li></ul></li><li><p>断开一个 TCP 连接则需要**“四次挥手**”，缺一不可 ：</p><ol><li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li><li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li><li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li></ol></li></ul></li><li><p>socket</p><ul><li><p>Socket通常包括以下几个要素：</p><ul><li>IP地址：用于标识网络中的计算机。</li><li>端口号：用于标识计算机上的进程。</li><li>协议类型：用于标识通信使用的协议类型，比如TCP、UDP等。</li></ul></li><li><p>Socket通信的流程通常包括以下几个步骤：</p><ul><li>服务器程序创建一个Socket，并绑定到一个IP地址和端口号。</li><li>客户端程序创建一个Socket，并连接到服务器的IP地址和端口号。</li><li>服务器程序接收连接请求，并创建一个新的Socket来处理客户端请求。</li><li>客户端程序发送数据到服务器，服务器程序接收数据并处理。</li><li>服务器程序发送数据到客户端，客户端程序接收数据并处理。</li><li>客户端和服务器程序关闭Socket。</li></ul></li></ul></li></ul><h2 id="端口">端口</h2><ul><li>应用程序的唯一标识；</li><li>由两个字节表示的整数，范围0~65535；</li><li>一个端口只能被一个应用程序使用；</li></ul><h2 id="HTTP">HTTP</h2><ul><li><p><strong>HTTP（Hypertext Transfer Protocol）</strong>（超文本传输协议）是一种应用层协议，用于在Web浏览器和Web服务器之间传输数据。</p></li><li><p>HTTP协议的基本工作流程如下：</p><ol><li>客户端向服务器发送HTTP请求，请求可以是<strong>GET、POST、PUT、DELETE</strong>等方法，其中GET方法用于获取资源，POST方法用于提交数据，PUT方法用于修改资源，DELETE方法用于删除资源。</li><li>服务器接收到请求后，会根据请求的方法和URI（Uniform Resource Identifier）来确定要响应的资源，并返回HTTP响应消息。响应消息包括状态行、消息头和消息体。</li><li>客户端接收到响应消息后，会解析消息头和消息体，并根据<strong>状态码</strong>来判断请求是否成功。</li></ol></li><li><p><strong>报文</strong></p><ul><li><p>报文结构</p><ul><li>起始行（请求行，响应行）</li><li>首部（key-value的形式）</li><li>主体</li></ul></li><li><p><strong>请求报文</strong></p></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/v3/api-docs</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>localhost:8080</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>application/json,*/*</span><br><span class="line"></span><br><span class="line"><span class="language-awk"><span class="regexp">//</span>首部与主体之间有空行</span></span><br><span class="line"><span class="language-awk">...  <span class="regexp">//</span> 请求主体：客户端发给服务端的数据</span></span><br><span class="line"><span class="language-awk"></span></span><br><span class="line"><span class="language-awk"><span class="regexp">//</span> 以HTTP协议的<span class="number">1.1</span>版本请求访问localhost:<span class="number">8080</span>服务器上的<span class="regexp">/v3/</span>api-docs资源</span></span><br></pre></td></tr></table></figure><ul><li><strong>响应报文</strong></li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">Date:Sun,20 Dec 2020 06:33:44 GMT</span><br><span class="line">Content-Type:application/json</span><br><span class="line"></span><br><span class="line"><span class="language-awk">...  <span class="regexp">//</span>响应主体：服务端返回给客户端的内容</span></span><br><span class="line"><span class="language-awk"></span></span><br><span class="line"><span class="language-awk"><span class="regexp">//</span></span></span><br></pre></td></tr></table></figure></li><li><p>状态码</p><ul><li>1xx：信息状态码</li><li>2xx：成功状态码</li><li>3xx：重定向状态码</li><li>4xx：客户端错误状态码</li><li>5xx：服务端错误状态码</li></ul></li><li><p><code>HTTP</code>方法的安全性的幂等性</p><ul><li>安全性：不会对服务端造成影响，即无论怎么请求，服务端都不会因此而发生变化；简而言之就是<strong>只读</strong>。</li><li>幂等性：多次请求对服务器的影响与第一次一样；</li></ul><table><thead><tr><th>HTTP方法</th><th>接口说明</th><th>安全性</th><th>幂等性</th></tr></thead><tbody><tr><td>GET</td><td>获取资源(Read)</td><td>安全</td><td>幂等</td></tr><tr><td>POST</td><td>创建资源(Create)</td><td>不安全</td><td>非幂等</td></tr><tr><td>PUT</td><td>更新资源(Update)</td><td>不安全</td><td>幂等</td></tr><tr><td>DELETE</td><td>删除资源(Delete)</td><td>不安全</td><td>幂等</td></tr></tbody></table></li></ul><h2 id="HTTPS">HTTPS</h2><ul><li>HTTPS（HTTP安全）是一种用于Web服务器和客户端（如Web浏览器）通信的协议，它在HTTP协议的基础上<strong>添加了加密和身份验证功能，从而提供更安全的数据通信</strong>。HTTPS使用TLS（传输层安全）协议来加密数据传输，从而防止中间人攻击和窃听。</li></ul><h2 id="常用CMD命令">常用CMD命令</h2><ul><li><code>ipconfig</code>：查看本机IP；</li><li><code>ping</code>：通常用于<strong>测试网络连接是否正常</strong>，以及确定网络延迟和数据包丢失率等问题。它也可以用于诊断网络故障，并提供有关网络性能的有用信息。</li></ul><h2 id="RESTful">RESTful</h2><ul><li><p>REST（Representational State Transfer）:资源以某种表现形式在HTTP方法的作用下发生变化；</p></li><li><p><code>RESTful</code>实践</p><ul><li><p>获取数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &quot;http://localhost:8080/rest/user/1&quot; </span><br></pre></td></tr></table></figure><p>定位id为1的用户（资源），用GET方法获取，查询资源；</p></li><li><p>新增数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST &quot;http://localhost:8080/rest/user&quot;</span><br><span class="line">Content-Type:application/json </span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;ming&quot;,</span><br><span class="line">&quot;age&quot;:3,</span><br><span class="line">&quot;email&quot;:&quot;ming@test.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST方法的参数通常会被放在请求体中，以Content-Type中的格式（JSON）提交到服务端；</p></li><li><p>更新数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT &quot;http://localhost:8080/rest/user&quot;</span><br><span class="line">Content-Type:application/json </span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:1,</span><br><span class="line">&quot;name&quot;:&quot;ming&quot;,</span><br><span class="line">&quot;age&quot;:21,</span><br><span class="line">&quot;email&quot;:&quot;ming@test.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与POST的区别在于请求参数还要指定一个唯一字段（如id）；</p></li><li><p>删除数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &quot;http://localhost:8080/rest/user/1&quot; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>RESTful风格由<code>URI</code>定位资源</p><ul><li><code>URI</code>：Uniform Resource Identifier</li><li><code>URL</code>：Uniform Resource Locator</li><li><code>URN</code>：Uniform Resource Name</li></ul><p>所有的<code>URL</code>和<code>URN</code>都可以称为<code>URI</code>；</p><p><code>URL</code>可以定位资源，而<code>URN</code>不行；</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>点评项目</title>
      <link href="/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/"/>
      <url>/2023/07/10/%E7%82%B9%E8%AF%84%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>点评项目是前后端分离项目，前端部署在nginx服务器上，后端部署在tomcat上。</p><h2 id="用户登录">用户登录</h2><ul><li><p><strong>权限认证方式</strong></p><ul><li><p><code>HTTP</code>是无状态的；</p></li><li><p><code>Session</code>（会话）认证：服务器为了保存用户状态而创建的一个对象。key-value形式存储；</p></li><li><p><code>Token</code>（令牌）：由服务端生成的一串字符串，作为客户端进行请求的一个凭证；当用户第一次登陆后，服务器会生成一个<code>Token</code>并返回给客户端，之后客户端再进行需要权限的请求时只需要带上这个<code>Token</code>即可，无需再携带用户名和密码进行认证；通过某种算法策略生成唯一的<code>Token</code>；</p></li></ul></li><li><p>集群**<code>session</code>共享问题**：集群模式下多台<code>tomcat</code>服务器不共享<code>session</code>存储空间，当请求切换到不同<code>tomcat</code>服务时导致数据丢失的问题。</p><p>因为<code>Redis</code>满足<strong>数据共享，内存存储，k-v键值对结构</strong>，因此使用<code>Redis</code>替代<code>session</code>可以解决<code>session</code>集群共享问题；</p></li><li><p><strong>登陆验证流程</strong></p><ol><li>前端提交手机号和验证码；</li><li>校验手机号，如果不符合，返回错误信息；</li><li>从<code>redis</code>获取验证码并校验，如果不一致，则返回错误信息；</li><li>如果一致，根据手机号查询用户；</li><li>判断用户是否存在，若不存在，创建新用户并保存（注册）；</li><li>保存用户信息到 <code>redis</code>中；<ol><li>生成随机<code>token</code>，作为登录令牌；</li><li>将User对象转为<code>HashMap</code>存储；</li><li>存入<code>Redis</code>，并设置<code>key</code>有效期；</li><li>返回<code>token</code>；</li></ol></li></ol></li><li><p><strong>刷新<code>Token</code>有效期拦截器</strong>：因为<code>Token</code>设置的有效期是固定的，因此如果用户一直在登陆状态，则需要一直刷新<code>Token</code>的有效期；</p><ul><li>拦截所有请求</li><li>获取<code>Token</code>；</li><li>基于<code>Token</code>获取Redis中的用户信息；</li><li>保存用户信息到<code>ThreadLocal</code>；</li><li>刷新<code>Token</code>有效期；</li></ul></li><li><p><strong>登录拦截器</strong>：拦截需要用户登录的请求，查询<code>ThreadLocal</code>中是否存在用户，存在则放行；</p><p><img src="https://img-blog.csdnimg.cn/78ed142c48c3448a8fb240194f22fce8.png" alt="拦截器"></p></li></ul><h2 id="商户查询缓存">商户查询缓存</h2><h3 id="简介">简介</h3><p>缓存是数据交换得缓冲区（Cache），用于存储临时数据，一般读写性能较高；</p><ul><li><p>缓存的作用</p><ul><li>降低后端负载</li><li>提高读写速率，降低响应速率</li></ul></li><li><p>缓存的成本</p><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本（集群部署等）</li></ul></li><li><p>通常我们这样使用缓存：</p><ul><li>写请求只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul></li></ul><p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230712110056150.png" alt="image-20230712110056150"></p><p>​这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「<strong>热数据</strong>」，缓存利用率得以最大化。</p><h3 id="缓存更新策略">缓存更新策略</h3><ul><li><p>缓存更新策略</p><ul><li>内存淘汰：利用Redis的内存淘汰机制；</li><li>超时剔除：给缓存数据添加超时时间；</li><li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存；</li></ul></li><li><p><strong>删除缓存还是更新缓存？</strong></p><ul><li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多；</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（<strong>更优</strong>）</li></ul></li><li><p>如何保证缓存和数据库操作的原子性？</p><ul><li>单体系统，将缓存和数据库放在一个事务中；</li><li>分布式系统：利用TCC等分布式事务方案；</li></ul></li><li><p>这里存在<strong>数据一致性问题</strong>，当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。这两个操作并非是原子的，所以有先后顺序；</p><ul><li><p>先删除缓存，再更新数据库：</p><ul><li><p>初始化（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 删除缓存后（数据库：1 ，缓存：null）</p></li><li><p><em>线程2</em> 前来查询缓存未命中，查询数据库，并将查询到的数据写入缓存（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 再更新数据库（数据库：2 ，缓存：1）</p></li><li><p>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率较大</strong>，因为Redis的读写速度比数据库快很多，并发情况下很容易发生这种情况。</p></li></ul></li><li><p>先更新数据库，再删除缓存</p><ul><li>初始化，恰好缓存失效（数据库：1 ，缓存：null）</li><li><em>线程1</em> 查询缓存未命中并查询数据库（1）</li><li><em>线程2</em> 更新数据库（数据库：2 ，缓存：null）</li><li><em>线程2</em>  删除缓存（数据库：2 ，缓存：null）</li><li><em>线程1</em> 写入缓存（数据库：2 ，缓存：1）</li><li>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率很小</strong>（线程1之前缓存恰好失效；Redis写入速度很快，在其之前有线程插入并更新数据库的概率很小）</li></ul></li></ul></li><li><p>因此，缓存更新策略的最佳实践方案为：</p><ul><li>低一致性需求：使用Redis自带的内存淘汰机制；</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案；<ul><li>读操作：<ul><li>缓存命中则直接返回；</li><li>缓存未命中则直接查询数据库，并写入缓存，并设定超时时间；</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存；</li><li>要确保数据库与缓存操作的原子性；</li></ul></li></ul></li></ul></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul><li><p>缓存穿透是指客户端<strong>请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远都不会生效，这些请求都会到数据库。（可能会被无效请求恶意攻击）。</p></li><li><p>解决方案：</p><ul><li><p>缓存空对象：对于无效的请求，缓存一个null对象</p><ul><li><p>优点：实现简单，维护简单</p></li><li><p>缺点：</p><ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>请求与Redis缓存之间设置一布隆过滤器，由布隆过滤器判断请求数据是否存在，存在则放行，不存在则直接返回。</li><li>布隆过滤器并不是存储了所有数据，而是通过某种算法来判断请求数据是否存在。</li></ul></li></ul></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul><li>缓存雪崩是指 <strong>同一时段大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</li><li>解决方案：<ul><li>给不同的key添加随机失效时间；</li><li>利用Redis集群提高服务的可用性；</li><li>给缓存业务添加降级限流策略；</li><li>给业务添加多级缓存；</li></ul></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul><li><p>缓存击穿问题也被称为<strong>热点key</strong>问题，就是一个<strong>被高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求在瞬间给数据库带来巨大的冲击。</p></li><li><p>解决方案：</p><ul><li><p>互斥锁：查询缓存未命中时，先获取互斥锁，获取锁成功后查询数据库并重建缓存，写入缓存后再释放锁；这样，其他线程请求无法在缓存重建期间查询缓存。</p><p>线程需要等待，性能收到影响；可能有死锁风险。</p></li><li><p>逻辑过期：<strong>给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL</strong>。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。</p><ul><li>优点：<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点：<ul><li>不保证一致性(因为会返回过期数据)</li><li>有额外的内存消耗(同时缓存了逻辑过期时间的字段)</li><li>实现复杂</li></ul></li></ul></li></ul></li></ul><h2 id="优惠券秒杀">优惠券秒杀</h2><p>Redis的计数器，lua脚本Redis，分布式锁，消息队列</p><h3 id="分布式全局唯一ID">分布式全局唯一ID</h3><ul><li><p>**<em>UUID(通用唯一标识符)**表示一个128位长的唯一值。 它也被普遍称为</em>GUID(全球唯一标识符)。我们可以使用*UUID*类来生成随机文件名，会话或事务ID。 UUID的另一种流行用法是在数据库中生成主键值。<strong>有极小的概率会重复</strong>。</p></li><li><p><strong>雪花算法</strong></p><p>由64位<code>bit</code>字符组成（Long）<br>$$<br>0\quad \quad0000 … 0000\quad\quad\quad 000000 0000 \quad\quad 0000 0000 0000<br>$$<br>​                                                       <strong>符号位   时间戳：41 bit          机器ID：10 bit</strong>      <strong>12 bit 序列号</strong></p><ul><li><p>组成：</p><ul><li>符号位：1 bit，生成ID一般均为正数，因此为0；</li><li>时间戳：41 bit，单位为ms，可以使用约69年；</li><li>机器ID：10 bit，可以支持1024个分布式机器；</li><li>序列号：12 bit，表示每ms可以生成$2^{12}=1024$个不同ID；</li></ul></li><li><p>特点</p><ul><li>按时间递增</li><li>唯一性</li><li>生成效率高</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成全局唯一ID（** 雪花算法 **）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIDWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1692213900</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="comment">// 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 机器ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">machineId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成序列号(通过Redis自增生成序列)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">increment</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                         .increment(<span class="string">&quot;icr&quot;</span> + prefix + <span class="string">&quot;:&quot;</span> + nowDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接并返回</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> timestamp &lt;&lt; <span class="number">22</span> | machineId &lt;&lt; <span class="number">12</span> | increment;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>雪花算法的**时钟回拨 **问题</p><ul><li>由于雪花算法对于时钟特别敏感，因此如果时钟出现回拨现象，有可能导致获取的ID重复。</li><li>正常来说只要不是不是有人手贱或者出于泄愤的目的进行干扰，系统的时间漂移是一个在毫秒级别的极短的时间。因此可以在获取 ID 的时候，记录一下当前的时间戳。然后在下一次过来获取的时候，<strong>对比一下当前时间戳和上次记录的时间戳，如果发现当前时间戳小于上次记录的时间戳，所以出现了时钟回拨现象，对外抛出异常，本次 ID 获取失败</strong>。理论上当前时间戳会很快的追赶上上次记录的时间戳。</li></ul></li></ul><h3 id="超卖问题">超卖问题</h3><ul><li><p>高并发场景下，做个线程交叉执行可能会出现超卖问题；</p><ul><li><p><code>初始</code>：库存：1；</p></li><li><p><code>线程1</code>：查询库存为1；</p></li><li><p><code>线程2</code>：查询库存为1；</p></li><li><p><code>线程1</code>：扣减库存，下单成功；</p></li><li><p><code>线程2</code>：扣减库存，下单成功；</p></li><li><p><code>库存</code>：<strong>-1</strong>（出现超买问题）；</p></li></ul></li><li><p>解决方案：加锁</p></li><li><p><strong>悲观锁</strong></p><ul><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li><li>例如<code>Synchronized</code>，<code>Lock</code>都属于悲观锁；</li><li>特点：简单直接，性能差；</li></ul></li><li><p><strong>乐观锁</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，只是<strong>在更新数据时判断是否有其他线程对数据进行了修改</strong>。<ul><li>如果没有，则认为是安全的，更新数据；</li><li>如果游，则重试或者抛出异常；</li></ul></li><li>特点：性能好，但容易出现成功率过低的问题；</li></ul></li><li><p>乐观锁的实现方式</p><ul><li><p><strong>版本号法</strong>：为资源添加一个version版本号，当修改资源后version就加一，修改资源前判断版本号是否被修改；</p><ul><li><p><code>初始</code>：库存：1；（ version = 1 ）</p></li><li><p><code>线程1</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程2</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程1</code>：扣减库存，下单成功；（ version = 2 ）</p></li><li><p><code>线程2</code>：此时发现version与查询时的不同，说明资源被其他线程修改，下单失败；</p></li></ul></li><li><p><strong>CAS</strong>（<code>Compare And Swap</code>）：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。<br>（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。<br>（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">// where ...</span></span><br><span class="line">        .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>该方法能够解决超卖问题，但是高并发场景下成功率过低，影响业务；</p></li></ul></li></ul><h3 id="一人一单">一人一单</h3><ul><li><p>业务场景下，同一个用户对同一优惠券只能下一次单。（抵制黄牛！）</p></li><li><p>加<code>sycronized</code>锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用户Id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// toString()底层每次调用都会重新创建一个String对象，导致synchronized失效</span></span><br><span class="line">    <span class="comment">// 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 一人一单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经抢购过该优惠券！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码可能会导致线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 一人一单</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁释放，此时其他线程可以进来</span></span><br><span class="line">    <span class="comment">// 而事务尚未提交，线程不安全！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// toString()底层每次调用都会重新创建一个String对象，导致synchronized失效</span></span><br><span class="line">    <span class="comment">// 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createVoucherOrder(voucherId); <span class="comment">// **事务失效** 问题</span></span><br><span class="line">        <span class="comment">// 事务已提交</span></span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上有可能导致<strong>事务失效</strong>问题，解决方案如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="comment">// 拿到当前对象的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分布式锁">分布式锁</h2><h3 id="简介-v2">简介</h3><ul><li><p><code>sycronized</code>只能在一个<code>JVM</code>内部实现不同线程之间的互斥，集群下可能出现线程安全问题</p></li><li><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见的互斥锁。</p></li><li><p>特点：</p><ul><li>多进程可见</li><li>互斥</li><li>高性能</li><li>高可用</li><li>安全性</li></ul></li><li><p>实现方式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身的互斥锁机制</td><td style="text-align:center">利用setnx命令</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超时时间，到期释放</td></tr></tbody></table></li></ul><h3 id="基于Redis实现分布式锁">基于Redis实现分布式锁</h3><ul><li><p>获取锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 利用setnx的互斥特性</span><br><span class="line">SETNX lock thread1</span><br><span class="line"># 添加锁过期时间，避免服务宕机引起的死锁</span><br><span class="line">EXPIRE lock <span class="number">30</span></span><br></pre></td></tr></table></figure><p>以上两条命令不具备原子性，可以使用以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> lock thread NX EX <span class="number">30</span></span><br></pre></td></tr></table></figure></li><li><p>释放锁</p><p>手动释放或超时释放</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除即可</span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li><li><p>实现Redis分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String lockName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          获取锁时存入线程标识</span></span><br><span class="line"><span class="comment">          解决分布式锁 **误删** 问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        return isSuccess;  // 可能会在自动拆箱过程中出现空指针</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         释放锁时先获取锁中的线程标识，判断是否与当前标识相同</span></span><br><span class="line"><span class="comment">         如果一致则释放锁，不一致则不释放锁；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_PREFIX + lockName);</span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(id)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(LOCK_PREFIX + lockName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决分布式锁 <strong>误删</strong> 问题</p><ul><li><p><code>线程1</code>：获取锁成功（<code>lock1</code>），执行任务；（任务时间较久或宕机）</p></li><li><p>超过超时时间，锁自动释放；</p></li><li><p><code>线程2</code>：获取锁成功（<code>lock1</code>），执行任务；</p></li><li><p><code>线程1</code>：任务执行成功，释放锁；</p></li><li><p>此时<code>线程2</code>还未执行完毕，<code>线程 1 </code>误删了<code>线程 2 </code>的锁；</p></li></ul><p>解决方案：</p></li><li><p>获取锁时存入线程标识（可以使用<code>UUID</code>）；</p><ul><li>释放锁时先获取锁中的线程标识，判断是否与当前标识相同，如果一致则释放锁，不一致则不释放锁；</li></ul></li><li><p>分布式锁的<strong>原子性</strong></p><ul><li><p>由于上述判断线程标识与释放锁的操作不具备原子性，因此可能会有线程安全问题；</p></li><li><p>Redis提供了lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性；</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script key [key ...]  # 执行脚本</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现思路总结</p><ul><li>利用<code>SETNX</code>命令获取锁，设置过期时间，并存入线程标识；</li><li>释放锁时先判断标识是否一致，一致则删除锁；</li></ul></li><li><p>基于<code>SETNX</code>实现分布式锁的问题：</p><ul><li>不可重入：同一个线程无法多次获取同一把锁；</li><li>不可重试：获取锁失败时返回false，没有重试机制；</li><li>超时释放：超时释放虽然可以避免死锁；设置超时时间过短，若业务执行时间过长，也会导致锁释放，存在安全隐患；设置超时时间过长，导致业务停滞；</li><li>主从一致性</li></ul></li></ul><h3 id="Redisson">Redisson</h3><ul><li><p><strong>Redisson使用</strong></p><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reddision 配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 单节点</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="string">&quot;lm12138&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Redisson</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，指定锁名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">// 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="秒杀优化">秒杀优化</h3><ul><li><p>秒杀流程回顾：</p><ul><li>查询优惠券（数据库）</li><li>判断秒杀库存</li><li>查询订单（数据库）</li><li>校验一人一单</li><li>减库存（数据库）</li><li>创建订单（数据库）</li></ul></li><li><p><strong>异步秒杀</strong>：</p><ul><li>新增秒杀优惠券的同时，将秒杀库存保存到Redis中；</li><li>基于lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul></li></ul><h2 id="点赞与评论">点赞与评论</h2><ul><li>基于SortedSet的点赞排行榜<ul><li>从Redis中查询，判断用户是否赞；</li><li>若未点赞，数据库点赞数 +1，并且将用户和点赞时间（score）存入Redis；</li><li>若已经点赞，数据库点赞数 -1，并且将用户移除Redis；</li><li>查询 top5 的点赞用户 <code>zrange key 0 4</code></li></ul></li></ul><h2 id="好友关注">好友关注</h2><p>基于set集合的关注，取关，共同关注和消息推送等功能</p><h2 id="附近的商户">附近的商户</h2><p>redis的GeoHash的应用</p><h2 id="UV统计">UV统计</h2><p>Redis的HyperLog的统计功能</p><h2 id="用户签到">用户签到</h2><p>Redis的BitMap数据统计功能</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置ssh</title>
      <link href="/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/"/>
      <url>/2023/07/01/Ubuntu%E9%85%8D%E7%BD%AEssh/</url>
      
        <content type="html"><![CDATA[<ul><li><p>安装ssh服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-server</span><br></pre></td></tr></table></figure></li><li><p>安装ssh客户端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install openssh-client</span><br></pre></td></tr></table></figure></li><li><p>配置<code>ssh</code>客户端，去掉<code>PasswordAuthentication yes</code>前面的#号，保存退出；配置ssh服务器，把<code>PermitRootLogin prohibit-password</code>改成<code>PermitRootLogin yes</code>，保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/ssh/ssh_config</span><br></pre></td></tr></table></figure></li><li><p>重启ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></li><li><p>启动ssh服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /etc/init.d/ssh start</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> ssh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu上安装anaconda</title>
      <link href="/2023/07/01/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85anaconda/"/>
      <url>/2023/07/01/Ubuntu%E4%B8%8A%E5%AE%89%E8%A3%85anaconda/</url>
      
        <content type="html"><![CDATA[<ul><li><p>官网下载 <a href="https://www.anaconda.com/%E5%AE%89%E8%A3%85%E5%8C%85">https://www.anaconda.com/安装包</a></p></li><li><p><a href="http://xn--jn2aw7m.sh">运行.sh</a> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash Anaconda3-2021.11-Linux-x86_64.sh</span><br><span class="line">/home/lm/anaconda3 # 安装路径</span><br></pre></td></tr></table></figure></li><li><p>配置环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim ~/.bashrc</span><br><span class="line">export PATH=/home/lm/anaconda3/bin:$PATH</span><br><span class="line">source ~/anaconda3/bin/activate #修改终端的默认 python 为 anaconda</span><br></pre></td></tr></table></figure></li><li><p>保存环境配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure></li><li><p>虚拟环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n env_name python=3.8</span><br></pre></td></tr></table></figure></li><li><p>激活环境</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda <span class="built_in">activate</span> env_name</span><br></pre></td></tr></table></figure></li><li><p>查看环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conda info --envs</span><br><span class="line">或</span><br><span class="line">conda info -e</span><br><span class="line">或</span><br><span class="line">conda env list</span><br></pre></td></tr></table></figure></li><li><p>复制环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create --name new_env_name --clone copied_env_name</span><br></pre></td></tr></table></figure></li><li><p>删除环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda remove --name env_name --all</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写IOC容器</title>
      <link href="/2023/07/01/%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/07/01/%E6%89%8B%E5%86%99IOC%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>实现：<strong>Java 反射 + 注解</strong></p><ul><li><p>创建两个注解：</p><ul><li><p><code>@Bean </code>：创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> <span class="comment">// 作用在类对象上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Bean &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Di</code>：属性注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.FIELD)</span> <span class="comment">// 使用在属性上</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">// 运行时生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Di &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建Bean容器接口 ApplicationContext，定义方法，返回对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    <span class="comment">// 返回Bean对象</span></span><br><span class="line">    Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> NoSuchMethodException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现Bean容器接口</p><ul><li>返回对象</li><li>创建有参构造器，传递包路径，设置包扫描规则</li><li>根据包规则加载Bean（）</li><li>属性注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationApplicationContext</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContext</span> &#123;</span><br><span class="line">    <span class="comment">// 创建map集合，存放Bean对象</span></span><br><span class="line">    <span class="keyword">private</span>  Map&lt;Class,Object&gt; beanFactory = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span>  String rootPath; <span class="comment">// 前路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// fa</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">        <span class="keyword">return</span> beanFactory.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建有参构造器，传递包路径，设置包扫描规则</span></span><br><span class="line">    <span class="comment">// 当前包及子包中，如果哪个类有@Bean注解，则通过反射将其实例化</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">AnnotationApplicationContext</span><span class="params">(String basePackage)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 将.替换为\</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">packagePath</span> <span class="operator">=</span> basePackage.replaceAll(<span class="string">&quot;\\.&quot;</span>,<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">            <span class="comment">// 2. 获取包的绝对路径</span></span><br><span class="line">            Enumeration&lt;URL&gt; urls = Thread.currentThread().getContextClassLoader()</span><br><span class="line">                                    .getResources(packagePath);</span><br><span class="line">            <span class="keyword">while</span>(urls.hasMoreElements())&#123;</span><br><span class="line">                <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> URLDecoder.decode(url.getFile(), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 截取前路径</span></span><br><span class="line">                rootPath = filePath.substring(<span class="number">0</span>, filePath.length() - packagePath.length());</span><br><span class="line">                <span class="comment">// 包扫描</span></span><br><span class="line">                loadBean(<span class="keyword">new</span> <span class="title class_">File</span>(filePath));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 属性注入</span></span><br><span class="line">        loadDi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>包扫描加载<code>Bean</code>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包扫描过程，实例化</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadBean</span><span class="params">(File file)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 判断当前内容是否是一个文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">// 获取文件夹中的所有内容</span></span><br><span class="line">        File[] subFiles = file.listFiles();</span><br><span class="line">        <span class="comment">// 判断文件夹是否为空</span></span><br><span class="line">        <span class="keyword">if</span>(subFiles==<span class="literal">null</span>||subFiles.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历文件夹所有内容</span></span><br><span class="line">        <span class="keyword">for</span>(File subfile:subFiles)&#123;</span><br><span class="line">            <span class="comment">// 递归遍历文件夹及子文件夹</span></span><br><span class="line">            <span class="keyword">if</span>(subfile.isDirectory())&#123;</span><br><span class="line">                <span class="comment">// 如果是文件夹，递归遍历</span></span><br><span class="line">                loadBean(subfile);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 得到包路径+类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">pathWithClass</span> <span class="operator">=</span> subfile.getAbsolutePath().substring(rootPath.length()-<span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 判断当前文件类型是否为.class</span></span><br><span class="line">                <span class="keyword">if</span>(pathWithClass.endsWith(<span class="string">&quot;.class&quot;</span>))&#123;</span><br><span class="line">                    <span class="comment">// 把\换成. 并去掉.class后缀</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">allName</span> <span class="operator">=</span> pathWithClass.replaceAll(<span class="string">&quot;\\\\&quot;</span>,<span class="string">&quot;.&quot;</span>).replace(<span class="string">&quot;.class&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">                    <span class="comment">// 对有注解 @Bean的类进行实例化</span></span><br><span class="line">                    Class&lt;?&gt; clazz = Class.forName(allName);</span><br><span class="line">                    <span class="comment">// 判断是否为接口</span></span><br><span class="line">                    <span class="keyword">if</span>(!clazz.isInterface())&#123;</span><br><span class="line">                        <span class="comment">// 判断有无注解</span></span><br><span class="line">                        <span class="type">Bean</span> <span class="variable">annotation</span> <span class="operator">=</span> clazz.getAnnotation(Bean.class);</span><br><span class="line">                        <span class="keyword">if</span>(annotation != <span class="literal">null</span>)&#123;</span><br><span class="line">                            <span class="comment">// 实例化对象</span></span><br><span class="line">                            <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> clazz.getConstructor().newInstance();</span><br><span class="line">                            <span class="comment">// 实例化后的对象放入到map集合中</span></span><br><span class="line">                            <span class="comment">// 如果有接口，接口作为key</span></span><br><span class="line">                            <span class="keyword">if</span>(clazz.getInterfaces().length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                                beanFactory.put(clazz.getInterfaces()[<span class="number">0</span>],instance);</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                beanFactory.put(clazz,instance);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>属性注入实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadDi</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历 map 集合</span></span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Class,Object&gt; entry:beanFactory.entrySet())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        Class&lt;?&gt; clazz = obj.getClass();</span><br><span class="line">        <span class="comment">// 获取每个对象的属性</span></span><br><span class="line">        Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">        <span class="comment">// 遍历得到对象的属性数组，得到每个属性</span></span><br><span class="line">        <span class="keyword">for</span>(Field field:fields)&#123;</span><br><span class="line">            <span class="comment">// 判断属性上是否有 @Di 注解，把对象进行注入</span></span><br><span class="line">            <span class="type">Di</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Di.class);</span><br><span class="line">            <span class="keyword">if</span>(annotation!=<span class="literal">null</span>)&#123;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    field.set(obj,beanFactory.get(field.getType()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lucy in the Sky with Diamonds</title>
      <link href="/2023/06/30/Lucy-in-the-Sky-with-Diamonds/"/>
      <url>/2023/06/30/Lucy-in-the-Sky-with-Diamonds/</url>
      
        <content type="html"><![CDATA[<p>1967年，甲壳虫乐队发行了一首单曲——《露西在缀满钻石的天空中》(Lucy in the Sky with Diamonds) ，被称作是他们最伟大的作品之一。这首歌曲最初的灵感来自于约翰·列侬 (John Lennon) 的儿子小朱利安 (Julian) 所创作的一幅肖像画，画上描绘的是一位女孩在缀满钻石的天空中。</br><br>1974年，在东非大裂谷附近的阿法尔地区科考队发现了一具完整度约40%的古人类化石，考古队员们通过初步观察，发现化石的骨骼属于女性。而在她刚刚被发现的当天晚上，大家为了庆祝这个伟大的发现，在营地上跳起舞来。这时录音机里正循环播放着披头士乐队的歌曲《露西在缀满钻石的天空中》 （Lucy in the Sky with Diamonds），故将其命名为“<a href="https://zh.wikipedia.org/wiki/%E9%9C%B2%E8%A5%BF_(%E5%8D%97%E6%96%B9%E5%8F%A4%E7%8C%BF)">露西</a>（Lucy）”。</br><br>2004年，哈佛史密森天体物理中心 (Harvard-Smithsonian Centre) 的天文学家们作出了一个惊人的发现，在我们已知的宇宙中存在着一枚巨大的“天然钻石”，这似乎与甲壳虫乐队那首预言般的标志性歌曲有着某种联系。这颗钻石星球是一颗白矮星，位于半人马座，编号为V886或BPM 37093，直径约为4000公里，可能是有史以来被观测到的最大的天然钻石。受甲壳虫乐队的启发，发现她的科学家将她命名为露西 (Lucy)，这真的是一颗名副其实的在天空中镶满钻石的星球。这颗令人震惊的钻石星球重达10的34次方克拉，让地球上最大的天然钻石也相形见绌。它散发出如此璀璨的光芒，以至于我们在距离近50光年的半人马座上都能看到它。科学家们一直在研究这个星球所发出的低沉的嗡嗡声，终于在2004年证实了它是一颗白矮星——一颗巨大的垂死恒星，她的表面已完全结晶化，诞生了天然钻石。</p>]]></content>
      
      
      <categories>
          
          <category> 没用的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Canon的故事</title>
      <link href="/2023/06/30/Canon%E7%9A%84%E6%95%85%E4%BA%8B/"/>
      <url>/2023/06/30/Canon%E7%9A%84%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<p>卡农Canon——复调音乐的一种,原意为“规律”。一个声部的曲调自始至终追逐着另一声部,直到最后的一个小结,最后的一个和弦,它们会融合在一起，永不分离。 <br /><br>卡农的作者帕卡贝尔（Pachelbel），德国人。在他十几岁的时候，战乱使他沦为孤儿。流浪到英国的他被一个钢琴师收养，此后他天天听琴师弹琴，耳濡目染也学会了钢琴。在他旁边的镇上有一个美丽的女孩叫Barbara，自从她在教堂听了Pachelbel弹的曲子，就爱上了他。害羞的Barbara不敢向Pachelbel表白，于是就找了个理由去Pachelbel那学钢琴。她对Pachelbel说自己热爱音乐，希望可以拜师学艺。之后的半年里，Barbara 为了证明自己的决心，努力练习钢琴，最终在一次比赛中获奖。而当她拿着奖杯想去和Pachelbel告白时，却得知Pachelbel被征去打仗。与此同时，同村一位心仪Barbara许久的男子为了让她对Pachelbel死心，令人从前线运来一具碎尸体并称这是Pachelbel。Pachelbel没有任何亲戚，所以Barbara无法求证，认为他已经战死。悲痛欲绝的她，最终在Pachelbel教她弹琴的教堂里割腕自杀。 <br /><br>而远在战场的Pachebel对此一无所知，离开小镇之后他才明白自己内心对Barbara的情愫。在战乱中，九死一生的他每次想起Barbara，都会有活下去的力量。他为Barbara写下了一首曲子，想等自己回去后向她求婚。这首曲子就是我们所熟悉的《卡农》。三年后，当Pachelbel回到小镇上，才得知Barbara早已离开人世，才明白原来心爱的女孩也一直爱着自己。Pachelbel来到当初两人相遇的那个教堂，流着泪弹出了那首永远没机会被爱人听见的《卡农》。 <br /><br>而直到今天，人们已很难去定义《卡农》到底表达的是何种情感。不同的人，在不同的时间听到这首曲子，或许都会有自己的理解。那些不可追的往日、未曾开口的秘密、曾一起共度的时光、对未来的期许……都融在了音符里。如同曲中一个声部追随另一个声部到最后一个和弦，我追随你，直到生命尽头，永不分离。</p>]]></content>
      
      
      <categories>
          
          <category> 没用的知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring学习笔记</title>
      <link href="/2023/06/28/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Spring%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="Bean">Bean</h2><ul><li><p>spring中的 Bean 就是 java 对象</p></li><li><p><strong>如何使用反射创建对象？</strong></p><ul><li>加载bean.xml配置文件</li><li>对xml文件进行解析</li><li>获取xml文件bean标签属性值：id值属性值和class属性值</li><li>使用反射根据类全路径创建对象</li><li>将创建的对象放到一个Map中（<code>key</code>：唯一标识，<code>value</code>：类的定义）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserObject1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 加载spring配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取创建的对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用方法进行测试</span></span><br><span class="line">        user.hello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过反射创建对象</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserObject2</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 获取类class对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.lm.spring6.User&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用方法创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Ioc容器">Ioc容器</h2><ul><li><p><strong>IOC容器</strong></p><ul><li><p>spring通过<strong>IOC容器</strong>来管理：<strong>所有对象的实例化和初始化，控制对象与对象之间的依赖关系。</strong></p></li><li><p>容器使用map集合，存放Bean对象。</p><p><img src="/images/IoC%E5%AE%B9%E5%99%A8.png" alt="IoC容器"></p><center>    IOC容器在spring中的实现</center></li></ul></li><li><p><strong>依赖注入</strong></p><ul><li>指spring创建对象过程中，将对象依赖属性通过配置注入</li><li>实现方式有两种：<ul><li>set注入</li><li>构造注入</li></ul></li></ul></li><li><p><strong>IOC就是一种控制反转的思想，而依赖注入是对IOC的实现</strong></p></li></ul><h2 id="IOC基于xml管理Bean">IOC基于xml管理Bean</h2><ul><li><p>获取<code>Bean</code>的方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--完成User对象创建</span></span><br><span class="line"><span class="comment">    Bean标签</span></span><br><span class="line"><span class="comment">        id属性：唯一标识</span></span><br><span class="line"><span class="comment">        class属性：要创建对象所在类的全路径（包名+类名）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.根据id获取Bean</span></span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);<span class="comment">//获取ioc容器</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user&quot;</span>);<span class="comment">//获取Bean</span></span><br><span class="line">System.out.println(<span class="string">&quot;根据id获取Bean:&quot;</span>+user1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.根据类型获取Bean</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> context.getBean(User.class);</span><br><span class="line">System.out.println(<span class="string">&quot;根据类型获取Bean:&quot;</span>+user2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.根据id和类型获取Bean</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;user&quot;</span>, User.class);</span><br><span class="line">System.out.println(<span class="string">&quot;根据id和类型获取Bean:&quot;</span>+user3);</span><br></pre></td></tr></table></figure><ul><li>如果一个组件类实现了接口，可以通过接口类型获取Bean；但是如果一个接口有多个实现类，则无法获取Bean;</li></ul></li><li><p>依赖注入-基于setter方法</p><ul><li>创建类，定义属性，生成属性set方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// set,get,constructor方法忽略</span></span><br></pre></td></tr></table></figure><ul><li>在spring配置文件中配置</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--set 方法注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.di.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;book1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean-di.xml&quot;</span>);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;book&quot;</span>, Book.class);</span><br></pre></td></tr></table></figure></li><li><p>依赖注入-基于构造器</p><ul><li>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--constructor 构造方法注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookCon&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.di.Book&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;book2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean-di.xml&quot;</span>);</span><br><span class="line"><span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;bookCon&quot;</span>, Book.class);</span><br></pre></td></tr></table></figure></li><li><p>特殊类型注入</p><ul><li>创建类，定义属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> School school;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String[] course;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        school.info(); <span class="comment">// 调用 School对象的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">School</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">info</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;name:&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">方法一：引入外部bean</span></span><br><span class="line"><span class="comment">1. 创建对象：student 和 school</span></span><br><span class="line"><span class="comment">2. 在student的标签中，使用property引入school的bean</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.ditest.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通类型注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--对象类型注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;school&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;school&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数组类型注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;course&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;school&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.ditest.School&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--普通类型注入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sjtu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean-di-test.xml&quot;</span>);</span><br><span class="line">     <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;student&quot;</span>,Student.class);</span><br><span class="line">     student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>引入外部属性文件（<code>jdbc.properties</code>）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bean-jdbc.xml</span><br><span class="line"><span class="comment">&lt;!--引入外部属性标签--&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:property-placeholder</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--完成数据库注入--&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;druidDataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Bean 的作用域</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">含义</th><th style="text-align:center">创建对象的时机</th></tr></thead><tbody><tr><td style="text-align:center">singleton（默认）</td><td style="text-align:center">在IOC容器中这个Bean的对象始终为单实例</td><td style="text-align:center">IOC容器初始化时</td></tr><tr><td style="text-align:center">prototype</td><td style="text-align:center">这个Bean在容器中有多个实例</td><td style="text-align:center">获取Bean时</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Bean 的生命周期</p><ul><li>Bean 对象从创建到销毁的过程<ol><li>Bean对象的创建（调用无参数构造）</li><li>给Bean对象设置相关的属性（属性注入）</li><li>Bean后置处理器（初始化之前）</li><li>对Bean对象初始化（调用指定的初始化方法）</li><li>Bean后置处理器（初始化之后）</li><li>Bean对象创建完成，可以使用</li><li>Bean对象的销毁（配置指定销毁方法）</li></ol></li><li>对象属性及方法定义</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1.Bean对象创建，调用无参数构造……&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;4.调用指定初始化方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroyMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;7.Bean对象的销毁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;2.设置属性值……&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置处理器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;3.Bean后置处理器（初始化之前）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessBeforeInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;5.Bean后置处理器（初始化之后）&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置文件(<code>bean-life.xml</code>)</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.beanlife.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ming&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>    </span><br><span class="line"><span class="comment">&lt;!--Bean的后置处理器需要放入IOC容器才能生效--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPost&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.beanlife.MyBeanPost&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestUser</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ClassPathXmlApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean-life.xml&quot;</span>);</span><br><span class="line">        context.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;6.Bean对象创建完成，可以使用&quot;</span>);</span><br><span class="line">        <span class="comment">// 注意：使用ClassPathXmlApplicationContext接口，才有close()方法</span></span><br><span class="line">        context.close();<span class="comment">// 销毁对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于xml实现自动装配</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userController&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.auto.controller.UserController&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.auto.service.UserServiceImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.lm.spring6.auto.dao.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自动装配方式有两种：</p><ul><li><code>byType</code>：根据类型匹配Ioc容器中的Bean，为属性自动复赋值；</li><li><code>byName</code>：将自动装配的属性名，作为Bean的id去匹配对应的Bean进行属性赋值；</li></ul></li></ul><h2 id="基于注解管理Bean">基于注解管理Bean</h2><ul><li><p>spring 通过注解实现自动装配的步骤如下：</p><ul><li>引入依赖</li><li>开启组件扫描</li><li>使用注解定义Bean</li><li>依赖注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描</span></span><br><span class="line"><span class="comment">扫描路径下的所有包，如果一个类加了注解，则将其装配到容器</span></span><br><span class="line"><span class="comment">--&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以定义Bean的注解</p><ul><li><code>@Component</code>：泛化的概念，可以用于任何层；</li><li><code>@Respository</code>：用于数据访问层；</li><li><code>@Service</code>：用于业务层；</li><li><code>@Controller</code>：用于控制层；</li></ul></li><li><p><code>@Autowired</code>注入</p><ul><li>默认<code>byType</code>方式装配</li><li>注入方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 方法一：属性注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2：set方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法3：构造方法注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 方法4：形参上注入</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(<span class="meta">@Autowired</span> UserService userService)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Controller方法执行……&quot;</span>);</span><br><span class="line">        userService.addUserService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Resource</code>注入</p><ul><li><code>@Resource</code>时java扩展包中的，也就是JDK的，所以是标准注解，更加通用；</li><li><code>@Autowired</code>是spring框架中的；</li><li>默认根据 <code>byName</code>装配；</li></ul></li></ul><h2 id="反射机制">反射机制</h2><ul><li><p>获取Class对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> User.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象.getClass()</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.forName(&quot;全路径&quot;)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.lm.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>(User)clazz1.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> User.class;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有public构造方法</span></span><br><span class="line">Constructor[] constructors1 = clazz.getConstructors();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有构造方法(包括private)</span></span><br><span class="line">Constructor[] constructors2 = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定有参数构造创建对象</span></span><br><span class="line"><span class="comment">//public        </span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);        </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User)c1.newInstance(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);  </span><br><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);        </span><br><span class="line">c2.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置允许访问        </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)c2.newInstance(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> User.class;</span><br><span class="line"><span class="comment">// 获取所有public属性</span></span><br><span class="line">Field[] fields1 = clazz.getFields();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有属性（包括private）</span></span><br><span class="line">Field[] fields2 = clazz.getDeclaredFields();</span><br></pre></td></tr></table></figure></li><li><p>获取方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> user.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 方法</span></span><br><span class="line">Method[] methods1 = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:methods1)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;</span><br><span class="line">        m.invoke(user); <span class="comment">// 执行 toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private</span></span><br><span class="line">Method[] methods2 = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:methods2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;run&quot;</span>))&#123;</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置允许访问</span></span><br><span class="line">        m.invoke(user); <span class="comment">// 执行 private run()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="代理模式">代理模式</h2><ul><li><p><strong>代理模式</strong>：代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。通俗的来讲代理模式就是我们生活中常见的中介。</p></li><li><p><strong>静态代理</strong>：通过将目标类与代理类实现同一个接口，让代理类持有真实类对象，然后在代理类方法中调用真实类方法，在调用真实类方法的前后添加我们所需要的功能扩展代码来达到增强的目的。</p><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span>&#123;</span><br><span class="line">    <span class="comment">// 注入真实类对象</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserServiceImpl userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;add&quot;</span>);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;delete&quot;</span>);</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;update&quot;</span>);</span><br><span class="line">        userService.update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        log(<span class="string">&quot;query&quot;</span>);</span><br><span class="line">        userService.query();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//增加日志打印</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.改动原有的业务代码,在公司中是大忌!</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端（测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"><span class="comment">//        userService.add();      //不使用代理</span></span><br><span class="line">        <span class="type">UserServiceProxy</span> <span class="variable">userServiceProxy</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>();</span><br><span class="line">        userServiceProxy.setUserService(userService);</span><br><span class="line">        userServiceProxy.add();</span><br><span class="line">        userServiceProxy.delete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态代理的缺点：对于每一个真实类对象都要创建一个代理类，开发效率低；</p></li></ul></li><li><p><strong>动态代理</strong>：在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术</p><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>真实类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 被代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTarget</span><span class="params">(Object target)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代理类</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 三个参数</span></span><br><span class="line">        <span class="comment">// 1. 加载动态生成代理类的类加载器</span></span><br><span class="line">        <span class="comment">// 2. 目标对象实现的所有接口的Class类型数组</span></span><br><span class="line">        <span class="comment">// 3 .设置代理对象实现目标对象方法的过程</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="built_in">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                      target.getClass().getInterfaces(),<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理代理实例，并返回结果</span></span><br><span class="line">    <span class="comment">// 参数1：代理对象</span></span><br><span class="line">    <span class="comment">// 参数2：代理对象需要实现的方法</span></span><br><span class="line">    <span class="comment">// 参数3：method方法里面的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 动态代理的本质，就是使用反射机制实现</span></span><br><span class="line">        log(method.getName());</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了&quot;</span>+msg+<span class="string">&quot;方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端（测试）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//真实角色</span></span><br><span class="line">        <span class="type">UserServiceImpl</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceImpl</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理角色，不存在</span></span><br><span class="line">        <span class="type">ProxyInvocationHandler</span> <span class="variable">pih</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyInvocationHandler</span>();</span><br><span class="line">        pih.setTarget(userService); <span class="comment">//设置要代理的对象</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//动态生成代理类</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">proxy</span> <span class="operator">=</span> (UserService) pih.getProxy();</span><br><span class="line">        proxy.query();</span><br><span class="line">        proxy.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行了query方法</span><br><span class="line">查询了一个用户</span><br><span class="line">执行了add方法</span><br><span class="line">增加了一个用户</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="AOP">AOP</h2><ul><li><p><strong>AOP</strong>：是一种设计思想，通过<strong>预编译</strong>方式和<strong>运行期间动态代理</strong>方式实现，在不修改源码的情况下，给程序动态添加额外功能的一种技术。</p><p>优点：对业务逻辑各部分进行<strong>解耦</strong>，提高程序的可重用性，提高开发效率。</p></li><li><p>动态代理的分类</p><ul><li>JDK动态代理：（有接口的情况）代理对象和目标对象实现同样的接口</li><li>cglib动态代理：（没有接口的情况）继承被代理的目标类</li></ul></li><li><p>相关术语</p><ul><li><strong>连接点</strong>：描述的是程序执行的某个特定位置。如一个类的初始化前、初始化后，或者类的某个方法调用前、调用后、方法抛出异常后等等；</li><li><strong>切入点</strong>：是一个连接点的过滤条件，AOP 通过切点定位到特定的连接点。类比：连接点相当于数据库中的记录，切点相当于查询条件；</li><li><strong>通知</strong>：切面在某个具体的连接点采取的行为或行动，切面的核心逻辑代码都写在通知中，有人也称之为增强或者横切关注点。通知是切面功能的具体实现，通常是业务代码以外的需求，如日志、验证等，这些被模块化的特殊对象。</li></ul></li></ul><h2 id="基于注解实现AOP">基于注解实现AOP</h2><ul><li><p>引入对应的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aspects<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建目标资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;增加了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;删除了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;修改了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">query</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了一个用户&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类并进行配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切面类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspects</span> &#123;</span><br><span class="line">    <span class="comment">// 设置切入点和通知类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知类型</span></span><br><span class="line">    <span class="comment">// 前置：@Before()</span></span><br><span class="line">    <span class="comment">// 返回：@AfterReturning</span></span><br><span class="line">    <span class="comment">// 异常：@AfterThrowing</span></span><br><span class="line">    <span class="comment">// 后置：@After()</span></span><br><span class="line">    <span class="comment">// 环绕：@Around()</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">beforeMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(注解方式)====方法执行前====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;(注解方式)====方法执行后====&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点;</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.lm.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">aroundMethod</span><span class="params">(ProceedingJoinPoint pj)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕前&quot;</span>);</span><br><span class="line">        <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> pj.getSignature(); <span class="comment">//获得签名</span></span><br><span class="line">        System.out.println(<span class="string">&quot;signature: &quot;</span>+signature);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pj.proceed();   <span class="comment">//执行方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;环绕后&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>编写applicationContext.xml文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.lm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--开启注解支持!   JDK(默认 proxy-target-class=&quot;false&quot; )   cglib(  proxy-target-class=&quot;true&quot;)--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestAspects</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">        userService.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">环绕前</span><br><span class="line">signature: void com.lm.service.UserService.add()</span><br><span class="line">(注解方式)====方法执行前====</span><br><span class="line">增加了一个用户</span><br><span class="line">(注解方式)====方法执行后====</span><br><span class="line">环绕后</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java学习笔记</title>
      <link href="/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>Java</h1><h2 id="前言">前言</h2><ul><li><p><strong>Java特点</strong>：</p><ul><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java 虚拟机实现平台无关性）</li><li>可靠性（具备异常处理和自动内存管理机制）</li><li>支持多线程</li></ul></li><li><p><strong>Java工作方式</strong>：</p><ul><li><strong>源代码</strong>：demo.java文件</li><li><strong>编译器</strong>：运行源代码检查错误，将demo.java编译为demo.class文件，由字节码组成</li><li><strong>输出</strong>：输出demo.class</li><li><strong>java虚拟机</strong>：运行demo.class文件，将字节码转换为平台能理解的形式</li></ul></li><li><p><strong>Java程序结构</strong>：</p><ol><li>源文件（source file）<br>2. 类（class file）<br>3. 方法（method）: 函数或过程<br>4. 语句（statement）</li></ol></li></ul><p><img src="/images/jdk-include-jre.png" alt="JDK 包含 JRE"></p><ul><li><strong>JDK</strong>（Java Development Kit）：包含了 JRE，同时还包括了 javac、javadoc、jdb、jconsole、javap 等工具，可以用于 Java 应用程序的开发和调试。</li><li><strong>JRE</strong>（Java Runtime Environment）：Java 运行时环境，仅包含 Java 应用程序的运行时环境和必要的类库。主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</li><li><strong>JVM</strong>：是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li></ul><h2 id="基本概念">基本概念</h2><ul><li><p>基本数据类型（8个）</p><ul><li>整数型：<code>byte</code>（1字节），<code>short</code>（2字节），<code>int</code>（4字节），<code>long</code>（8字节）</li><li>浮点型：<code>float</code>（4字节），<code>double</code>（8字节）</li><li>字符类型：<code>char</code>（2字节）</li><li>布尔类型：<code>boolean</code>（1字节）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span><span class="number">0</span></span><br><span class="line">string[] str = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line">println() <span class="comment">//输出加换行</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> str.length</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (<span class="type">int</span>) <span class="number">24.6</span> <span class="comment">//类型转换</span></span><br><span class="line"><span class="keyword">while</span>(flag)&#123;&#125;<span class="comment">//java中integer与boolean两个类型不相容，故flag必须为boolean类型 </span></span><br></pre></td></tr></table></figure></li><li><p>包装类型</p><ul><li>八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> 。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 <code>equals()</code> 方法。</li><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li></ul></li><li><p><strong>自动拆装箱</strong></p><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;  <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i;   <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure><ul><li>装箱其实就是调用了包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>) <span class="comment">// 装箱</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> i.intValue();  <span class="comment">// 拆箱</span></span><br></pre></td></tr></table></figure></li><li><p>Java数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myList;         <span class="comment">// 数组变量声明，首选的方法</span></span><br><span class="line"><span class="type">int</span> myList[];         <span class="comment">//  效果相同，但不是首选方法</span></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[arraySize];     <span class="comment">// 创建数组</span></span><br><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[arraySize];   <span class="comment">// 数组变量声明 + 创建数组</span></span><br><span class="line"><span class="type">int</span>[] array = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">Arrays.sort(array); <span class="comment">// 数组排序</span></span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];<span class="comment">// 二维数组创建</span></span><br></pre></td></tr></table></figure></li><li><p>在Java中，动态数组是通过ArrayList实现的。可以使用add()方法向ArrayList中添加元素。以下是添加元素的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向数组末尾添加元素</span></span><br><span class="line">arrayList.add(<span class="string">&quot;元素1&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;元素2&quot;</span>);</span><br><span class="line">arrayList.add(<span class="string">&quot;元素3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定位置添加元素</span></span><br><span class="line">arrayList.add(<span class="number">1</span>, <span class="string">&quot;新元素&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(arrayList); <span class="comment">// 输出 [元素1, 新元素, 元素2, 元素3]</span></span><br><span class="line"></span><br><span class="line">arrayList.sort(Comparator.naturalOrder());<span class="comment">// 升序排列</span></span><br><span class="line">arrayList.sort(Comparator.reverseOrder()); <span class="comment">// 降序</span></span><br><span class="line">arrayList.size()</span><br></pre></td></tr></table></figure></li><li><p>输入输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Input</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.print(<span class="string">&quot;输入一个整数: &quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> input.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;您输入 &quot;</span> + number);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取double输入</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">myDouble</span> <span class="operator">=</span> input.nextDouble();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//获取字符串输入</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> input.next(); <span class="comment">//以空格结束</span></span><br><span class="line">        input.useDelimiter(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 设置为以换行结束</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">myString</span> <span class="operator">=</span> input.nextline(); <span class="comment">// 以回车结束 </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭scanner对象</span></span><br><span class="line">        input.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>JDK 1.5 引进了一种新的循环类型，被称为 For-Each 循环或者加强型循环，它能在不使用下标的情况下遍历数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element: array)</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>可变参数列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用数组语法实现可变参数列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj: args)&#123;</span><br><span class="line">    System.out.println(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用省略号实现可变参数列表</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(Object... args)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Object obj: args)&#123;</span><br><span class="line">    System.out.println(obj + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>枚举类型：多用在swith语句中；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Color</span>&#123;</span><br><span class="line">    RED,BLUE,WHITE,GREEN</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Color</span> <span class="variable">color</span> <span class="operator">=</span> Color.RED;</span><br></pre></td></tr></table></figure></li><li><p>java中的全局变量与全局方法：任何变量只要加上public，static和final，基本上都会变成全局变量取用的常数。这是一种近似全局的事物，他们也必须定义在类中。</p></li><li><p>java是通过<strong>值传递</strong>的，也就是通过拷贝传递；</p><ul><li>传递基本类型参数：方法接收到的是参数的拷贝，会创建副本；</li><li>传递引用类型参数：传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本；</li></ul></li></ul><h2 id="面向对象">面向对象</h2><ul><li><p><strong>面向对象和面向过程</strong></p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。（<strong>面向对象开发的程序一般更易维护、易复用、易扩展。</strong>）</li></ul></li><li><p>对象具有接口</p><ul><li><p>对象能够接受什么请求是由它的<strong>接口</strong>（interface）决定的，而接口由对象所归属的类定义；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Light</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span>&#123; <span class="comment">// 接口</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span>&#123; <span class="comment">// 接口</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Light</span> <span class="variable">lt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Light</span>();  <span class="comment">// 创建对象</span></span><br><span class="line">lt.on();<span class="comment">// 对象发出请求</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象和对象引用</p><ul><li>new运算符创建对象，存放在堆内存中；</li><li>对象引用指向对象，存放在栈内存中；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>()\\ person:对象引用</span><br></pre></td></tr></table></figure></li><li><p>对象相等和引用相等</p><ul><li>对象相等：内存中的内容相等；</li><li>引用相等：内存的地址相等；</li></ul></li><li><p>面向对象三大特征</p><ul><li><p><strong>封装</strong></p><ul><li>实例变量标记为<strong>private</strong></li><li>提供公有的getters与setters，标记为<strong>public</strong>，来控制存取动作</li><li><strong>public</strong>：可以被所有人访问；<strong>private</strong>：只能被类的创建者通过自身的方法访问；<strong>protected</strong>：类似于private，但是区别是继承的子类可以访问；</li></ul></li><li><p><strong>继承</strong></p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li><p><strong>多态</strong></p><ul><li>存在的三个必要条件：继承，重写，父类引用指向子类对象 <strong>Parent p = new Child()</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Circle.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;·</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Square.draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>参数化类型（泛型）</p><ul><li><p>一个被参数化的类型是一个特殊的类，可以让编译器自动适配特定的类型；</p></li><li><p>例如，编译器可以将集合定义为只接受放入shape的对象，因此集合中也只能取出shape对象；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;shape&gt; shapes = <span class="keyword">new</span> <span class="title class_">ArraytList</span>&lt;&gt;();\\ 创建一个防止shape对象的ArrayList</span><br></pre></td></tr></table></figure></li></ul></li><li><p>对象的创建和生命周期</p><ul><li>创建一个新对象时，可以通过堆内存来创建，因为堆是在运行时动态管理内存的；</li><li>java只允许<strong>动态分配内存</strong>，当创建一个新对象时，都需要通过new操作符创建一个对象的动态实例；</li><li>java底层支持<strong>垃圾收集器</strong>机制，它知道一个对象何时不会再用，并自动释放该对象占用的内存；</li></ul></li><li><p><strong>浅拷贝，深拷贝，引用拷贝</strong></p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：引用拷贝就是两个不同的引用指向同一个对象。</li></ul><p><img src="/images/shallow&amp;deep-copy.png" alt="浅拷贝、深拷贝、引用拷贝示意图"></p></li></ul><h2 id="对象">对象</h2><ul><li><p>数据保存的地方</p><ul><li>寄存器：数据直接保存在中央处理器（CPU），存储速度最快；</li><li>栈：数据存储在RAM里，效率仅次于寄存器；</li><li>堆：是一个通用的内存池（也使用RAM），用于存放所有的java对象；</li><li>常量：直接保存在程序代码中；</li></ul></li><li><p>static关键字</p><ul><li>使用static的字段或方法不依赖于对象；</li><li>即便没有为这个类创建对象，也可以调用该类的static方法和static字段；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">test</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line"><span class="type">test</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">test</span>();</span><br><span class="line"><span class="comment">// 即便创建了两个对象，test.x只会占用同一块空间</span></span><br><span class="line"><span class="comment">// t1.x和t2.x均为0</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="操作符">操作符</h2><ul><li><p><strong><code>==</code></strong> 和 <strong><code>equals ()</code></strong> 的区别：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li><li><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来<strong>判断两个对象是否相等</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">System.out.println(aa == bb);<span class="comment">// true</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">// true</span></span><br><span class="line">System.out.println(<span class="number">42</span> == <span class="number">42.0</span>);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="初始化和请理">初始化和请理</h2><ul><li><p>构造器进行初始化</p><ul><li>构造器的名字就是类的名字；</li><li>构造器也可以传入参数来指定如何创建对象；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rock</span>&#123;</span><br><span class="line">    Rock()&#123; <span class="comment">//无参构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Rock&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    Rock(<span class="type">int</span> x)&#123; <span class="comment">//构造器</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Rock&quot;</span> + x );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法重载</strong></p><ul><li>允许不同参数类型的方法<strong>具有相同的名字</strong>；例如可以创建一个无参构造器和有参数传递的构造器；</li><li>每个重载方法必须有<strong>独一无二的参数列表</strong>；</li></ul></li><li><p><strong>重写</strong></p><ul><li><strong>@override</strong>注解，表示该方法是一个重写（Override）父类中的方法，而不是在子类中定义一个新的方法；</li><li>@Override注解只能应用于重写父类中的方法，而不能应用于接口中的方法或静态方法。</li></ul></li><li><p>无参构造器</p><ul><li>如果你没有创建构造器，系统会自动为这个类创建一个无参构造器；</li><li>但如果你已经创建了构造器，即便没有无参构造器，系统都不会再自动创建了；</li></ul></li><li><p><strong>this</strong>关键字</p><ul><li>this 表示对当前对象的引用；</li><li>只能在非静态方法中使用；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>finalize()方法</p><ul><li>Java中：<ul><li>对于一些特殊的内存，垃圾处理器可能不知道怎么释放；</li><li>垃圾收集不是析构；</li><li>垃圾收集仅与内存有关；</li></ul></li><li>finalize()的使用仅限于一种特殊情况，对象以某种方式分配空间，而不是通过创建对象来分配；</li></ul></li><li><p><strong>垃圾收集器的工作原理</strong></p><ul><li>java中的堆更像一个传送带，“堆指针”只是简单的移动到尚未分配的区域，而垃圾收集器的介入可以使“堆指针”移到靠近传送带的地方，由此构建了一个高速的，有无限空闲空间的堆模型；</li><li><strong>引用计数</strong>：每个对象都有一个引用计数器，每次该对象被引用时，引用计数都会增加；离开作用域或设置为null时计数器减小；</li><li><strong>停止-复制</strong>：该算法将可用内存空间分为两部分，每次只使用其中一部分。当一部分内存用完后，将未被回收的对象复制到另一部分内存中，并清除原来的内存。该算法的优点是简单高效，缺点是需要额外的内存空间。</li><li><strong>标记-清除</strong>：该算法分为标记和清除两个阶段，首先标记出所有需要回收的对象，然后进行清除。该算法的缺点是会产生内存碎片，容易导致频繁的内存分配和回收。</li></ul></li></ul><h2 id="实现隐藏">实现隐藏</h2><ul><li>控制访问被称为<strong>实现隐藏</strong>；</li><li>将数据和方法包装在类中，并与实现隐藏结合，称为<strong>封装</strong>；</li><li><strong>类不能是private或protected的</strong>；如果想要防止对该类的访问，可以将该类的构造器都设为priate；</li></ul><h2 id="复用">复用</h2><ul><li><p><strong>组合</strong></p><ul><li>组合就是 A类的对象是B类的成员变量。相当于 A类对象是B类对象的一个变量，A类中的所有功能，B类都可以通过A类对象的调用来实现。</li><li>组合体现的是整体与部分、拥有的关系，即 has - a 的关系</li></ul></li><li><p><strong>继承</strong></p><ul><li><p>继承在面向对象语言中必不可少；其实创建一个类时，总是在继承，除非明确指定要继承某个类，否则都会<strong>隐式继承java的标准根类Object</strong>；</p></li><li><p>使用<strong>extends</strong>关键字，可以使用基类中的方法，还可以向子类中添加新方法；</p></li><li><p>创建对象时，构造过程是由基类 “向外” 进行的；即便没有为子类创建构造器，编译器也会自动创建一个可以调用基类的无参构造器；</p></li><li><p>如果基类没有无参构造器，那么就需要用 <strong>Super</strong>关键字来显示的调用构造器；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Art</span>&#123;</span><br><span class="line">    Art(<span class="type">int</span> i)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Draw</span> <span class="keyword">extends</span> <span class="title class_">Art</span>&#123;</span><br><span class="line">    Draw(<span class="type">int</span> i)&#123;</span><br><span class="line">        <span class="built_in">super</span>(i); <span class="comment">// 调用基类构造器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Cartoon <span class="keyword">extends</span> <span class="title class_">Draw</span>&#123;</span><br><span class="line">    Cartoon()&#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">11</span>); <span class="comment">// 调用基类构造器</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>向上转型</strong></p><ul><li><p>在Java中，子类继承了父类的所有方法和属性，因此<strong>子类对象可以被当做父类对象来使用</strong>。这种将子类对象转换为父类对象的过程就是向上转型。</p></li><li><p>向上转型总是安全的，因为是从更具体的类型转换为更通用的类型；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();  <span class="comment">// 创建了一个Dog对象，并将其赋值给Animal类型的变量animal,完成向上转型</span></span><br><span class="line">        animal.eat();  <span class="comment">// 调用父类方法 // 动态绑定</span></span><br><span class="line">        animal.bark();  <span class="comment">// 编译错误，父类不能访问子类特有的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>final</strong></p><ul><li>final，static表示是一个常量；</li><li>空白 final：即没有被初始化的final字段；必须在构造器里进行初始化，保证了final字段在使用之前总是被初始化；</li><li>final参数：只能读取，不能修改参数；</li><li>final类：该类不能被继承；</li></ul></li></ul><h2 id="多态">多态</h2><ul><li><p>多态是指同一个方法或者同一个类在不同的情况下表现出不同的行为。Java中的多态性主要通过方法的重载和覆盖以及向上转型实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">   <span class="meta">@override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">zoo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manage</span><span class="params">(Animal i)</span>&#123; <span class="comment">//方法接收一个Animal引用，他怎么知道这个引用在这里指的是cat，而不是dog，pig?</span></span><br><span class="line">        i.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">cat</span> <span class="variable">cat1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">cat</span>();</span><br><span class="line">        manage(cat1); <span class="comment">// 向上转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方法调用绑定</strong></p><ul><li><strong>前期绑定</strong>：在程序运行之前执行绑定，面向过程语言中默认是前期绑定；在多态中，困惑的点在于，编译器中只有一个基类引用时，怎么确定哪个才是要调用的正确方法；</li><li><strong>后期绑定</strong>（动态绑定）：是指在运行时根据对象的实际类型来调用相应的方法；java中所有方法都是动态绑定，除非方法是static或final的；</li></ul></li><li><p><strong>构造器和多态</strong></p><ul><li>构造器的调用顺序<ul><li>基类构造器被调用，然后是子类；</li><li>按声明的顺序初始化成员变量；</li><li>最后执行子类构造器的方法体；</li></ul></li><li>构造器内部的多态方法行为<ul><li>构造器负责创建对象，如果在构造器内调用动态绑定方法，则可以调用尚未被初始化的成员的方法——<strong>这将会导致灾难</strong></li></ul></li></ul></li></ul><h2 id="抽象类">抽象类</h2><ul><li><p><strong>抽象方法</strong>只有一个声明，没有方法体；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>包含抽象方法的类</strong>称为抽象类，抽象类（Abstract Class）是一种<strong>不能被实例化的类，它只能作为其他类的父类</strong>，用于定义一些抽象方法和非抽象方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">absrtact <span class="keyword">class</span> <span class="title class_">Basic</span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">m</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Basic</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Basic</span>(); <span class="comment">// 错误的，抽象类不能被实例化</span></span><br></pre></td></tr></table></figure></li><li><p>如果要创建一个可实例化的类，继承抽象类后<strong>要为所有的抽象方法提供定义</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Basic</span>()&#123;</span><br><span class="line">    <span class="meta">@override</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="接口">接口</h2><ul><li><p>用<strong>interface</strong>关键字创建了一个完全抽象的类，它不代表任何实现；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">4</span>; <span class="comment">//接口中的字段必须被声明为 public static final</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">f3</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;hello!&quot;</span>); <span class="comment">// default关键字允许我们在接口中实现方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>implements</strong>关键字创建一个符合特定接口的类，表示要提供它的定义；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">guitar</span> <span class="keyword">implements</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">     <span class="meta">@override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123; <span class="comment">// 来自接口的方法必须被定义为public</span></span><br><span class="line">        System.out.print(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="meta">@override</span> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>多重继承</strong></p><ul><li><strong>Java通过接口来解决多重继承问题。一个类可以实现多个接口，从而具有多个不同的行为。</strong></li></ul></li><li><p><strong>抽象类与接口</strong></p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">接口</th><th style="text-align:center">抽象类</th></tr></thead><tbody><tr><td style="text-align:center">组合</td><td style="text-align:center">可在新类中组合多个接口</td><td style="text-align:center">只能继承一个抽象类</td></tr><tr><td style="text-align:center">状态</td><td style="text-align:center">不能包含字段（静态字段除外）</td><td style="text-align:center">可以包含字段，且非抽象方法可以引用这些字段</td></tr><tr><td style="text-align:center">默认方法&amp;抽象方法</td><td style="text-align:center">默认方法不需要在子类中实现，它只能引用子接口中的方法</td><td style="text-align:center">抽象方法必须在子类中实现</td></tr><tr><td style="text-align:center">构造器</td><td style="text-align:center">不能有构造器</td><td style="text-align:center">可以有构造器</td></tr><tr><td style="text-align:center">访问权限</td><td style="text-align:center">隐式的public</td><td style="text-align:center">可以为protected或包访问权限</td></tr></tbody></table><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法。</li></ul></li><li><p><strong>工厂方法</strong>设计模式</p><ul><li><p>产生某个接口的对象时，不是直接调用构造器，而是在工厂对象上直接调用构建方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动物接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    Animal <span class="title function_">createAnimal</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪汪！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 狗工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@override</span> <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猫工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CatFactory</span> <span class="keyword">implements</span> <span class="title class_">AnimalFactory</span> &#123;</span><br><span class="line">    <span class="meta">@override</span> <span class="keyword">public</span> Animal <span class="title function_">createAnimal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factories</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">animalAct</span><span class="params">(AnimalFactory fact)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> fact.createAnimal();</span><br><span class="line">        a.speak();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">        animalAct(<span class="keyword">new</span> <span class="title class_">DogFactory</span>());</span><br><span class="line">        animalAct(<span class="keyword">new</span> <span class="title class_">CatFactory</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>接口的新特性</p><ul><li><p>接口中可以加入private的方法，这些方法只能被接口内的其他方法调用;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Instrument</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">()</span>&#123;           <span class="comment">// 默认是default的</span></span><br><span class="line">        System.out.print(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">         f1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="内部类">内部类</h2><ul><li><p>创建内部类</p><ul><li>内部类即定义在其他类内的类；</li><li>在外部创建非静态内部类的对象的时候，必须将对象的类型指定为 OuterClassName.InnerClassName</li></ul></li><li><p>为何使用内部类</p><ul><li>可以<strong>隐藏细节和内部结构</strong>，封装性更好；</li></ul></li><li><p>内部类可以访问外围类的所有成员（当创建一个内部类时，内部类的对象会隐含一个链接指向创建该对象的外围对象）</p></li><li><p>要使用外部类的名字，可以使用 OuterName.this ;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DotThis</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span>()&#123; <span class="comment">// 内部类</span></span><br><span class="line">        <span class="keyword">public</span> DotThis <span class="title function_">outer</span><span class="params">()</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> DoThis.<span class="built_in">this</span>;    <span class="comment">// 如果使用”this“，引用的会是Inner的”This“</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="集合">集合</h2><ul><li><p>利用泛型指定保存在集合中对象的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line">ArrayList&lt;Apple&gt; apple = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 编译时将阻止我们将错误的类型的对象放入某个集合中</span></span><br></pre></td></tr></table></figure></li><li><p>Java 集合类库（可以表示为库的两个基本接口）</p><ul><li><p><strong>Collection</strong>：一个由单独元素组成的序列；</p><ul><li><strong>List</strong> ：必须按元素插入顺序来保存他们；<ul><li><code>ArrayList</code> ：底层是<code>Object[]</code>数组；</li><li><code>LinkedList</code>：底层是双向链表；</li></ul></li><li><strong>Set</strong>：不能存在重复元素；<ul><li><code>HashSet</code>：查找速度最快；基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素；</li><li><code>TreeSet</code>：按添加顺序升序保存对象；红黑树（自平衡的排序二叉树）；</li><li><code>LinkedHashSet</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的；</li></ul></li><li><strong>Queue</strong>：先进先出<ul><li><code>ArrayQueue</code>：<code>Object[]</code> 数组 + 双指针实现；</li><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆；</li></ul></li></ul></li><li><p><strong>Map</strong> ：一组键值对对象，使用键（key）来查找值（value）；<strong>key 是无序的、不可重复的</strong>，value 是无序的、可重复的，每个键最多映射到一个值。</p><ul><li><p>List使用数值来查找某个对象，而<strong>Map使用另一个对象来查找某个对象</strong>，它将对象与对象关联在了一起，因此也被称为关联<strong>数组</strong> or <strong>字典</strong></p></li><li><p>操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map.put(key,value);  <span class="comment">//添加键值对</span></span><br><span class="line">Map.get(key) <span class="comment">// 查值</span></span><br></pre></td></tr></table></figure></li><li><p>三种风格</p><ul><li><p><code>HashMap</code>：查找顺序最快；</p><p><strong>JDK1.8 之前</strong> <code>HashMap</code> 由<strong>数组+链表</strong>组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决<strong>哈希冲突</strong>而存在的（“拉链法”解决冲突）。</p><p><strong>JDK1.8 以后</strong>在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为<strong>红黑树</strong>，以减少搜索时间。</p></li><li><p><code>TreeMap</code>：按添加元素的升序排列；</p></li><li><p><code>LinkedHashMap</code>：既按插入顺序保存对象，也保留了HashMap的查找速度；</p></li></ul></li></ul></li></ul></li><li><p><strong>List</strong></p><ul><li><p>分类</p><ul><li><code>ArrayList</code>：<strong>访问性能好，中间插入或删除元素的速度慢；</strong></li><li><code>LinkedList</code>：<strong>访问性能差，但是中间插入或删除元素的成本低；</strong></li></ul></li><li><p><code>ArrayList</code>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add();  <span class="comment">// 添加元素</span></span><br><span class="line">addAll();   <span class="comment">// 添加所有元素</span></span><br><span class="line">contains();  <span class="comment">// 确定某个对象是否在列表中</span></span><br><span class="line">remove();  <span class="comment">// 移除对象</span></span><br><span class="line">get(i);   <span class="comment">// 通过索引获取元素</span></span><br><span class="line">indexOf(value);  <span class="comment">// 获得List中的索引编号</span></span><br><span class="line">size(); <span class="comment">// 元素数量</span></span><br><span class="line">set(i，v); <span class="comment">// 替换指定索引的元素</span></span><br><span class="line">sort(); <span class="comment">//排序</span></span><br><span class="line">toString(); <span class="comment">// 转换为字符串</span></span><br><span class="line">isEmpty(); <span class="comment">// 判空</span></span><br></pre></td></tr></table></figure></li><li><p>迭代器（<strong>Iterator</strong>）</p><ul><li><code>Iterator</code>是一种用于遍历集合类（如<code>ArrayList</code>、<code>HashSet</code>等）元素的接口。通过使用<code>Iterator</code>接口，可以在不暴露集合内部结构的情况下，逐个访问集合中的元素。</li><li><code>Iterator</code>能够<strong>将序列的遍历操作和底层结构分离</strong>，即迭代器<strong>统一了对集合的访问</strong>；</li><li><code>Iterator</code>接口包含以下常用方法：<ul><li><code>boolean hasNext()</code>：如果迭代器还有下一个元素，则返回<code>true</code>。</li><li><code>E next()</code>：返回迭代器的下一个元素。</li><li><code>void remove()</code>：从迭代器返回的集合中删除迭代器最后一个元素。</li></ul></li></ul></li><li><p><code>LinkedList</code>常用方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getFirst()  element()  peek() <span class="comment">// 均为返回列表的头部     </span></span><br><span class="line">removeFirst()   remove()   <span class="comment">// 移除并返回列表头部</span></span><br><span class="line">add()  addLast()  offer()  <span class="comment">//在列表尾部插入元素</span></span><br><span class="line">addFirst()  <span class="comment">//列表开头插入元素</span></span><br><span class="line">removeLast() <span class="comment">// 移除并返回列表的最后一个元素</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Stack</strong></p><ul><li>通过<code>LinkedList</code>提供</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;String&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">s.push(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">s.pop();</span><br><span class="line">s.peek(); <span class="comment">// 返回栈顶元素</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Set</strong></p><ul><li><p>不允许有重复元素出现</p></li><li><p>常用来测试成员身份</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set1 = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">Collections.addAll(set1,<span class="string">&quot;A B C D E&quot;</span>.split(<span class="string">&quot; &quot;</span>));</span><br><span class="line">set1.contains(<span class="string">&quot;D&quot;</span>);<span class="comment">// true</span></span><br><span class="line">set1.containsAll(set2);</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Map</strong></p><ul><li><p>对象映射到对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Pet&gt; petMap = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;&gt;();</span><br><span class="line">petMap.put(<span class="string">&quot;My cat&quot;</span>,<span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;mm&quot;</span>));</span><br><span class="line">petMap.put(<span class="string">&quot;My dog&quot;</span>,<span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;ww&quot;</span>));</span><br><span class="line"><span class="type">Pet</span> <span class="variable">dog</span> <span class="operator">=</span> petMap.get(<span class="string">&quot;My dog&quot;</span>); <span class="comment">// &quot;ww&quot;</span></span><br><span class="line">petMap.getOrDefault(key,<span class="string">&quot;Not Found&quot;</span>) <span class="comment">// 获取指定 key 对应对 value，如果找不到则返回设置的默认值。</span></span><br><span class="line">petMap.containsKey(<span class="string">&quot;My cat&quot;</span>); <span class="comment">// true</span></span><br><span class="line">petMap.containsValue(dog); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>HashMap</code></p><ul><li><p><code>HashMap</code> 主要用来存放键值对，它基于哈希表的 Map 接口实现，是常用的 Java 集合之一，是<strong>非线程安全的</strong>。</p><p><code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个;</p></li><li></li></ul></li></ul></li><li><p><strong>Queue</strong></p><ul><li><p>典型的先进先出（<strong>FIFO</strong>）的集合。</p></li><li><p><code>LinkedList</code>实现了<code>Queue</code>接口，提供了支持队列行为的方法，因此可以通过将<code>LinkedList</code>向上转型为<code>Queue</code>实现队列；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通队列</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">q.offer(); <span class="comment">// 队列特有的操作，队列尾部插入元素</span></span><br><span class="line">q.peek(); <span class="comment">// 返回头部，若队列为空，则返回NULL   </span></span><br><span class="line">q.element();  <span class="comment">// 返回头部，若队列为空，则报错</span></span><br><span class="line">q.poll();  <span class="comment">// 删除头部元素，若队列为空，则返回NULL</span></span><br><span class="line">q.remove(); <span class="comment">// 删除头部元素，若队列为空，则报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端队列</span></span><br><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">dq.offerLast();</span><br><span class="line">dq.peekFirst();</span><br><span class="line">dq.getFirst();</span><br><span class="line">dq.pollFirst();</span><br><span class="line">dq.removeFirst();</span><br></pre></td></tr></table></figure></li><li><p><code>PriorityQueue</code>（优先级队列）</p><ul><li><p>优先级最高的元素先出；</p></li><li><p>当一个元素被加入队列，会先进行排序再加入；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PriorityQueue&lt;Integer&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); </span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>BlockingQueue</code> （阻塞队列）是一个接口，继承自 <code>Queue</code>。</p><ul><li><code>BlockingQueue</code>阻塞的原因是其支持当队列没有元素时一直阻塞，直到有元素；还支持如果队列已满，一直等到队列可以放入新元素时再放入。</li><li><code>BlockingQueue</code> 常用于<strong>生产者-消费者模型</strong>中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</li></ul></li></ul></li><li><p><strong>集合转数组</strong>：使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] s = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;lazy&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;over&quot;</span>, <span class="string">&quot;jumps&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(s);</span><br><span class="line"><span class="comment">// 没有指定类型的话会报错</span></span><br><span class="line">String[] ss = list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure></li><li><p><strong>数组转集合</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>&#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line"><span class="comment">//上面两个语句等价于下面一条语句</span></span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(<span class="string">&quot;Apple&quot;</span>,<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="函数式编程">函数式编程</h2><ul><li><p>通过整合现有代码来产生新功能，而不是从零开始编写所有内容；</p><p><strong>面向对象编程抽象数据，而函数式编程抽象行为</strong></p></li><li><p><strong>lambda 表达式</strong></p><ul><li><p>基本语法：</p><ul><li>参数；</li><li>后面跟 - &gt;，可以读为产生；</li><li>-&gt; 后面都是方法体。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperCaseStrings = strings.stream()</span><br><span class="line">    .map(str -&gt; str.toUpperCase()) <span class="comment">// map()方法接受一个lambda表达式作为参数，该表达式将字符串转换为大写字母。                                      //由于lambda表达式只有一个参数，因此可以省略参数列表的括号。</span></span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure></li><li><p>编写递归的lambda表达式；</p></li></ul></li><li><p><strong>方法引用</strong></p><ul><li>基本语法 ：<code>类名or对象名</code> +  <code>::</code>  + <code>方法名</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br><span class="line">list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br></pre></td></tr></table></figure><ul><li>直接引用已有的方法或构造函数，而不需要像lambda表达式那样创建新的方法体。</li><li><code>Runnable</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Go</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">go</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;go!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Thread 对象接受一个Runnable作为其构造器参数，start()方法会调用该引用的方法（run()）</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(Go::go).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="流">流</h2><ul><li><p>“ 集合优化了对象的存储，而<strong>流</strong>（stream）与对象的成批处理有关 ”</p></li><li><p><strong>声明式编程</strong>，直接说明想要完成<strong>什么</strong>（how），而不是<strong>怎么做</strong>（what）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stream</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Random</span>(<span class="number">1</span>)</span><br><span class="line">            .ints(<span class="number">2</span>, <span class="number">10</span>)</span><br><span class="line">            .limit(<span class="number">5</span>)</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="异常">异常</h2><ul><li><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li><strong><code>Exception</code></strong> ：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</li><li><strong><code>Error</code></strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。这种异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</li></ul></li><li><p><strong>捕获异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能会产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="comment">// 异常处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">// 可能会产生异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    <span class="comment">// 异常处理程序</span></span><br><span class="line">&#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 不管怎么样都会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="反射">反射</h2><ul><li><p>反射可以在程序运行时发现并使用对象的类型的<strong>所有信息</strong>；反射允许对类的成员变量，成员方法和构造方法进行编程访问；</p></li><li><p><strong>Class 对象</strong></p><ul><li><p>程序中每个类都会有一个Class 对象，它包含了与类相关的信息；</p></li><li><p>获取Class对象的三种方式：</p><ul><li><code>Class.forName(&quot;类名&quot;)</code></li><li><code>类名.class</code></li><li><code>对象.getClass( )</code> （已经创建了对象后才能使用）</li></ul></li><li><p>万物皆对象</p><ul><li>字节码文件：<code>Class</code>类的对象；</li><li>构造方法：<code>Constructor</code>类的对象；</li><li>成员变量：<code>Field</code>类的对象；</li><li>成员方法：<code>Method</code>类的对象；</li></ul></li><li><p>获取Class对象的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类名.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> User.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象.getClass()</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>().getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Class.forName(&quot;全路径&quot;)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.lm.User&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span>(User)clazz1.getDeclaredConstructor().newInstance();</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> User.class;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有public构造方法</span></span><br><span class="line">Constructor[] constructors1 = clazz.getConstructors();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有构造方法(包括private)</span></span><br><span class="line">Constructor[] constructors2 = clazz.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定有参数构造创建对象</span></span><br><span class="line"><span class="comment">//public        </span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c1</span> <span class="operator">=</span> clazz.getConstructor(String.class,<span class="type">int</span>.class);        </span><br><span class="line"><span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> (User)c1.newInstance(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);  </span><br><span class="line"><span class="comment">// private</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c2</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class, <span class="type">int</span>.class);        </span><br><span class="line">c2.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置允许访问        </span></span><br><span class="line"><span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> (User)c2.newInstance(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);</span><br></pre></td></tr></table></figure></li><li><p>获取属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> User.class;</span><br><span class="line"><span class="comment">// 获取所有public属性</span></span><br><span class="line">Field[] fields1 = clazz.getFields();</span><br><span class="line">        </span><br><span class="line"><span class="comment">// 获取所有属性（包括private）</span></span><br><span class="line">Field[] fields2 = clazz.getDeclaredFields();</span><br></pre></td></tr></table></figure></li><li><p>获取方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> user.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 方法</span></span><br><span class="line">Method[] methods1 = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:methods1)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;toString&quot;</span>))&#123;</span><br><span class="line">        m.invoke(user); <span class="comment">// 执行 toString()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// private</span></span><br><span class="line">Method[] methods2 = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m:methods2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m.getName().equals(<span class="string">&quot;run&quot;</span>))&#123;</span><br><span class="line">        m.setAccessible(<span class="literal">true</span>); <span class="comment">// 设置允许访问</span></span><br><span class="line">        m.invoke(user); <span class="comment">// 执行 private run()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>转型前检查</p><ul><li>在java中，可以使用<code>instanceof</code>关键字检查一个对象是否是某个类的实例；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">    ((DOg)x).bark();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理（proxy）</p><ul><li>在程序运行期，创建目标对象的代理对象，并对目标对象中的方法进行功能性增强的一种技术；</li><li><strong>AOP</strong>思想：基于动态代理思想，对原来目标对象创建代理对象，在不修改原对象代码情况下，通过代理对象调用增强功能的代码，从而对原有业务方法进行增强。</li></ul></li></ul><h2 id="泛型">泛型</h2><ul><li><p>让代码只需依赖于 &quot; <strong>某种不具体指定的类型</strong> &quot;，而不是特定的接口或类，那么就可以编写出更为通用的代码；</p></li><li><p>泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Generic</span>&lt;T&gt;&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Generic</span><span class="params">(T key)</span> &#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getKey</span><span class="params">()</span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型通配符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span>&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;key value is &quot;</span> + obj.getKey());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 类型通配符一般是使用？代替具体的类型实参</span></span><br><span class="line"><span class="comment">// 此处’？’是类型实参，而不是类型形参!!!</span></span><br><span class="line"><span class="comment">// ?和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。</span></span><br></pre></td></tr></table></figure></li><li><p>泛型方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型方法，需要将泛型参数列表(&lt;T&gt;)放在返回值之前(必不可少！)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(T x)</span>&#123;</span><br><span class="line">    System.out.println(x.getClass().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="String">String</h2><ul><li><p><code>String</code> 类中使用 <code>final</code> 关键字修饰字符数组来保存字符串，所以<code>String</code> 对象是不可变的。</p></li><li><p>线程安全性</p><ul><li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全；</li><li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li><li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li></ul></li><li><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String <strong>字符串的值</strong>是否相等。（<code>Object</code> 的 <code>equals</code> 方法是比较的<strong>对象的内存地址</strong>。）</p></li><li><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在堆中创建字符串对象”ab“</span></span><br><span class="line"><span class="comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span></span><br><span class="line"><span class="type">String</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span></span><br><span class="line"><span class="type">String</span> <span class="variable">bb</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">System.out.println(aa==bb);<span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p><code>String.intern()</code> 方法，其作用是将指定的字符串对象的引用保存在字符串常量池中。</p><ul><li>如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。</li><li>如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="简介">简介</h2><ul><li><p><code>Redis</code>（Remote Dictionary Server）是一个<strong>基于内存</strong>的<code>key-value</code>的结构数据库，它可以用作数据库，缓存和消息中间件。</p><ul><li><p>单线程，每个命令具备原子性</p></li><li><p>基于内存存储，读写性能高</p></li><li><p>适合存储热点数据（热点资讯，热点商品）</p></li></ul></li><li><p><code>Redis</code>是一种典型的<code>NoSql</code>数据库（非关系型数据库）；</p></li><li><p><code>Redis</code>所有的数据结构都以唯一的<code>key</code>字符串作为名称，然后通过唯一的<code>key</code>获取相应的<code>value</code>；不同数据结构之间的差异就在于<code>value</code>的数据结构的不同。</p></li></ul><h3 id="常用数据类型">常用数据类型</h3><ul><li>字符串（<code>string</code>）：普通字符串，常用；</li><li>哈希（<code>hash</code>）：适合存储对象；</li><li>列表（<code>list</code>）：按照插入元素顺序排序，可以有重复元素；</li><li>无序集合（<code>set</code>）：无序集合，没有重复元素；</li><li>有序集合（<code>sorted set</code>）：有序集合，没有重复元素；</li></ul><h2 id="常用命令">常用命令</h2><ul><li><p><code>String</code>操作命令</p><ul><li>Redis中的字符串是动态的可以修改的字符串，类似于<code>ArrayList</code>；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> key <span class="keyword">value</span></span><br><span class="line"><span class="keyword">GET</span> key</span><br><span class="line">SETEX key seconds <span class="keyword">value</span>  # 设置指定key的值，并将key的过期时间设为seconds</span><br><span class="line">SETNX key <span class="keyword">value</span>  # 只有key不存在时设置key的值</span><br></pre></td></tr></table></figure></li><li><p><code>hash</code>操作命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HSET key field <span class="keyword">value</span></span><br><span class="line">HGET key field</span><br><span class="line">HDEL key field</span><br><span class="line">HKEYS key   # 获取Hash表中所有字段</span><br><span class="line">HVALS key   # 获取Hash表中所有值</span><br><span class="line">HGETALL key  # 获取Hash表中指定key所有字段和值</span><br></pre></td></tr></table></figure></li><li><p><code>list</code>操作命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key value1 [value2] # 将一个或多个元素插入列表头部</span><br><span class="line">LRANGE key <span class="keyword">start</span> stop   # 获取指定范围内的元素</span><br><span class="line">RPOP key     # 移除并获取列表最后一个元素</span><br><span class="line">LLEN key     # 获取列表长度</span><br><span class="line">BRPOP key1 [key2] timeout  # 移出并获取列表最后一个元素</span><br></pre></td></tr></table></figure></li><li><p><code>set</code>操作命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SADD key memeber1 [memeber2] # 添加一个或多个成员</span><br><span class="line">SMEMBERS key         # 返回集合中所有元素</span><br><span class="line">SCARD key     # 获取集合中的成员数</span><br><span class="line">SREM key memeber1 [memeber2]   #移除一个或多个成员</span><br></pre></td></tr></table></figure></li><li><p><code>sorted set</code></p><p>每个元素都会关联一个 double 类型的分数。<code>redis</code>正是通过分数来为集合中的成员进行从小到大的排序。</p><p>有序集合的成员是唯一的,但分数(score)却可以重复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZADD key score <span class="keyword">member</span>  # 添加成员或更新分数</span><br><span class="line">ZRANGE  key <span class="keyword">start</span> stop [WITHSCORES] # 返回指定范围内的成员</span><br><span class="line">ZINCRBY key increment memeber # 对指定成员的分数加上increment</span><br><span class="line">ZREM key memeber # 移除成员</span><br></pre></td></tr></table></figure></li><li><p>通用命令</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">KEYS <span class="keyword">pattern</span>    # 查找所有符合的key</span><br><span class="line"><span class="keyword">EXISTS</span> key   # 检查key是否存在</span><br><span class="line">TYPE key  # 查看key对应的类型</span><br><span class="line">TTL key  #返回key的剩余生存时间(<span class="type">time</span> <span class="keyword">to</span> live),以秒为单位</span><br><span class="line">         # <span class="number">-1</span>表示存活时间为永久</span><br><span class="line">DEL key  #删除key</span><br></pre></td></tr></table></figure></li></ul><h2 id="Java客户端工具">Java客户端工具</h2><h3 id="jedis">jedis</h3><h4 id="jedis配置">jedis配置</h4><p>jedis就是基于java语言的redis客户端，集成了redis的命令操作，提供了连接池管理。（线程不安全）</p><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>连接测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Jedis jedis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行测试文件前执行</span></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 1. 建立连接</span></span><br><span class="line">        jedis = <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="comment">// 2. 设置密码</span></span><br><span class="line">        jedis.auth(<span class="string">&quot;lm12138&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 选择库</span></span><br><span class="line">        jedis.select(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 设置数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> jedis.set(<span class="string">&quot;ming&quot;</span>, <span class="string">&quot;22&quot;</span>);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;ming&quot;</span>);</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放缓存</span></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(jedis!=<span class="literal">null</span>)&#123;</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="jedis连接池">jedis连接池</h4><p>jedis线程不安全，频繁的连接和释放连接会有损害性能，推荐用线程池；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisConnectionFactory</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 配置连接池</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">poolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        poolConfig.setMaxTotal(<span class="number">8</span>);<span class="comment">// 最大连接数</span></span><br><span class="line">        poolConfig.setMaxIdle(<span class="number">4</span>); <span class="comment">// 最大空闲连接数</span></span><br><span class="line">        poolConfig.setMinIdle(<span class="number">0</span>); <span class="comment">// 最小空闲连接</span></span><br><span class="line">        poolConfig.setMaxWaitMillis(<span class="number">1000</span>); <span class="comment">// 最大等待时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(poolConfig,<span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">                <span class="number">6379</span>,<span class="number">1000</span>,<span class="string">&quot;lm12138&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取jedis对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="spring-data-redis">spring-data-redis</h3><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫做<code>SpringDataRedis</code></p><blockquote><p><strong>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525140217446.png" alt="image-20220525140217446"></p><h4 id="基本配置">基本配置</h4><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">lm12138</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure></li><li><p>测试连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisDemoApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;ming&quot;</span>,<span class="number">21</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">age</span> <span class="operator">=</span> redisTemplate.opsForValue().get(<span class="string">&quot;ming&quot;</span>);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="RedisSerializer配置">RedisSerializer配置</h4><hr><blockquote><p><strong>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，<code>默认是采用JDK序列化</code>，得到的结果是这样的</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525170205272.png" alt="image-20220525170205272"></p><p>**缺点：**可读性差，内存占用较大</p><ul><li><p>编写配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String ,Object&gt; redisTemplate = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 2.设置连接工厂</span></span><br><span class="line">        redisTemplate.setConnectionFactory(factory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建序列化对象</span></span><br><span class="line">        <span class="type">StringRedisSerializer</span> <span class="variable">stringRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>();</span><br><span class="line">        <span class="type">GenericJackson2JsonRedisSerializer</span> <span class="variable">genericJackson2JsonRedisSerializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.设置key和hashKey采用String的序列化方式</span></span><br><span class="line">        redisTemplate.setKeySerializer(stringRedisSerializer);</span><br><span class="line">        redisTemplate.setHashKeySerializer(stringRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.设置value和hashValue采用json的序列化方式</span></span><br><span class="line">        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line">        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> redisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于我们设置的value序列化方式是Json的，因此我们可以直接向redis中插入一个<strong>对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> &#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;ming&quot;</span>, <span class="number">21</span>));</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;User = &quot;</span> + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="StringRedisTemplate">StringRedisTemplate</h4><blockquote><p><strong>为了节省内存空间，我们并不会使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</strong></p></blockquote><p><img src="https://image-bed-vz.oss-cn-hangzhou.aliyuncs.com/Redis/image-20220525172001057.png" alt="image-20220525172001057"></p><blockquote><p><strong>Spring默认提供了一个StringRedisTemplate类，它的key和value的序列化方式默认就是String方式。省去了我们自定义RedisTemplate的过程</strong></p></blockquote><ul><li><p>我们可以直接编写一个测试类使用<code>StringRedisTemplate</code>来执行以下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisStringTemplateTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException &#123;</span><br><span class="line"><span class="comment">// 1.创建一个Json序列化对象</span></span><br><span class="line"><span class="type">ObjectMapper</span> <span class="variable">objectMapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"><span class="comment">// 2.将要存入的对象通过Json序列化对象转换为字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson1</span> <span class="operator">=</span> objectMapper.writeValueAsString(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Vz&quot;</span>, <span class="number">21</span>));</span><br><span class="line"><span class="comment">// 3.通过StringRedisTemplate将数据存入redis</span></span><br><span class="line">stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>,userJson1);</span><br><span class="line"><span class="comment">// 4.通过key取出value</span></span><br><span class="line"><span class="type">String</span> <span class="variable">userJson2</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line"><span class="comment">// 5.由于取出的值是String类型的Json字符串，因此我们需要通过Json序列化对象来转换为java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> objectMapper.readValue(userJson2, User.class);</span><br><span class="line"><span class="comment">// 6.打印结果</span></span><br><span class="line">System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RedisTemplate的两种序列化实践方案，两种方案各有各的优缺点，可以根据实际情况选择使用。</p><p>方案一：</p><ol><li>自定义RedisTemplate</li><li>修改RedisTemplate的序列化器为GenericJackson2JsonRedisSerializer</li><li>缺点：占用内存空间，需要记录类的字节码</li></ol><p>方案二：</p><ol><li>使用StringRedisTemplate</li><li>写入Redis时，手动把对象序列化为JSON</li><li>读取Redis时，手动把读取到的JSON反序列化为对象</li></ol></li></ul><h2 id="缓存">缓存</h2><h3 id="简介-v2">简介</h3><p>缓存是数据交换得缓冲区（Cache），用于存储临时数据，一般读写性能较高；</p><ul><li><p>缓存的作用</p><ul><li>降低后端负载</li><li>提高读写速率，降低响应速率</li></ul></li><li><p>缓存的成本</p><ul><li>数据一致性成本</li><li>代码维护成本</li><li>运维成本（集群部署等）</li></ul></li><li><p>通常我们这样使用缓存：</p><ul><li>写请求只写数据库</li><li>读请求先读缓存，如果缓存不存在，则从数据库读取，并更新缓存</li><li>同时，写入缓存中的数据，都设置失效时间</li></ul></li></ul><p><img src="C:%5CUsers%5CMistletoe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230712110056150.png" alt="image-20230712110056150"></p><p>​这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「<strong>热数据</strong>」，缓存利用率得以最大化。</p><h3 id="缓存更新策略">缓存更新策略</h3><ul><li><p>缓存更新策略</p><ul><li>内存淘汰：利用Redis的内存淘汰机制；</li><li>超时剔除：给缓存数据添加超时时间；</li><li>主动更新：编写业务逻辑，在修改数据库的同时，更新缓存；</li></ul></li><li><p>删除缓存还是更新缓存？</p><ul><li>更新缓存：每次更新数据库都需要更新缓存，无效写操作较多；</li><li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存（<strong>更优</strong>）</li></ul></li><li><p>如何保证缓存和数据库操作的原子性？</p><ul><li>单体系统，将缓存和数据库放在一个事务中；</li><li>分布式系统：利用TCC等分布式事务方案；</li></ul></li><li><p>这里存在<strong>数据一致性问题</strong>，当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。这两个操作并非是原子的，所以有先后顺序；</p><ul><li><p>先删除缓存，再更新数据库：</p><ul><li><p>初始化（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 删除缓存后（数据库：1 ，缓存：null）</p></li><li><p><em>线程2</em> 前来查询缓存未命中，查询数据库，并将查询到的数据写入缓存（数据库：1 ，缓存：1）</p></li><li><p><em>线程1</em> 再更新数据库（数据库：2 ，缓存：1）</p></li><li><p>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率较大</strong>，因为Redis的读写速度比数据库快很多，并发情况下很容易发生这种情况。</p></li></ul></li><li><p>先更新数据库，再删除缓存</p><ul><li>初始化，恰好缓存失效（数据库：1 ，缓存：null）</li><li><em>线程1</em> 查询缓存未命中并查询数据库（1）</li><li><em>线程2</em> 更新数据库（数据库：2 ，缓存：null）</li><li><em>线程2</em>  删除缓存（数据库：2 ，缓存：null）</li><li><em>线程1</em> 写入缓存（数据库：2 ，缓存：1）</li><li>导致数据库和缓存数据不一致问题；<strong>这种情况发生的概率很小</strong>（线程1之前缓存恰好失效；Redis写入速度很快，在其之前有线程插入并更新数据库的概率很小）</li></ul></li></ul></li><li><p>因此，缓存更新策略的最佳实践方案为：</p><ul><li>低一致性需求：使用Redis自带的内存淘汰机制；</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案；<ul><li>读操作：<ul><li>缓存命中则直接返回；</li><li>缓存未命中则直接查询数据库，并写入缓存，并设定超时时间；</li></ul></li><li>写操作：<ul><li>先写数据库，然后再删除缓存；</li><li>要确保数据库与缓存操作的原子性；</li></ul></li></ul></li></ul></li></ul><h3 id="缓存穿透">缓存穿透</h3><ul><li><p>缓存穿透是指客户端<strong>请求的数据在缓存和数据库中都不存在</strong>，这样缓存永远都不会生效，这些请求都会到数据库。（可能会被无效请求恶意攻击）。</p></li><li><p>解决方案：</p><ul><li><p>缓存空对象：对于无效的请求，缓存一个null对象</p><ul><li><p>优点：实现简单，维护简单</p></li><li><p>缺点：</p><ul><li>额外的内存消耗</li><li>可能造成短期的数据不一致</li></ul></li></ul></li><li><p>布隆过滤</p><ul><li>请求与Redis缓存之间设置一布隆过滤器，由布隆过滤器判断请求数据是否存在，存在则放行，不存在则直接返回。</li><li>布隆过滤器并不是存储了所有数据，而是通过某种算法来判断请求数据是否存在。</li></ul></li></ul></li></ul><h3 id="缓存雪崩">缓存雪崩</h3><ul><li>缓存雪崩是指 <strong>同一时段大量的缓存key同时失效或者Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。</li><li>解决方案：<ul><li>给不同的key添加随机失效时间；</li><li>利用Redis集群提高服务的可用性；</li><li>给缓存业务添加降级限流策略；</li><li>给业务添加多级缓存；</li></ul></li></ul><h3 id="缓存击穿">缓存击穿</h3><ul><li><p>缓存击穿问题也被称为<strong>热点key</strong>问题，就是一个<strong>被高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求在瞬间给数据库带来巨大的冲击。</p></li><li><p>解决方案：</p><ul><li><p>互斥锁：查询缓存未命中时，先获取互斥锁，获取锁成功后查询数据库并重建缓存，写入缓存后再释放锁；这样，其他线程请求无法在缓存重建期间查询缓存。</p><p>线程需要等待，性能收到影响；可能有死锁风险。</p></li><li><p>逻辑过期：<strong>给缓存的数据添加一个逻辑过期字段，而不是真正的给它设置一个TTL</strong>。每次查询缓存的时候去判断是否已经超过了我们设置的逻辑过期时间，如果未过期，直接返回缓存数据；如果已经过期则进行缓存重建。</p><ul><li>优点：<ul><li>线程无需等待，性能较好</li></ul></li><li>缺点：<ul><li>不保证一致性(因为会返回过期数据)</li><li>有额外的内存消耗(同时缓存了逻辑过期时间的字段)</li><li>实现复杂</li></ul></li></ul></li></ul></li></ul><h2 id="秒杀">秒杀</h2><h3 id="分布式全局唯一ID">分布式全局唯一ID</h3><ul><li><p>**<em>UUID(通用唯一标识符)**表示一个128位长的唯一值。 它也被普遍称为</em>GUID(全球唯一标识符)。我们可以使用*UUID*类来生成随机文件名，会话或事务ID。 UUID的另一种流行用法是在数据库中生成主键值。<strong>有极小的概率会重复</strong>。</p></li><li><p><strong>雪花算法</strong></p><p>由64位<code>bit</code>字符组成（Long）<br>$$<br>0\quad \quad0000 … 0000\quad\quad\quad 000000 0000 \quad\quad 0000 0000 0000<br>$$<br>​                                                       <strong>符号位   时间戳：41 bit          机器ID：10 bit</strong>      <strong>12 bit 序列号</strong></p><ul><li><p>组成：</p><ul><li>符号位：1 bit，生成ID一般均为正数，因此为0；</li><li>时间戳：41 bit，单位为ms，可以使用约69年；</li><li>机器ID：10 bit，可以支持1024个分布式机器；</li><li>序列号：12 bit，表示每ms可以生成$2^{12}=1024$个不同ID；</li></ul></li><li><p>特点</p><ul><li>按时间递增</li><li>唯一性</li><li>生成效率高</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成全局唯一ID（** 雪花算法 **）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UIDWorker</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始时间戳</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1692213900</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">nextId</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="comment">// 生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 机器ID</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">machineId</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成序列号(通过Redis自增生成序列)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">nowDateTime</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="type">long</span> <span class="variable">increment</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                         .increment(<span class="string">&quot;icr&quot;</span> + prefix + <span class="string">&quot;:&quot;</span> + nowDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拼接并返回</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> timestamp &lt;&lt; <span class="number">22</span> | machineId &lt;&lt; <span class="number">12</span> | increment;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>雪花算法的**时钟回拨 **问题</p><ul><li>由于雪花算法对于时钟特别敏感，因此如果时钟出现回拨现象，有可能导致获取的ID重复。</li><li>正常来说只要不是不是有人手贱或者出于泄愤的目的进行干扰，系统的时间漂移是一个在毫秒级别的极短的时间。因此可以在获取 ID 的时候，记录一下当前的时间戳。然后在下一次过来获取的时候，<strong>对比一下当前时间戳和上次记录的时间戳，如果发现当前时间戳小于上次记录的时间戳，所以出现了时钟回拨现象，对外抛出异常，本次 ID 获取失败</strong>。理论上当前时间戳会很快的追赶上上次记录的时间戳。</li></ul></li></ul><h3 id="超卖问题">超卖问题</h3><ul><li><p>高并发场景下，做个线程交叉执行可能会出现超卖问题；</p><ul><li><p><code>初始</code>：库存：1；</p></li><li><p><code>线程1</code>：查询库存为1；</p></li><li><p><code>线程2</code>：查询库存为1；</p></li><li><p><code>线程1</code>：扣减库存，下单成功；</p></li><li><p><code>线程2</code>：扣减库存，下单成功；</p></li><li><p><code>库存</code>：<strong>-1</strong>（出现超买问题）；</p></li></ul></li><li><p>解决方案：加锁</p></li><li><p><strong>悲观锁</strong></p><ul><li>认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</li><li>例如<code>Synchronized</code>，<code>Lock</code>都属于悲观锁；</li><li>特点：简单直接，性能差；</li></ul></li><li><p><strong>乐观锁</strong></p><ul><li>认为线程安全问题不一定会发生，因此不加锁，只是<strong>在更新数据时判断是否有其他线程对数据进行了修改</strong>。<ul><li>如果没有，则认为是安全的，更新数据；</li><li>如果有，则重试或者抛出异常；</li></ul></li><li>特点：性能好，但容易出现成功率过低的问题；</li></ul></li><li><p>乐观锁的实现方式</p><ul><li><p><strong>版本号法</strong>：为资源添加一个version版本号，当修改资源后version就加一，修改资源前判断版本号是否被修改；</p><ul><li><p><code>初始</code>：库存：1；（ version = 1 ）</p></li><li><p><code>线程1</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程2</code>：查询库存为1；（ version = 1 ）</p></li><li><p><code>线程1</code>：扣减库存，下单成功；（ version = 2 ）</p></li><li><p><code>线程2</code>：此时发现version与查询时的不同，说明资源被其他线程修改，下单失败；</p></li></ul></li><li><p><strong>CAS</strong>（<code>Compare And Swap</code>）：CAS算法有三个操作数，通过内存中的值（V）、预期原始值（A)、修改后的新值。<br>（1）如果内存中的值和预期原始值相等， 就将修改后的新值保存到内存中。<br>（2）如果内存中的值和预期原始值不相等，说明共享数据已经被修改，放弃已经所做的操作，然后重新执行刚才的操作，直到重试成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">        .setSql(<span class="string">&quot;stock = stock - 1&quot;</span>) <span class="comment">// set stock = stock - 1</span></span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId) <span class="comment">// where ...</span></span><br><span class="line">        .eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock())</span><br><span class="line">        .update();</span><br></pre></td></tr></table></figure><p>该方法能够解决超卖问题，但是高并发场景下成功率过低，影响业务；</p></li></ul></li></ul><h3 id="一人一单">一人一单</h3><ul><li><p>业务场景下，同一个用户对同一优惠券只能下一次单。（抵制黄牛！）</p></li><li><p>加<code>sycronized</code>锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取用户Id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// toString()底层每次调用都会重新创建一个String对象，导致synchronized失效</span></span><br><span class="line">    <span class="comment">// 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 一人一单</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).count();</span><br><span class="line">        <span class="keyword">if</span>(count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Result.fail(<span class="string">&quot;用户已经抢购过该优惠券！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上代码可能会导致线程安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern())&#123;</span><br><span class="line">        <span class="comment">// 一人一单</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 锁释放，此时其他线程可以进来</span></span><br><span class="line">    <span class="comment">// 而事务尚未提交，线程不安全！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    <span class="comment">// toString()底层每次调用都会重新创建一个String对象，导致synchronized失效</span></span><br><span class="line">    <span class="comment">// 调用intern()方法:如果字符串池中存在该字符串对象，则直接返回，而不是重新创建一个字符串</span></span><br><span class="line">    <span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.createVoucherOrder(voucherId); <span class="comment">// **事务失效** 问题</span></span><br><span class="line">        <span class="comment">// 事务已提交</span></span><br><span class="line">    &#125; <span class="comment">// 释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">createVoucherOrder</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>以上有可能导致<strong>事务失效</strong>问题，解决方案如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line"><span class="keyword">synchronized</span> (userId.toString().intern()) &#123;</span><br><span class="line">    <span class="comment">// 拿到当前对象的代理对象</span></span><br><span class="line">    <span class="type">IVoucherOrderService</span> <span class="variable">proxy</span> <span class="operator">=</span> (IVoucherOrderService) AopContext.currentProxy();</span><br><span class="line">    <span class="keyword">return</span> proxy.createVoucherOrder(voucherId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="分布式锁">分布式锁</h2><h3 id="简介-v3">简介</h3><ul><li><p><code>sycronized</code>只能在一个<code>JVM</code>内部实现不同线程之间的互斥，集群下可能出现线程安全问题</p></li><li><p><strong>分布式锁</strong>：满足分布式系统或集群模式下多进程可见的互斥锁。</p></li><li><p>特点：</p><ul><li>多进程可见</li><li>互斥</li><li>高性能</li><li>高可用</li><li>安全性</li></ul></li><li><p>实现方式</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">MySQL</th><th style="text-align:center">Redis</th></tr></thead><tbody><tr><td style="text-align:center">互斥</td><td style="text-align:center">利用MySQL本身的互斥锁机制</td><td style="text-align:center">利用setnx命令</td></tr><tr><td style="text-align:center">高可用</td><td style="text-align:center">好</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">高性能</td><td style="text-align:center">一般</td><td style="text-align:center">好</td></tr><tr><td style="text-align:center">安全性</td><td style="text-align:center">断开连接，自动释放锁</td><td style="text-align:center">利用锁超时时间，到期释放</td></tr></tbody></table></li></ul><h3 id="基于Redis实现分布式锁">基于Redis实现分布式锁</h3><ul><li><p>获取锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 利用setnx的互斥特性</span><br><span class="line">SETNX lock thread1</span><br><span class="line"># 添加锁过期时间，避免服务宕机引起的死锁</span><br><span class="line">EXPIRE lock <span class="number">30</span></span><br></pre></td></tr></table></figure><p>以上两条命令不具备原子性，可以使用以下命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> lock thread NX EX <span class="number">30</span></span><br></pre></td></tr></table></figure></li><li><p>释放锁</p><p>手动释放或超时释放</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除即可</span><br><span class="line">DEL lock</span><br></pre></td></tr></table></figure></li><li><p>实现Redis分布式锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeoutSec 锁持有的超时时间，过期后自动释放</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true代表获取锁成功; false代表获取锁失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleRedisLock</span> <span class="keyword">implements</span> <span class="title class_">ILock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ID_PREFIX</span> <span class="operator">=</span> UUID.randomUUID(<span class="literal">true</span>) + <span class="string">&quot;-&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;lock_&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SimpleRedisLock</span><span class="params">(StringRedisTemplate stringRedisTemplate, String lockName)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lockName = lockName;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeoutSec)</span> &#123;</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">          获取锁时存入线程标识</span></span><br><span class="line"><span class="comment">          解决分布式锁 **误删** 问题</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取线程标示</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> stringRedisTemplate.opsForValue()</span><br><span class="line">                .setIfAbsent(LOCK_PREFIX + lockName, threadId, timeoutSec, TimeUnit.MINUTES);</span><br><span class="line"><span class="comment">//        return isSuccess;  // 可能会在自动拆箱过程中出现空指针</span></span><br><span class="line">        <span class="keyword">return</span> Boolean.TRUE.equals(isSuccess);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         释放锁时先获取锁中的线程标识，判断是否与当前标识相同</span></span><br><span class="line"><span class="comment">         如果一致则释放锁，不一致则不释放锁；</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">threadId</span> <span class="operator">=</span> ID_PREFIX + Thread.currentThread().getId();</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(LOCK_PREFIX + lockName);</span><br><span class="line">        <span class="keyword">if</span> (threadId.equals(id)) &#123;</span><br><span class="line">            stringRedisTemplate.delete(LOCK_PREFIX + lockName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决分布式锁 <strong>误删</strong> 问题</p><ul><li><p><code>线程1</code>：获取锁成功（<code>lock1</code>），执行任务；（任务时间较久或宕机）</p></li><li><p>超过超时时间，锁自动释放；</p></li><li><p><code>线程2</code>：获取锁成功（<code>lock1</code>），执行任务；</p></li><li><p><code>线程1</code>：任务执行成功，释放锁；</p></li><li><p>此时<code>线程2</code>还未执行完毕，<code>线程 1 </code>误删了<code>线程 2 </code>的锁；</p></li></ul><p>解决方案：</p></li><li><p>获取锁时存入线程标识（可以使用<code>UUID</code>）；</p><ul><li>释放锁时先获取锁中的线程标识，判断是否与当前标识相同，如果一致则释放锁，不一致则不释放锁；</li></ul></li><li><p>分布式锁的<strong>原子性</strong></p><ul><li><p>由于上述判断线程标识与释放锁的操作不具备原子性，因此可能会有线程安全问题；</p></li><li><p>Redis提供了lua脚本功能，在一个脚本中编写多条redis命令，确保多条命令执行时的原子性；</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL script key [key ...]  # 执行脚本</span><br></pre></td></tr></table></figure></li></ul></li><li><p>实现思路总结</p><ul><li>利用<code>SETNX</code>命令获取锁，设置过期时间，并存入线程标识；</li><li>释放锁时先判断标识是否一致，一致则删除锁；</li></ul></li><li><p>基于<code>SETNX</code>实现分布式锁的问题：</p><ul><li>不可重入：同一个线程无法多次获取同一把锁；</li><li>不可重试：获取锁失败时返回false，没有重试机制；</li><li>超时释放：超时释放虽然可以避免死锁；设置超时时间过短，若业务执行时间过长，也会导致锁释放，存在安全隐患；设置超时时间过长，导致业务停滞；</li><li>主从一致性</li></ul></li></ul><h3 id="Redisson">Redisson</h3><ul><li><p><strong>Redisson使用</strong></p><ul><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reddision 配置</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 配置</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 单节点</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="string">&quot;lm12138&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建RedissonClient对象</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>Redisson</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取锁，指定锁名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock();</span><br><span class="line">    <span class="comment">// 判断是否获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(!isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">// 业务逻辑</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">// 释放锁</span></span><br><span class="line">          lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="秒杀优化">秒杀优化</h3><ul><li><p>秒杀流程回顾：</p><ul><li>查询优惠券（数据库）</li><li>判断秒杀库存</li><li>查询订单（数据库）</li><li>校验一人一单</li><li>减库存（数据库）</li><li>创建订单（数据库）</li></ul></li><li><p><strong>异步秒杀</strong>：</p><ul><li>新增秒杀优惠券的同时，将秒杀库存保存到Redis中；</li><li>基于lua脚本，判断秒杀库存，一人一单，决定用户是否抢购成功</li><li>如果抢购成功，将优惠券id和用户id存入阻塞队列</li><li>开启线程任务，不断从阻塞队列中获取信息，实现异步下单功能</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL学习笔记</title>
      <link href="/2023/06/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2023/06/28/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL基础">MySQL基础</h2><ul><li><p>数据库：保存有组织的数据库的容器；</p><p>数据库管理系统（DBMS）：数据库软件，通过DBMS来创建和操纵数据库；</p></li><li><p>关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）；常见的关系型数据库有<strong>MySQL</strong>、PostgreSQL、Oracle、SQL Server、SQLite；</p></li><li><p><strong>连接器</strong>：与数据库建立连接；</p></li><li><p><strong>连接池</strong></p><ul><li><p>背景：传统的数据库连接方式是，用户每次请求都要向数据库获取连接，而数据库连接的创建和关闭需要一定的开销。<strong>频繁的建立、关闭数据库，会极大的降低系统的性能，增大系统的开销</strong>，甚至成为系统的瓶颈。</p></li><li><p>MySQL连接池是一个数据库连接管理器，它允许应用程序在需要时从预定义的一组连接中获取数据库连接，而不是为每个请求创建一个新的连接。这有助于<strong>减少应用程序的资源占用，提高数据库性能和可伸缩性</strong>。</p></li><li><p>连接池管理连接的生命周期，并确保连接在不再需要时被正确回收，主要包括以下组件：</p><ul><li>连接池管理器：负责连接的创建，回收和管理。</li><li>连接池配置：<ol><li><strong>最大连接数</strong>：连接池中允许的最大连接数；</li><li><strong>连接等待超时时间</strong>：连接池中连接请求的等待时间；</li><li>**连接验证：**连接池可以通过连接验证来确保连接池中的连接仍然有效。</li></ol></li></ul></li></ul></li><li><p><strong>基本数据类型</strong></p><ul><li>数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）、浮点型（float 和 double）、定点型（decimal）</li><li>字符串类型：char（固定长度）、varchar（可变长度）、tinytext、text、mediumtext、longtext、tinyblob、blob、mediumblob 和 longblob 等，最常用的是 char 和 varchar 。</li><li>日期时间类型：year、time、date、datetime 和 timestamp 等</li></ul></li><li><p><strong>MySQL基础架构</strong></p></li></ul><p><img src="/images/mysql-framework.png" alt="img"></p><ul><li><p><strong>MySQL语句</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">use database; // 选择数据库</span><br><span class="line"></span><br><span class="line"># 检索</span><br><span class="line">select distinct username from users; # 检索不同的行</span><br><span class="line">select distinct username from users </span><br><span class="line">limit 5; # 返回不多于5行</span><br><span class="line">select distinct username from users </span><br><span class="line">limit 5,3; # 返回从行5开始的3行</span><br><span class="line"></span><br><span class="line"># 排序</span><br><span class="line">select username </span><br><span class="line">from users order by username; # 按username的字母顺序升序排序</span><br><span class="line">select username </span><br><span class="line">from users order by username desc; # 降序</span><br><span class="line">select id,username,email </span><br><span class="line">from users order by id,username; # 对id相同的行使用username排序</span><br><span class="line"></span><br><span class="line"># 过滤数据</span><br><span class="line">select username from users where userid &lt; 5 or userid &gt; 10;</span><br><span class="line">select username from users where userid between 3 and 5;</span><br><span class="line">select username from users where username is null # 空值检查</span><br><span class="line">select username from users </span><br><span class="line">where userid &lt; 5 and username = &#x27;xxx&#x27;;</span><br><span class="line">select username from users where id in(10,12);</span><br><span class="line"></span><br><span class="line"># 使用通配符过滤</span><br><span class="line"></span><br><span class="line"># 百分号( % )通配符：表示任意字符出现任意次数</span><br><span class="line">select id,uername from users </span><br><span class="line">where username like &#x27;li%&#x27;; #检索以li起头的词</span><br><span class="line"># 下划线( _ )通配符：表示任意字符出现一次，即只匹配一个字符</span><br><span class="line">select id,uername from users </span><br><span class="line">where username like &#x27;_i ming&#x27;; #检索Xi ming 格式的词</span><br><span class="line"></span><br><span class="line"># 使用正则表达式搜索</span><br><span class="line">select id from users </span><br><span class="line">where regexp &#x27;.000&#x27;; # .表示任意字符</span><br><span class="line">select id from users </span><br><span class="line">where regexp &#x27;1000 | 2000&#x27;;</span><br><span class="line"></span><br><span class="line"># 拼接字段</span><br><span class="line">select Concat(information,&#x27;(&#x27;,age,&#x27;)&#x27;) from users; # 输出实例：ming(20)</span><br><span class="line"># 使用别名</span><br><span class="line">select username as customer_name from users;</span><br><span class="line"></span><br><span class="line"># 汇总数据</span><br><span class="line"># AVG() COUNT() MAX() MIN() SUM()</span><br><span class="line">select AVG(price) as avg_price from products;</span><br><span class="line">select COUNT(*) as num_pro from products; # 对表中的所有行的数目计数（包括NULL）</span><br><span class="line">                                         # COUNT(COLUMN)：对特定的列中具有值的行进行计数，忽略NULL</span><br><span class="line">                                         # SUM(COLUMN)：返回指定列值的和</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">insert into users(username,email) </span><br><span class="line">values(&#x27;mike&#x27;,&#x27;mike@test.com&#x27;); </span><br><span class="line"></span><br><span class="line">insert into users(username,email) </span><br><span class="line">values(&#x27;mike&#x27;,&#x27;mike@test.com&#x27;), </span><br><span class="line">values(&#x27;jack&#x27;,&#x27;jack@test.com&#x27;); # 列名和次序相同时，可以同时插入多行</span><br><span class="line"></span><br><span class="line"># 更新数据</span><br><span class="line">update users</span><br><span class="line">set username = &#x27;xxx&#x27;,email = &#x27;xx@xxx.com&#x27;</span><br><span class="line">where id = 1000;</span><br><span class="line"></span><br><span class="line"># 删除数据</span><br><span class="line">delete from users</span><br><span class="line">where id = 1000;</span><br><span class="line"></span><br><span class="line"># !!! 如果不带where字句，则会删除或更新所有行</span><br></pre></td></tr></table></figure></li><li><p><strong>创建和操纵表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 创建表</span><br><span class="line">create table users</span><br><span class="line">(</span><br><span class="line">    id            int        not NULL auto_increment, # 自动增量</span><br><span class="line">    username      char(50)   not NULL,</span><br><span class="line">    age           int        not NULL default 18, #使用默认值</span><br><span class="line">    email         char(50)   NULL,</span><br><span class="line">    passward      char(50)   NULL,</span><br><span class="line">    primary key(id) # 定义主键</span><br><span class="line">)engine=InnoDB;</span><br><span class="line"></span><br><span class="line"># 更新表</span><br><span class="line">alter table users</span><br><span class="line">add phone_number char(20); # 表中插入新的列，常用来添加外键</span><br><span class="line"></span><br><span class="line">alter table users</span><br><span class="line">drop column phone_number;# 删除表中的列</span><br><span class="line"></span><br><span class="line"># 删除表</span><br><span class="line">drop table users;</span><br></pre></td></tr></table></figure></li><li><p><strong>子查询</strong></p><ul><li><p><strong>查询</strong>：任何sql语句都是查询，但术语一般指select；</p></li><li><p>子查询：即嵌套在其他查询中的查询；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select username from users </span><br><span class="line">where id in( select id from users</span><br><span class="line">            where username like &#x27;li%&#x27;</span><br><span class="line">); # 由内向外执行</span><br></pre></td></tr></table></figure></li></ul></li><li><p>联结表</p><ul><li><strong>外键</strong>（foreign key）：外键为某个表中的一列，它包含了另一个表的主键值；</li><li>如果数据从存储在多个表中，使用<strong>联结</strong>检索数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># users 和 products两个表</span><br><span class="line">select username,prod_name,prod_price</span><br><span class="line">from users,products</span><br><span class="line">where users.prod_id = products.prod_id  # 为避免歧义，使用完全限定列名</span><br><span class="line">order by username,prod_name;</span><br></pre></td></tr></table></figure></li><li><p>内连接（<code>Inner Join</code>）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> order_id, customer_id, first_name</span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">JOIN</span> customers</span><br><span class="line"><span class="keyword">ON</span> orders.customer_id <span class="operator">=</span> customers.customer_id</span><br></pre></td></tr></table></figure></li><li><p>视图</p><ul><li><p>视图是一种虚拟的表格，它<strong>并不真实存在于数据库中</strong>，但可以像真实的表格一样被查询、更新和操作。</p></li><li><p>特点：</p><ul><li><p>视图是虚拟的，不实际存在于数据库中；</p></li><li><p>隐藏底层数据表中的某些列或行，从而简化复杂的SQL操作；</p></li><li><p>加强数据的安全性，防止用户对敏感数据进行误操作；</p></li></ul></li></ul></li><li><p>使用存储过程</p><ul><li>存储过程：为以后使用而保存的一条或多条MySQL语句的集合。</li><li>特点：<ul><li>可重复使用；</li><li>提高性能；</li><li>安全性高；</li><li>支持事务；</li></ul></li><li>简单来讲，就是数据库 SQL 语言层面的代码封装与重用；</li></ul></li><li><p>使用游标</p><ul><li>游标（Cursor）是一种数据库对象，用于在SQL语句执行过程中，对结果集进行逐行处理。游标可以看作是一个指向结果集中某一行的指针，程序可以使用游标来逐行读取或更新结果集中的数据。</li><li>MySQL游标<strong>只能用于存储过程</strong>；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">-- 定义存储过程</span><br><span class="line">CREATE PROCEDURE count_product_sales()</span><br><span class="line">BEGIN</span><br><span class="line">    -- 定义游标</span><br><span class="line">    DECLARE cur CURSOR FOR SELECT product_id FROM product;</span><br><span class="line">    -- 定义变量</span><br><span class="line">    DECLARE product_id INT;</span><br><span class="line">    DECLARE sales_count INT;</span><br><span class="line">    -- 打开游标</span><br><span class="line">    OPEN cur;</span><br><span class="line">    -- 循环读取数据</span><br><span class="line">    WHILE TRUE DO</span><br><span class="line">        -- 读取数据</span><br><span class="line">        FETCH cur INTO product_id;</span><br><span class="line">        -- 判断是否读取完毕</span><br><span class="line">        IF (SQLSTATE = &#x27;02000&#x27;) THEN</span><br><span class="line">            LEAVE WHILE;</span><br><span class="line">        END IF;</span><br><span class="line">        -- 计算销售数量</span><br><span class="line">        SELECT COUNT(*) INTO sales_count FROM order WHERE product_id = cur_product_id;</span><br><span class="line">        -- 更新产品表格</span><br><span class="line">        UPDATE product SET sales_count = sales_count + sales_count WHERE id = cur_product_id;</span><br><span class="line">    END WHILE;</span><br><span class="line">    -- 关闭游标</span><br><span class="line">    CLOSE cur;</span><br><span class="line">    -- 销毁游标</span><br><span class="line">    DEALLOCATE cur;</span><br><span class="line">END</span><br></pre></td></tr></table></figure></li><li><p>管理事务处理</p><ul><li><p><strong>事务处理</strong>：是一种机制，用来维护数据的完整性，它保证成段的MySQL操作要么完全执行，要么完全不执行。（要么成功，要么不成功）</p></li><li><p>关键词：</p><ul><li>事务（transaction）：指一组SQL语句；</li><li>回退（rollback）：撤销指定SQL语句的过程；</li><li>提交（commit）：指将未存储的SQL语句结果写入数据库表；</li><li>保留点（savepoint）：事务处理中设置的临时占位符；</li></ul></li><li><p>使用<code>rollback</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">delete from users;</span><br><span class="line">rollback; # 回退 start transaction 之后的所有语句</span><br></pre></td></tr></table></figure><p>显然，<code>rollback</code>只能在一个事务内使用；</p><p>可以回退<code>insert</code>，<code>update</code>, <code>delete</code>语句，不能回退<code>select</code> 语句（也没意义）。</p></li><li><p>使用<code>commit</code></p><ul><li>一般的MySQL语句都是针对数据库表执行和操作的，提交操作是自动的，即<strong>隐含提交</strong>；</li><li>事务处理块中必须进行明确的提交，使用<code>commit</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">delete from users where id = 1;</span><br><span class="line">delete from articles where id = 1;</span><br><span class="line">commit; # 如果以上某条语句失败，则commit语句失效</span><br></pre></td></tr></table></figure></li><li><p><strong>隐含事务关闭</strong>：当<code>rollback</code> 和<code>commit</code>执行后，事务会自动关闭（将来的操作变为隐含提交）</p></li><li><p>使用<code>savepoint</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">start transaction;</span><br><span class="line">delete from users where id = 1;</span><br><span class="line">savepoint delete1;</span><br><span class="line">delete from articles where id = 1;</span><br><span class="line">rollback to delete1;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="MySQL存储引擎">MySQL存储引擎</h2><ul><li><p>MySQL 当前默认的存储引擎是 <strong>InnoDB</strong>。</p></li><li><p><strong>InnoDB存储引擎</strong>简介：</p><ul><li>特点：<strong>支持事务，行锁设计，支持外键，支持非锁定读；</strong></li><li>将数据存放在一个逻辑的表空间中，由InnoDB自身管理；将InnoDB存储引擎的表单独存放到一个独立的 <code>ibd </code>文件中。</li><li>InnoDB通过使用多版本并发控制（<strong>MVCC</strong>）来获得高并发性；</li><li>实现了SQL标准的四种隔离级别，默认为<code>REPEATABLE</code>级别;</li><li>使用一种被称为<code>next-key locking</code> 的策略来避免幻读（<code>phantom</code>）现象的产生。</li><li>提供了插入缓存（<code>insert buffer</code>），二次写（<code>double write</code>），自适应哈希索引（<code>adaptive hash index</code>），预读（<code>read ahead</code>）等高性能和高可用的功能。</li></ul></li><li><p><strong>InnoDB体系架构</strong></p><p><img src="C:%5CUsers%5CMistletoe%5CDesktop%5Cwork%5Cimages%5Cmysql02.png" alt=""></p><ul><li><p><strong>内存池</strong>：</p><ul><li>维护进程和线程需要访问的多个内部数据结构；</li><li>缓存磁盘上的数据，在磁盘文件被修改之前进行缓存；</li><li>重做日志（<code>redo log</code>）缓存；</li></ul></li><li><p><strong>后台线程：<strong>InnoDB是</strong>多线程</strong>的模型，因此有多个不同的后台进程，负责处理不同任务。</p><ul><li>主要作用：负责刷新内存池中的数据；将已修改的文件刷新到磁盘文件；保证在数据库发生异常的情况下InnoDB能恢复到正常的状态。</li><li><code>Master Thread</code>：负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性，包括脏页的刷新，合并插入缓存，UNDO页回收；</li><li><code>IO Thread</code>：负责IO请求的回调处理；</li><li><code>Purge Thread</code>：回收已经使用并分配的UNDO页；设置purge Thread可以减轻Master Thread的工作；</li><li><code>Page Cleaner Thread</code>：脏页的刷新操作；</li></ul></li><li><p>内存</p><ul><li><p><strong>缓冲池</strong>：一块内存区域，磁盘读取较慢，因此数据库进行读取页操作时，如果该页在缓冲池中，则称该页被命中，直接读取该页；否则，读取磁盘上的页；<strong>InnoDB存储引擎中，缓冲池中页的大小默认为16KB</strong>；</p><p><strong>缓冲池的设计目的是为了协调CPU速度与磁盘速度之间的鸿沟</strong>。</p></li><li><p>缓冲池的管理：<strong>LRU</strong>（Latest Recently Used）即最频繁使用的页在LRU列表的前端，而最少使用的在尾端；</p></li><li><p>LRU列表中的页被修改之后，称该页为<strong>脏页</strong>（dirty page），即此时<strong>缓冲池中的页和磁盘上的页的数据产生不一致</strong>。</p><p>此时数据库会<strong>通过<code>CHECKPOINT</code>机制将脏页刷新回磁盘</strong>；</p></li><li><p><strong>重做日志缓冲</strong>：将重做日志信息按一定频率刷新到重做日志文件中；</p></li></ul></li><li><p><code>CheckPoint</code>技术</p><ul><li>为了避免数据丢失的情况发生，当前事务数据库系统普遍采用了<strong>Write Ahead Log</strong>的策略，即<strong>当前事务提交时，先写重做日志，再修改页。</strong> 当发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。</li></ul></li></ul></li></ul><h2 id="MySQL索引">MySQL索引</h2><ul><li><p>索引是一种用于快速查询和检索数据的<strong>数据结构</strong>，其本质可以看成是一种排序好的数据结构。</p></li><li><p>分类</p><ul><li>按底层数据结构：哈希索引，B+树索引，B树索引；</li><li>按底层存储方式：聚集索引，非聚集索引；</li><li>按应用维度：主键索引，二级索引；</li></ul></li><li><p>索引优缺点：</p><ul><li>优点：加快数据检索速度；创建唯一索引可以保证数据唯一性；</li><li>缺点：数据更新时，索引也需要更新；耗费一定空间；</li></ul></li><li><p><strong>哈希索引</strong></p><ul><li><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，时间复杂度接近O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash = hashfunc(key)</span><br><span class="line">index = hash % array_size</span><br></pre></td></tr></table></figure><p>哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。</p></li><li><p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“<strong>均匀地</strong>”将数据分布在整个可能的哈希值集合中。</p></li><li><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？<strong>主要是因为 Hash 索引</strong>不支持顺序和范围查询</strong>。</p></li></ul></li><li><p><strong>B树&amp;B+树</strong></p><ul><li><strong>B 树&amp; B+树两者有何异同呢？</strong><ul><li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树<strong>只有叶子节点存放 key 和 data</strong>，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的<strong>顺序检索</strong>很明显。</li></ul></li></ul></li><li><p><strong>主键索引（primary key）</strong></p><ul><li>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</li><li>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</li></ul></li><li><p>二级索引（辅助索引）</p><ul><li>二级索引的叶子节点存储的数据是主键，也就是说通过<strong>二级索引可以定位主键的位置</strong>。</li><li>分类：<ul><li><strong>唯一索引</strong>(Unique Key)：唯一索引的属性列<strong>不能出现重复的数据</strong>，但是<strong>允许数据为 NULL</strong>，一张表<strong>允许创建多个</strong>唯一索引。 建立唯一索引的目的是为了该属性列的<strong>数据的唯一性</strong>。</li><li>普通索引(Index)：普通索引的唯一作用就是为了<strong>快速查询数据</strong>，一张表<strong>允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li>前缀索引(Prefix)：只适用于字符串类型的数据。</li><li>全文索引(Full Text)：为了检索大文本数据中的关键字的信息。</li></ul></li></ul></li><li><p>聚集索引</p><ul><li>聚集索引即<strong>索引结构和数据一起存放的索引</strong>，并不是一种单独的索引类型。InnoDB 中的<strong>主键索引</strong>就属于聚簇索引。</li><li>优缺点<ul><li>优点：查询速度快；对于主键的排序查找和范围查找速度非常快；叶子节点的数据即用户所需数据；</li><li>缺点：如果索引数据不是有序的，需要在插入时进行排序；</li></ul></li></ul></li><li><p>非聚集索引</p><ul><li>非聚集索引即<strong>索引结构和数据分开存放</strong>的索引，并不是一种单独的索引类型。<strong>二级索引</strong>就属于非聚簇索引。</li><li>优缺点<ul><li>优点：由于叶子节点不存放数据，<strong>更新代价比聚集索引要小</strong> ；</li><li>缺点：<strong>需要二次查询</strong>，先找到主键，再根据主键找到数据；</li></ul></li></ul></li><li><p><strong>自适应哈希索引</strong></p><ul><li>数据库本身创建并使用的；</li><li><strong>适合用于等值查询，对于范围查询无能为力；</strong></li></ul></li><li><p>使用索引的一些tips：</p><ul><li>选择合适的字段作为索引：<ul><li>尽量不为Null；</li><li>被频繁查询的字段；</li><li>频繁需要排序的字段，可以利用索引的排序，加快排序速度；</li><li>避免使用频繁更新的字段，因为维护索引的成本也不小；</li></ul></li></ul></li></ul><h2 id="MySQL事务">MySQL事务</h2><ul><li><strong>四大特性（ACID）</strong><ul><li><strong>原子性（Atomicity）</strong><ul><li>事务中的所有操作需要像原子一样不可分割，要么全部执行成功，要么全部失败；</li><li>实现：<strong>undo log</strong> 机制；</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>数据库从一种状态转变为另一种一致的状态；</li><li>如果某个操作失败了，系统可以自动撤销事务；</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>多个事务执行时彼此隔离，不可以互相干扰；</li><li>写+写隔离：<strong>锁机制</strong>；</li><li>写+读隔离：<strong>MVCC</strong>；</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>事务一旦提交，其结果的就是永久性的；</li><li>实现：<strong>redo log 机制</strong></li></ul></li></ul></li><li><strong>三大问题</strong><ul><li><strong>脏读</strong>：事务A读取(<code>SELECT</code>)到了事务B未提交的数据；</li><li><strong>不可重复读</strong>：事务A执行过程中，对同一个数据进行了两次读取(<code>SELECT</code>)，在这两次读取之间，事务B对该数据进行了更新(<code>UPDATE</code>)并完整提交，导致事务A两次读取到的数据不一致；</li><li><strong>幻读</strong>：事务A执行过程中，对同一个集合数据进行两次读取(<code>COUNT</code>)，在这两次读取之间，事务B在该集合中增加(<code>INSERT</code>)或删除(<code>DELETE</code>)了部分数据，导致事务A两次读取到的行数据不一致；</li></ul></li><li><strong>事务的实现</strong><ul><li><strong>Redo Log</strong><ul><li><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</li><li>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的<strong>持久性</strong>与完整性。</li></ul></li><li><strong>Undo Log</strong><ul><li>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过**回滚日志（undo log）**实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</li><li>简单来说，有两个作用：<ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读；</li></ul></li></ul></li></ul></li></ul><h2 id="MySQL锁机制">MySQL锁机制</h2><ul><li><p><strong>锁（Lock）<strong>机制为了支持</strong>对共享资源进行并发访问，提供数据的一致性和完整性</strong>；</p></li><li><p>lock的对象是事务，用来锁定的是数据库中的对象，如表，页，行。并且一般lock的对象仅在事务<code>commit</code>或<code>rollback</code>后进行释放。</p></li><li><p><strong>行级锁</strong></p><ul><li><p><strong>共享锁</strong>（S Lock）：允许事务<strong>读</strong>一行数据；</p></li><li><p><strong>排他锁</strong>（X Lock）：允许事务<strong>删除或更新</strong>一行事务；</p></li><li><p>当一个事务锁定一个行时，其他事务也可以在该行上进行读取操作（<strong>锁兼容</strong>），但是不能进行修改操作（<strong>锁不兼容</strong>），直到持有锁的事务提交或回滚。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">X</th><th style="text-align:center">S</th></tr></thead><tbody><tr><td style="text-align:center">X</td><td style="text-align:center">不兼容</td><td style="text-align:center">不兼容</td></tr><tr><td style="text-align:center">S</td><td style="text-align:center">不兼容</td><td style="text-align:center">兼容</td></tr></tbody></table></li></ul></li><li><p><strong>意向锁</strong></p><ul><li>数据库的层次结构：数据库 $\rightarrow$ 表 $\rightarrow$ 页 $\rightarrow$ 记录(Row)      (粒度：粗 $\rightarrow$ 细)</li><li>意向锁意味着事务希望在更细粒度上进行上锁；</li><li><strong>意向共享锁</strong>（IS Lock）：事务想要获得一张表中某几行的共享锁；（多行）</li><li><strong>意向排他锁</strong>（IX Lock）：事务想要获得一张表中某几行的排他锁；（多行）</li><li><strong>意向锁不会与行级的共享 / 排他锁互斥！！！</strong></li></ul></li><li><p><strong>一致性非锁定读</strong></p><ul><li>如果读取的行正在执行删除或更新操作，这时<strong>不需要等待行上X锁的释放</strong>，而是读取行的一个<strong>快照数据</strong>（即存储在undo log 中的该行的历史数据）</li><li>一个行记录可能有不止一个快照数据，一般称之为行多版本技术；由此带来的并发控制，称为<strong>多版本并发控制(Multi Version Concurrency Control, MVCC)</strong></li></ul></li><li><p><strong>事务隔离级别</strong></p><ul><li><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong>(默认配置) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">READ-UNCOMMITTED</th><th style="text-align:center">READ-COMMITTED</th><th style="text-align:center">REPEATABLE-READ</th><th style="text-align:center">SERIALIZABLE</th></tr></thead><tbody><tr><td style="text-align:center">脏读</td><td style="text-align:center"></td><td style="text-align:center">解决</td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr><tr><td style="text-align:center">不可重复读</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">解决</td><td style="text-align:center">解决</td></tr><tr><td style="text-align:center">幻读</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">解决</td></tr></tbody></table><p>！！！<strong>从左到右，隔离级别越高，并发性能越差</strong>；</p></li><li><p>InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以<strong>解决幻读</strong>问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong> ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li></ul></li></ul></li><li><p><strong>死锁</strong>：</p><ul><li><strong>多个事务在执行过程中，因争夺资源而造成的一种互相等待的现象</strong>；</li><li>解决死锁最简单的方式：<strong>设置超时</strong>；</li></ul></li><li><p><strong>乐观锁和悲观锁</strong></p><ul><li>乐观锁和悲观锁都是并发控制的技术，用于在多个线程或进程同时访问共享资源时保证数据的一致性和完整性。</li><li><strong>悲观锁</strong>认为在并发访问情况下，数据很可能会被其他线程修改，所以在<strong>访问共享资源之前先获取锁，防止其他线程同时修改，从而保证数据的一致性</strong>。悲观锁的实现方式包括数据库中的行级锁、表级锁、读写锁等。</li><li><strong>乐观锁</strong>则认为在并发访问情况下，数据很少被其他线程修改，所以<strong>不需要在访问共享资源之前获取锁，而是在更新数据时检查数据是否被其他线程修改过</strong>，如果没有则更新，否则放弃更新。乐观锁的实现方式包括版本号控制、时间戳控制等。</li><li><strong>悲观锁在高并发场景下会导致性能瓶颈，因为获取锁需要等待其他线程释放锁</strong>，而乐观锁则可以避免这种等待，但是<strong>在数据竞争激烈的情况下，乐观锁的重试机制会导致性能下降。</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo搭建个人博客</title>
      <link href="/2023/06/28/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/06/28/%E5%9F%BA%E4%BA%8Ehexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="环境准备">环境准备</h2><ul><li><p>安装<code>node.js</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nodejs npm</span><br></pre></td></tr></table></figure></li><li><p>查看版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建博客">搭建博客</h2><ul><li><p>安装<code>hexo</code>框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v # 查看版本</span><br></pre></td></tr></table></figure></li><li><p>创建博客的根目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure></li><li><p>搭建<code>hexo</code>博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure></li><li><p>本地端口启动博客！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></li><li><p>创建博客</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;My first Post&quot; # 创建新博客</span><br><span class="line">hexo clean # 清理</span><br><span class="line">hexo generate # 生成</span><br></pre></td></tr></table></figure></li></ul><h2 id="部署到远端">部署到远端</h2><ul><li><p>部署到gitee/github</p><p>创建一个新的仓库，<a href="http://YourGithubName.github.io">YourGithubName.github.io</a>（必须一致！）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-deployer-git #在blog目录下安装git部署插件</span><br></pre></td></tr></table></figure></li><li><p>配置<code>_config.yml</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Deployment</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Docs: https://hexo.io/docs/deployment.html</span></span></span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line"> repo: https://gitee.com/YourGiteeName/YourGiteeName.gitee.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>部署到仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d# 部署到Github仓库里</span><br></pre></td></tr></table></figure></li><li><p>然后就可以通过 <a href="https://YourGithubName.github.io">https://YourGithubName.github.io</a> 地址访问博客啦！</p></li></ul><h2 id="更换主题">更换主题</h2><ul><li><p>下载博客主题</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia  #下载yilia主题到本地</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改hexo根目录下的 _config.yml 文件 ： theme: yilia</span></span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean# 清理一下</span><br><span class="line">hexo generate # 生成</span><br><span class="line">hexo d# 部署到远程Github仓库</span><br></pre></td></tr></table></figure></li></ul><h2 id="搭建个人公网博客">搭建个人公网博客</h2><ul><li><p>本地Linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install git</span><br><span class="line">ssh-keygen -t rsa <span class="comment"># 选择 rsa 保存位置为/root/.ssh/id_rsa</span></span><br><span class="line"><span class="built_in">cat</span> /root/.ssh/id_rsa.pub <span class="comment"># 查看公钥内容(后续添加到远程Linux信任的key里面)</span></span><br></pre></td></tr></table></figure></li><li><p>远程Linux：</p><ul><li><p>创建Git裸仓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt install git</span><br><span class="line">adduser ming <span class="comment"># 创建新用户ming</span></span><br><span class="line">su ming <span class="comment"># 切换用户为ming</span></span><br><span class="line">git init --bare /home/ming/ming.git <span class="comment"># 创建裸git仓库</span></span><br><span class="line"><span class="built_in">ls</span> -l /home/home <span class="comment">#查看生成的文件</span></span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 7 ming ming 4096 Jun 28 00:37 ming.git</span><br></pre></td></tr></table></figure><p>可见 <code>ming.git</code> 的所属用户和用户组都是 <code>ming</code>。 如果创建<code>ming.git</code> 时是root 身份，可用 <code>chown -R ming:ming /home/ming/ming.git </code>更改<code>ming.git</code> 的所属用户和用户组为<code>ming</code>。</p></li><li><p>配置 Git 工作目录:</p><p>该目录用于存放 &quot;本地Linux &quot; 提交上来 (给 远程 Linux) 的 html 等文件，后续安装 Nginx 将该目录下的 html 呈现在公网。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /var/www/minghexo</span><br><span class="line"><span class="built_in">chmod</span> -R 777 /var/www/minghexo</span><br><span class="line">vim /home/ming/ming.git/hooks/post-update <span class="comment"># 配置Git hooks</span></span><br></pre></td></tr></table></figure><p>往<code>post-update </code>种写入 <code>git --work-tree=/var/www/huaehexo --git-dir=/home/huae/huae.git checkout -f </code></p></li><li><p>添加SSH信任</p><p>创建<code>authorized_keys</code>文件，把本地Linux的<code> id_rsa.pub</code> 添加到此 <code>authorized_keys</code>，该<code>id_rsa.pub</code> 对应的（本地Linux）帐户就能提交 git 内容到本远程主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p  /home/ming/.ssh</span><br><span class="line">vim /home/ming/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>此时可以通过<code>ssh &lt;用户名&gt;@&lt;服务器公网IP&gt;</code>测试，如果不需要输入密码并连接成功，则没有问题。</p></li></ul></li><li><p>本地Linux：</p><ul><li><p>配置 <code>hexo</code> 博客使其能自动推送到远程Linux的git仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/blog$ vim _config.yml</span><br></pre></td></tr></table></figure><p>写入内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  <span class="comment"># repo: &lt;git仓库主人&gt;@&lt;远程Linux ip &gt; : &lt;到达 git仓库的路径&gt;</span></span><br><span class="line">  repo: ming@47.110.137.82:/home/ming/ming.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p><code>hexo</code> 博客文件夹中安装 部署工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>执行部署，部署到远程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -d</span><br></pre></td></tr></table></figure></li></ul></li><li><p>远程Linux配置Nginx：</p><ul><li><p>安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nginx</span><br></pre></td></tr></table></figure></li><li><p>配置nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p>在<code>default</code>文件的<code>server&#123;&#125;</code>中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root /var/www/minghexo;</span><br></pre></td></tr></table></figure></li><li><p>注意 <code>/etc/nginx/nginx.conf</code> 文件中 <code>http &#123; &#125; </code>花括号里要填入<code>include /etc/nginx/sites-enabled/*;</code></p></li><li><p>启动nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>​此时用浏览器访问服务器远程IP，就可以访问到博客页面啦！</p><ul><li>参考链接：<a href="https://www.cnblogs.com/Huae/p/16155927.html">Ubuntu 20.4 + Hexo + Nginx 搭建公网博客 - 星云体 - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> nginx </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Restful 风格</title>
      <link href="/2023/06/20/Restful%20%E9%A3%8E%E6%A0%BC/"/>
      <url>/2023/06/20/Restful%20%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="RESTful">RESTful</h2><ul><li><p>REST（Representational State Transfer）：资源以某种表现形式在HTTP方法的作用下发生变化；</p></li><li><p><code>RESTful</code>实践</p><ul><li><p>获取数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &quot;http://localhost:8080/rest/user/1&quot; </span><br></pre></td></tr></table></figure><p>定位id为1的用户（资源），用GET方法获取，查询资源；</p></li><li><p>新增数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST &quot;http://localhost:8080/rest/user&quot;</span><br><span class="line">Content-Type:application/json </span><br><span class="line">&#123;</span><br><span class="line">&quot;name&quot;:&quot;ming&quot;,</span><br><span class="line">&quot;age&quot;:3,</span><br><span class="line">&quot;email&quot;:&quot;ming@test.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>POST方法的参数通常会被放在请求体中，以Content-Type中的格式（JSON）提交到服务端；</p></li><li><p>更新数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT &quot;http://localhost:8080/rest/user&quot;</span><br><span class="line">Content-Type:application/json </span><br><span class="line">&#123;</span><br><span class="line">&quot;id&quot;:1,</span><br><span class="line">&quot;name&quot;:&quot;ming&quot;,</span><br><span class="line">&quot;age&quot;:21,</span><br><span class="line">&quot;email&quot;:&quot;ming@test.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与POST的区别在于请求参数还要指定一个唯一字段（如id）；</p></li><li><p>删除数据</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &quot;http://localhost:8080/rest/user/1&quot; </span><br></pre></td></tr></table></figure></li></ul></li><li><p>RESTful风格由<code>URI</code>定位资源</p><ul><li><code>URI</code>：Uniform Resource Identifier</li><li><code>URL</code>：Uniform Resource Locator</li><li><code>URN</code>：Uniform Resource Name</li></ul><p>所有的<code>URL</code>和<code>URN</code>都可以称为<code>URI</code>；</p><p><code>URL</code>可以定位资源，而<code>URN</code>不行；</p></li></ul><h2 id="spring-中的Restful应用">spring 中的Restful应用</h2><ul><li><p>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userInfo1</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        log.info(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/&#123;age&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userInfo2</span><span class="params">(<span class="meta">@PathVariable</span> Integer age)</span>&#123;</span><br><span class="line">        System.out.println(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/info&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userInfo3</span><span class="params">(String name,Integer age)</span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot; &quot;</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求方式</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET localhost:8888/user</span><br></pre></td></tr></table></figure><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST localhost:8888/user</span><br><span class="line">Content-Type:application/json </span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;:&quot;ming&quot;,</span><br><span class="line">    &quot;age&quot;:&quot;20&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求路径传参</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST localhost:8888/user/20</span><br></pre></td></tr></table></figure></li><li><p>普通路径传参</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST localhost:8888/user/info?name=ming&amp;age=20</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
